{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst semver = require(\"semver\");\n\nconst call_credentials_1 = require(\"./call-credentials\");\n\nexports.CallCredentials = call_credentials_1.CallCredentials;\n\nconst channel_1 = require(\"./channel\");\n\nexports.connectivityState = channel_1.ConnectivityState;\nexports.Channel = channel_1.Http2Channel;\n\nconst channel_credentials_1 = require(\"./channel-credentials\");\n\nexports.ChannelCredentials = channel_credentials_1.ChannelCredentials;\n\nconst client_1 = require(\"./client\");\n\nexports.Client = client_1.Client;\n\nconst constants_1 = require(\"./constants\");\n\nexports.logVerbosity = constants_1.LogVerbosity;\nexports.status = constants_1.Status;\n\nconst logging = require(\"./logging\");\n\nconst make_client_1 = require(\"./make-client\");\n\nexports.loadPackageDefinition = make_client_1.loadPackageDefinition;\nexports.makeClientConstructor = make_client_1.makeClientConstructor;\nexports.makeGenericClientConstructor = make_client_1.makeClientConstructor;\n\nconst metadata_1 = require(\"./metadata\");\n\nexports.Metadata = metadata_1.Metadata;\n\nconst server_credentials_1 = require(\"./server-credentials\");\n\nexports.ServerCredentials = server_credentials_1.ServerCredentials;\n\nconst status_builder_1 = require(\"./status-builder\");\n\nexports.StatusBuilder = status_builder_1.StatusBuilder;\n\nconst supportedNodeVersions = require('../../package.json').engines.node;\n\nif (!semver.satisfies(process.version, supportedNodeVersions)) {\n  throw new Error(\"@grpc/grpc-js only works on Node \".concat(supportedNodeVersions));\n}\n\nfunction mixin(...sources) {\n  const result = {};\n\n  for (const source of sources) {\n    for (const propName of Object.getOwnPropertyNames(source)) {\n      const property = source[propName]; // tslint:disable-line no-any\n\n      if (typeof property === 'function') {\n        result[propName] = property;\n      }\n    }\n  }\n\n  return result;\n}\n/**** Client Credentials ****/\n// Using assign only copies enumerable properties, which is what we want\n\n\nexports.credentials = mixin({\n  /**\n   * Create a gRPC credential from a Google credential object.\n   * @param googleCredentials The authentication client to use.\n   * @return The resulting CallCredentials object.\n   */\n  createFromGoogleCredential: googleCredentials => {\n    return call_credentials_1.CallCredentials.createFromMetadataGenerator((options, callback) => {\n      // google-auth-library pre-v2.0.0 does not have getRequestHeaders\n      // but has getRequestMetadata, which is deprecated in v2.0.0\n      let getHeaders;\n\n      if (typeof googleCredentials.getRequestHeaders === 'function') {\n        getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n      } else {\n        getHeaders = new Promise((resolve, reject) => {\n          googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n            if (err) {\n              reject(err);\n              return;\n            }\n\n            resolve(headers);\n          });\n        });\n      }\n\n      getHeaders.then(headers => {\n        const metadata = new metadata_1.Metadata();\n        metadata.add('authorization', headers.Authorization);\n        callback(null, metadata);\n      }, err => {\n        callback(err);\n      });\n    });\n  },\n\n  /**\n   * Combine a ChannelCredentials with any number of CallCredentials into a\n   * single ChannelCredentials object.\n   * @param channelCredentials The ChannelCredentials object.\n   * @param callCredentials Any number of CallCredentials objects.\n   * @return The resulting ChannelCredentials object.\n   */\n  combineChannelCredentials: (channelCredentials, ...callCredentials) => {\n    return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);\n  },\n\n  /**\n   * Combine any number of CallCredentials into a single CallCredentials\n   * object.\n   * @param first The first CallCredentials object.\n   * @param additional Any number of additional CallCredentials objects.\n   * @return The resulting CallCredentials object.\n   */\n  combineCallCredentials: (first, ...additional) => {\n    return additional.reduce((acc, other) => acc.compose(other), first);\n  }\n}, channel_credentials_1.ChannelCredentials, call_credentials_1.CallCredentials);\n/**\n * Close a Client object.\n * @param client The client to close.\n */\n\nexports.closeClient = client => client.close();\n\nexports.waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);\n/**** Unimplemented function stubs ****/\n\n/* tslint:disable:no-any variable-name */\n\n\nexports.loadObject = (value, options) => {\n  throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\n\nexports.load = (filename, format, options) => {\n  throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\n\nexports.setLogger = logger => {\n  logging.setLogger(logger);\n};\n\nexports.setLogVerbosity = verbosity => {\n  logging.setLoggerVerbosity(verbosity);\n};\n\nexports.Server = options => {\n  throw new Error('Not yet implemented');\n};\n\nexports.getClientChannel = client => {\n  return client_1.Client.prototype.getChannel.call(client);\n};\n\nexports.ListenerBuilder = () => {\n  throw new Error('Not yet implemented');\n};\n\nexports.InterceptorBuilder = () => {\n  throw new Error('Not yet implemented');\n};\n\nexports.InterceptingCall = () => {\n  throw new Error('Not yet implemented');\n};","map":null,"metadata":{},"sourceType":"script"}