{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst ConfigStore = require(\"configstore\");\n\nconst crypto_1 = require(\"crypto\");\n\nconst google_auth_library_1 = require(\"google-auth-library\");\n\nconst Pumpify = require(\"pumpify\");\n\nconst stream_1 = require(\"stream\");\n\nconst streamEvents = require(\"stream-events\");\n\nconst BASE_URI = 'https://www.googleapis.com/upload/storage/v1/b';\nconst TERMINATED_UPLOAD_STATUS_CODE = 410;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst RETRY_LIMIT = 5;\n\nclass Upload extends Pumpify {\n  constructor(cfg) {\n    super();\n    this.numBytesWritten = 0;\n    this.numRetries = 0;\n    streamEvents(this);\n    cfg = cfg || {};\n\n    if (!cfg.bucket || !cfg.file) {\n      throw new Error('A bucket and file name are required');\n    }\n\n    cfg.authConfig = cfg.authConfig || {};\n    cfg.authConfig.scopes = ['https://www.googleapis.com/auth/devstorage.full_control'];\n    this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n    this.bucket = cfg.bucket;\n    this.file = cfg.file;\n    this.generation = cfg.generation;\n    this.kmsKeyName = cfg.kmsKeyName;\n    this.metadata = cfg.metadata || {};\n    this.offset = cfg.offset;\n    this.origin = cfg.origin;\n    this.userProject = cfg.userProject;\n\n    if (cfg.key) {\n      /**\n       * NOTE: This is `as string` because there appears to be some weird kind\n       * of TypeScript bug as 2.8. Tracking the issue here:\n       * https://github.com/Microsoft/TypeScript/issues/23155\n       */\n      const base64Key = Buffer.from(cfg.key).toString('base64');\n      this.encryption = {\n        key: base64Key,\n        hash: crypto_1.createHash('sha256').update(cfg.key).digest('base64')\n      };\n    }\n\n    this.predefinedAcl = cfg.predefinedAcl;\n    if (cfg.private) this.predefinedAcl = 'private';\n    if (cfg.public) this.predefinedAcl = 'publicRead';\n    const configPath = cfg.configPath;\n    this.configStore = new ConfigStore('gcs-resumable-upload', {\n      configPath\n    });\n    this.uriProvidedManually = !!cfg.uri;\n    this.uri = cfg.uri || this.get('uri');\n    this.numBytesWritten = 0;\n    this.numRetries = 0;\n    const contentLength = cfg.metadata ? Number(cfg.metadata.contentLength) : NaN;\n    this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n    this.once('writing', () => {\n      if (this.uri) {\n        this.continueUploading();\n      } else {\n        this.createURI(err => {\n          if (err) {\n            return this.destroy(err);\n          }\n\n          this.startUploading();\n        });\n      }\n    });\n  }\n\n  createURI(callback) {\n    if (!callback) {\n      return this.createURIAsync();\n    }\n\n    this.createURIAsync().then(r => callback(null, r), callback);\n  }\n\n  createURIAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const metadata = this.metadata;\n      const reqOpts = {\n        method: 'POST',\n        url: [BASE_URI, this.bucket, 'o'].join('/'),\n        params: {\n          name: this.file,\n          uploadType: 'resumable'\n        },\n        data: metadata,\n        headers: {}\n      };\n\n      if (metadata.contentLength) {\n        reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n      }\n\n      if (metadata.contentType) {\n        reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n      }\n\n      if (typeof this.generation !== 'undefined') {\n        reqOpts.params.ifGenerationMatch = this.generation;\n      }\n\n      if (this.kmsKeyName) {\n        reqOpts.params.kmsKeyName = this.kmsKeyName;\n      }\n\n      if (this.predefinedAcl) {\n        reqOpts.params.predefinedAcl = this.predefinedAcl;\n      }\n\n      if (this.origin) {\n        reqOpts.headers.Origin = this.origin;\n      }\n\n      const resp = yield this.makeRequest(reqOpts);\n      const uri = resp.headers.location;\n      this.uri = uri;\n      this.set({\n        uri\n      });\n      this.offset = 0;\n      return uri;\n    });\n  }\n\n  continueUploading() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.offset === 'number') {\n        this.startUploading();\n        return;\n      }\n\n      yield this.getAndSetOffset();\n      this.startUploading();\n    });\n  }\n\n  startUploading() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // The buffer stream allows us to keep chunks in memory\n      // until we are sure we can successfully resume the upload.\n      const bufferStream = this.bufferStream || new stream_1.PassThrough();\n      this.bufferStream = bufferStream; // The offset stream allows us to analyze each incoming\n      // chunk to analyze it against what the upstream API already\n      // has stored for this upload.\n\n      const offsetStream = this.offsetStream = new stream_1.Transform({\n        transform: this.onChunk.bind(this)\n      }); // The delay stream gives us a chance to catch the response\n      // from the API request before we signal to the user that\n      // the upload was successful.\n\n      const delayStream = new stream_1.PassThrough(); // The request library (authClient.request()) requires the\n      // stream to be sent within the request options.\n\n      const requestStreamEmbeddedStream = new stream_1.PassThrough();\n      delayStream.on('prefinish', () => {\n        // Pause the stream from finishing so we can process the\n        // response from the API.\n        this.cork();\n      }); // Process the API response to look for errors that came in\n      // the response body.\n\n      this.on('response', resp => {\n        if (resp.data.error) {\n          this.destroy(resp.data.error);\n          return;\n        }\n\n        if (resp.status < 200 || resp.status > 299) {\n          this.destroy(new Error('Upload failed'));\n          return;\n        }\n\n        this.emit('metadata', resp.data);\n        this.deleteConfig(); // Allow the stream to continue naturally so the user's\n        // \"finish\" event fires.\n\n        this.uncork();\n      });\n      this.setPipeline(bufferStream, offsetStream, delayStream);\n      this.pipe(requestStreamEmbeddedStream);\n      this.once('restart', () => {\n        // The upload is being re-attempted. Disconnect the request\n        // stream, so it won't receive more data.\n        this.unpipe(requestStreamEmbeddedStream);\n      });\n      const reqOpts = {\n        method: 'PUT',\n        url: this.uri,\n        headers: {\n          'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength\n        },\n        body: requestStreamEmbeddedStream\n      };\n\n      try {\n        yield this.makeRequestStream(reqOpts);\n      } catch (e) {\n        this.destroy(e);\n      }\n    });\n  }\n\n  onChunk(chunk, enc, next) {\n    const offset = this.offset;\n    const numBytesWritten = this.numBytesWritten;\n    this.emit('progress', {\n      bytesWritten: this.numBytesWritten,\n      contentLength: this.contentLength\n    }); // check if this is the same content uploaded previously. this caches a\n    // slice of the first chunk, then compares it with the first byte of\n    // incoming data\n\n    if (numBytesWritten === 0) {\n      let cachedFirstChunk = this.get('firstChunk');\n      const firstChunk = chunk.slice(0, 16).valueOf();\n\n      if (!cachedFirstChunk) {\n        // This is a new upload. Cache the first chunk.\n        this.set({\n          uri: this.uri,\n          firstChunk\n        });\n      } else {\n        // this continues an upload in progress. check if the bytes are the same\n        cachedFirstChunk = Buffer.from(cachedFirstChunk);\n        const nextChunk = Buffer.from(firstChunk);\n\n        if (Buffer.compare(cachedFirstChunk, nextChunk) !== 0) {\n          // this data is not the same. start a new upload\n          this.bufferStream.unshift(chunk);\n          this.bufferStream.unpipe(this.offsetStream);\n          this.restart();\n          return;\n        }\n      }\n    }\n\n    let length = chunk.length;\n    if (typeof chunk === 'string') length = Buffer.byteLength(chunk, enc);\n    if (numBytesWritten < offset) chunk = chunk.slice(offset - numBytesWritten);\n    this.numBytesWritten += length; // only push data from the byte after the one we left off on\n\n    next(undefined, this.numBytesWritten > offset ? chunk : undefined);\n  }\n\n  getAndSetOffset() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const opts = {\n        method: 'PUT',\n        url: this.uri,\n        headers: {\n          'Content-Length': 0,\n          'Content-Range': 'bytes */*'\n        }\n      };\n\n      try {\n        const resp = yield this.makeRequest(opts);\n\n        if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n          if (resp.headers.range) {\n            const range = resp.headers.range;\n            this.offset = Number(range.split('-')[1]) + 1;\n            return;\n          }\n        }\n\n        this.offset = 0;\n      } catch (err) {\n        const resp = err.response; // we don't return a 404 to the user if they provided the resumable\n        // URI. if we're just using the configstore file to tell us that this\n        // file exists, and it turns out that it doesn't (the 404), that's\n        // probably stale config data.\n\n        if (resp && resp.status === 404 && !this.uriProvidedManually) {\n          this.restart();\n          return;\n        } // this resumable upload is unrecoverable (bad data or service error).\n        //  -\n        //  https://github.com/stephenplusplus/gcs-resumable-upload/issues/15\n        //  -\n        //  https://github.com/stephenplusplus/gcs-resumable-upload/pull/16#discussion_r80363774\n\n\n        if (resp && resp.status === TERMINATED_UPLOAD_STATUS_CODE) {\n          this.restart();\n          return;\n        }\n\n        this.destroy(err);\n      }\n    });\n  }\n\n  makeRequest(reqOpts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.encryption) {\n        reqOpts.headers = reqOpts.headers || {};\n        reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n        reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n        reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n      }\n\n      if (this.userProject) {\n        reqOpts.params = reqOpts.params || {};\n        reqOpts.params.userProject = this.userProject;\n      }\n\n      reqOpts.validateStatus = () => true;\n\n      const res = yield this.authClient.request(reqOpts);\n\n      if (res.data && res.data.error) {\n        throw res.data.error;\n      } // If no error was returned, but the response had an invalid status\n      // code, create a new error to be passed to the callback.\n\n\n      if ((res.status < 200 || res.status >= 300) && res.status !== RESUMABLE_INCOMPLETE_STATUS_CODE) {\n        const e = new Error(\"The request failed with a \".concat(res.status, \".\"));\n        e.code = res.status;\n      }\n\n      return res;\n    });\n  }\n\n  makeRequestStream(reqOpts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const controller = new abort_controller_1.default();\n      this.once('error', () => controller.abort());\n\n      if (this.userProject) {\n        reqOpts.params = reqOpts.params || {};\n        reqOpts.params.userProject = this.userProject;\n      }\n\n      reqOpts.signal = controller.signal;\n\n      reqOpts.validateStatus = () => true;\n\n      const res = yield this.authClient.request(reqOpts);\n      this.onResponse(res);\n      return res;\n    });\n  }\n\n  restart() {\n    this.emit('restart');\n    this.numBytesWritten = 0;\n    this.deleteConfig();\n    this.createURI(err => {\n      if (err) {\n        return this.destroy(err);\n      }\n\n      this.startUploading();\n    });\n  }\n\n  get(prop) {\n    const store = this.configStore.get([this.bucket, this.file].join('/'));\n    return store && store[prop];\n  } // tslint:disable-next-line no-any\n\n\n  set(props) {\n    this.configStore.set([this.bucket, this.file].join('/'), props);\n  }\n\n  deleteConfig() {\n    this.configStore.delete([this.bucket, this.file].join('/'));\n  }\n  /**\n   * @return {bool} is the request good?\n   */\n\n\n  onResponse(resp) {\n    if (resp.status === 404) {\n      if (this.numRetries < RETRY_LIMIT) {\n        this.numRetries++;\n        this.startUploading();\n      } else {\n        this.destroy(new Error('Retry limit exceeded'));\n      }\n\n      return false;\n    }\n\n    if (resp.status > 499 && resp.status < 600) {\n      if (this.numRetries < RETRY_LIMIT) {\n        const randomMs = Math.round(Math.random() * 1000);\n        const waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs;\n        this.numRetries++;\n        setTimeout(this.continueUploading.bind(this), waitTime);\n      } else {\n        this.destroy(new Error('Retry limit exceeded'));\n      }\n\n      return false;\n    }\n\n    this.emit('response', resp);\n    return true;\n  }\n\n}\n\nexports.Upload = Upload;\n\nfunction upload(cfg) {\n  return new Upload(cfg);\n}\n\nexports.upload = upload;\n\nfunction createURI(cfg, callback) {\n  const up = new Upload(cfg);\n\n  if (!callback) {\n    return up.createURI();\n  }\n\n  up.createURI().then(r => callback(null, r), callback);\n}\n\nexports.createURI = createURI;","map":null,"metadata":{},"sourceType":"script"}