{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\md_sh\\\\OneDrive\\\\Desktop\\\\verycoolmathgames.github.io\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst deepEqual = require('deep-equal');\n\nconst assert = require(\"assert\");\n\nconst field_value_1 = require(\"./field-value\");\n\nconst path_1 = require(\"./path\");\n\nconst serializer_1 = require(\"./serializer\");\n\nconst util_1 = require(\"./util\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n */\n\n\nclass DocumentSnapshotBuilder {\n  /**\n   * Builds the DocumentSnapshot.\n   *\n   * @private\n   * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n   * provided) or a DocumentSnapshot.\n   */\n  build() {\n    assert(this.fieldsProto !== undefined === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n    assert(this.fieldsProto !== undefined === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n    return this.fieldsProto ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime) : new DocumentSnapshot(this.ref, undefined, this.readTime);\n  }\n\n}\n\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class\n */\n\nclass DocumentSnapshot {\n  /**\n   * @hideconstructor\n   *\n   * @param ref The reference to the document.\n   * @param fieldsProto The fields of the Firestore `Document` Protobuf backing\n   * this document (or undefined if the document does not exist).\n   * @param readTime The time when this snapshot was read  (or undefined if\n   * the document exists only locally).\n   * @param createTime The time when the document was created (or undefined if\n   * the document does not exist).\n   * @param updateTime The time when the document was last updated (or undefined\n   * if the document does not exist).\n   */\n  constructor(ref, fieldsProto, readTime, createTime, updateTime) {\n    this._ref = ref;\n    this._fieldsProto = fieldsProto;\n    this._serializer = ref.firestore._serializer;\n    this._readTime = readTime;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n  }\n  /**\n   * Creates a DocumentSnapshot from an object.\n   *\n   * @private\n   * @param ref The reference to the document.\n   * @param obj The object to store in the DocumentSnapshot.\n   * @return The created DocumentSnapshot.\n   */\n\n\n  static fromObject(ref, obj) {\n    const serializer = ref.firestore._serializer;\n    return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n  }\n  /**\n   * Creates a DocumentSnapshot from an UpdateMap.\n   *\n   * This methods expands the top-level field paths in a JavaScript map and\n   * turns { foo.bar : foobar } into { foo { bar : foobar }}\n   *\n   * @private\n   * @param ref The reference to the document.\n   * @param data The field/value map to expand.\n   * @return The created DocumentSnapshot.\n   */\n\n\n  static fromUpdateMap(ref, data) {\n    const serializer = ref.firestore._serializer;\n    /**\n     * Merges 'value' at the field path specified by the path array into\n     * 'target'.\n     */\n\n    function merge(target, value, path, pos) {\n      const key = path[pos];\n      const isLast = pos === path.length - 1;\n\n      if (target[key] === undefined) {\n        if (isLast) {\n          if (value instanceof field_value_1.FieldTransform) {\n            // If there is already data at this path, we need to retain it.\n            // Otherwise, we don't include it in the DocumentSnapshot.\n            return !util_1.isEmpty(target) ? target : null;\n          } // The merge is done.\n\n\n          const leafNode = serializer.encodeValue(value);\n\n          if (leafNode) {\n            target[key] = leafNode;\n          }\n\n          return target;\n        } else {\n          // We need to expand the target object.\n          const childNode = {\n            mapValue: {\n              fields: {}\n            }\n          };\n          const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n\n          if (nestedValue) {\n            childNode.mapValue.fields = nestedValue;\n            target[key] = childNode;\n            return target;\n          } else {\n            return !util_1.isEmpty(target) ? target : null;\n          }\n        }\n      } else {\n        assert(!isLast, \"Can't merge current value into a nested object\");\n        target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n        return target;\n      }\n    }\n\n    const res = {};\n\n    for (const _ref of data) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      const key = _ref2[0];\n      const value = _ref2[1];\n      const path = key.toArray();\n      merge(res, value, path, 0);\n    }\n\n    return new DocumentSnapshot(ref, res);\n  }\n  /**\n   * True if the document exists.\n   *\n   * @type {boolean}\n   * @name DocumentSnapshot#exists\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n   *   }\n   * });\n   */\n\n\n  get exists() {\n    return this._fieldsProto !== undefined;\n  }\n  /**\n   * A [DocumentReference]{@link DocumentReference} for the document\n   * stored in this snapshot.\n   *\n   * @type {DocumentReference}\n   * @name DocumentSnapshot#ref\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n   *   }\n   * });\n   */\n\n\n  get ref() {\n    return this._ref;\n  }\n  /**\n   * The ID of the document for which this DocumentSnapshot contains data.\n   *\n   * @type {string}\n   * @name DocumentSnapshot#id\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Document found with name '${documentSnapshot.id}'`);\n   *   }\n   * });\n   */\n\n\n  get id() {\n    return this._ref.id;\n  }\n  /**\n   * The time the document was created. Undefined for documents that don't\n   * exist.\n   *\n   * @type {Timestamp|undefined}\n   * @name DocumentSnapshot#createTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     let createTime = documentSnapshot.createTime;\n   *     console.log(`Document created at '${createTime.toDate()}'`);\n   *   }\n   * });\n   */\n\n\n  get createTime() {\n    return this._createTime;\n  }\n  /**\n   * The time the document was last updated (at the time the snapshot was\n   * generated). Undefined for documents that don't exist.\n   *\n   * @type {Timestamp|undefined}\n   * @name DocumentSnapshot#updateTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     let updateTime = documentSnapshot.updateTime;\n   *     console.log(`Document updated at '${updateTime.toDate()}'`);\n   *   }\n   * });\n   */\n\n\n  get updateTime() {\n    return this._updateTime;\n  }\n  /**\n   * The time this snapshot was read.\n   *\n   * @type {Timestamp}\n   * @name DocumentSnapshot#readTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   let readTime = documentSnapshot.readTime;\n   *   console.log(`Document read at '${readTime.toDate()}'`);\n   * });\n   */\n\n\n  get readTime() {\n    if (this._readTime === undefined) {\n      throw new Error(\"Called 'readTime' on a local document\");\n    }\n\n    return this._readTime;\n  }\n  /**\n   * Retrieves all fields in the document as an object. Returns 'undefined' if\n   * the document doesn't exist.\n   *\n   * @returns {DocumentData|undefined} An object containing all fields in the\n   * document or 'undefined' if the document doesn't exist.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   let data = documentSnapshot.data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // tslint:disable-next-line no-any\n\n\n  data() {\n    // tslint:disable-line no-any\n    const fields = this._fieldsProto;\n\n    if (fields === undefined) {\n      return undefined;\n    }\n\n    const obj = {};\n\n    for (const prop in fields) {\n      if (fields.hasOwnProperty(prop)) {\n        obj[prop] = this._serializer.decodeValue(fields[prop]);\n      }\n    }\n\n    return obj;\n  }\n  /**\n   * Retrieves the field specified by `field`.\n   *\n   * @param {string|FieldPath} field The field path\n   * (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns {*} The data at the specified field location or undefined if no\n   * such field exists.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({ a: { b: 'c' }}).then(() => {\n   *   return documentRef.get();\n   * }).then(documentSnapshot => {\n   *   let field = documentSnapshot.get('a.b');\n   *   console.log(`Retrieved field value: ${field}`);\n   * });\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // tslint:disable-next-line no-any\n\n\n  get(field) {\n    // tslint:disable-line no-any\n    path_1.validateFieldPath('field', field);\n    const protoField = this.protoField(field);\n\n    if (protoField === undefined) {\n      return undefined;\n    }\n\n    return this._serializer.decodeValue(protoField);\n  }\n  /**\n   * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n   * representation.\n   *\n   * @private\n   * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns The Protobuf-encoded data at the specified field location or\n   * undefined if no such field exists.\n   */\n\n\n  protoField(field) {\n    let fields = this._fieldsProto;\n\n    if (fields === undefined) {\n      return undefined;\n    }\n\n    const components = path_1.FieldPath.fromArgument(field).toArray();\n\n    while (components.length > 1) {\n      fields = fields[components.shift()];\n\n      if (!fields || !fields.mapValue) {\n        return undefined;\n      }\n\n      fields = fields.mapValue.fields;\n    }\n\n    return fields[components[0]];\n  }\n  /**\n   * Checks whether this DocumentSnapshot contains any fields.\n   *\n   * @private\n   * @return {boolean}\n   */\n\n\n  get isEmpty() {\n    return this._fieldsProto === undefined || util_1.isEmpty(this._fieldsProto);\n  }\n  /**\n   * Convert a document snapshot to the Firestore 'Document' Protobuf.\n   *\n   * @private\n   * @returns The document in the format the API expects.\n   */\n\n\n  toProto() {\n    return {\n      update: {\n        name: this._ref.formattedName,\n        fields: this._fieldsProto\n      }\n    };\n  }\n  /**\n   * Returns true if the document's data and path in this `DocumentSnapshot` is\n   * equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n   * value.\n   */\n\n\n  isEqual(other) {\n    // Since the read time is different on every document read, we explicitly\n    // ignore all document metadata in this comparison.\n    return this === other || other instanceof DocumentSnapshot && this._ref.isEqual(other._ref) && deepEqual(this._fieldsProto, other._fieldsProto, {\n      strict: true\n    });\n  }\n\n}\n\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class\n * @extends DocumentSnapshot\n */\n\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n  /**\n   * @hideconstructor\n   *\n   * @param ref The reference to the document.\n   * @param fieldsProto The fields of the Firestore `Document` Protobuf backing\n   * this document.\n   * @param readTime The time when this snapshot was read.\n   * @param createTime The time when the document was created.\n   * @param updateTime The time when the document was last updated.\n   */\n  constructor(ref, fieldsProto, readTime, createTime, updateTime) {\n    super(ref, fieldsProto, readTime, createTime, updateTime);\n  }\n  /**\n   * The time the document was created.\n   *\n   * @type {Timestamp}\n   * @name QueryDocumentSnapshot#createTime\n   * @readonly\n   * @override\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(snapshot => {\n   *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n   * });\n   */\n\n\n  get createTime() {\n    return super.createTime;\n  }\n  /**\n   * The time the document was last updated (at the time the snapshot was\n   * generated).\n   *\n   * @type {Timestamp}\n   * @name QueryDocumentSnapshot#updateTime\n   * @readonly\n   * @override\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(snapshot => {\n   *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n   * });\n   */\n\n\n  get updateTime() {\n    return super.updateTime;\n  }\n  /**\n   * Retrieves all fields in the document as an object.\n   *\n   * @override\n   *\n   * @returns {DocumentData} An object containing all fields in the document.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(documentSnapshot => {\n   *   let data = documentSnapshot.data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   */\n\n\n  data() {\n    const data = super.data();\n\n    if (!data) {\n      throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n    }\n\n    return data;\n  }\n\n}\n\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n */\n\nclass DocumentMask {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param fieldPaths The field paths in this mask.\n   */\n  constructor(fieldPaths) {\n    this._sortedPaths = fieldPaths;\n\n    this._sortedPaths.sort((a, b) => a.compareTo(b));\n  }\n  /**\n   * Creates a document mask with the field paths of a document.\n   *\n   * @private\n   * @param data A map with fields to modify. Only the keys are used to extract\n   * the document mask.\n   */\n\n\n  static fromUpdateMap(data) {\n    const fieldPaths = [];\n    data.forEach((value, key) => {\n      if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n        fieldPaths.push(path_1.FieldPath.fromArgument(key));\n      }\n    });\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Creates a document mask from an array of field paths.\n   *\n   * @private\n   * @param fieldMask A list of field paths.\n   */\n\n\n  static fromFieldMask(fieldMask) {\n    const fieldPaths = [];\n\n    for (const fieldPath of fieldMask) {\n      fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n    }\n\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Creates a document mask with the field names of a document.\n   *\n   * @private\n   * @param data An object with fields to modify. Only the keys are used to\n   * extract the document mask.\n   */\n\n\n  static fromObject(data) {\n    const fieldPaths = [];\n\n    function extractFieldPaths(currentData, currentPath) {\n      let isEmpty = true;\n\n      for (const key in currentData) {\n        if (currentData.hasOwnProperty(key)) {\n          isEmpty = false; // We don't split on dots since fromObject is called with\n          // DocumentData.\n\n          const childSegment = new path_1.FieldPath(key);\n          const childPath = currentPath ? currentPath.append(childSegment) : childSegment;\n          const value = currentData[key];\n\n          if (value instanceof field_value_1.FieldTransform) {\n            if (value.includeInDocumentMask) {\n              fieldPaths.push(childPath);\n            }\n          } else if (serializer_1.isPlainObject(value)) {\n            extractFieldPaths(value, childPath);\n          } else {\n            fieldPaths.push(childPath);\n          }\n        }\n      } // Add a field path for an explicitly updated empty map.\n\n\n      if (currentPath && isEmpty) {\n        fieldPaths.push(currentPath);\n      }\n    }\n\n    extractFieldPaths(data);\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Returns true if this document mask contains no fields.\n   *\n   * @private\n   * @return {boolean} Whether this document mask is empty.\n   */\n\n\n  get isEmpty() {\n    return this._sortedPaths.length === 0;\n  }\n  /**\n   * Removes the specified values from a sorted field path array.\n   *\n   * @private\n   * @param input A sorted array of FieldPaths.\n   * @param values An array of FieldPaths to remove.\n   */\n\n\n  static removeFromSortedArray(input, values) {\n    for (let i = 0; i < input.length;) {\n      let removed = false;\n\n      for (const fieldPath of values) {\n        if (input[i].isEqual(fieldPath)) {\n          input.splice(i, 1);\n          removed = true;\n          break;\n        }\n      }\n\n      if (!removed) {\n        ++i;\n      }\n    }\n  }\n  /**\n   * Removes the field path specified in 'fieldPaths' from this document mask.\n   *\n   * @private\n   * @param fieldPaths An array of FieldPaths.\n   */\n\n\n  removeFields(fieldPaths) {\n    DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n  }\n  /**\n   * Returns whether this document mask contains 'fieldPath'.\n   *\n   * @private\n   * @param fieldPath The field path to test.\n   * @return Whether this document mask contains 'fieldPath'.\n   */\n\n\n  contains(fieldPath) {\n    for (const sortedPath of this._sortedPaths) {\n      const cmp = sortedPath.compareTo(fieldPath);\n\n      if (cmp === 0) {\n        return true;\n      } else if (cmp > 0) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Removes all properties from 'data' that are not contained in this document\n   * mask.\n   *\n   * @private\n   * @param data An object to filter.\n   * @return A shallow copy of the object filtered by this document mask.\n   */\n\n\n  applyTo(data) {\n    /*!\n     * Applies this DocumentMask to 'data' and computes the list of field paths\n     * that were specified in the mask but are not present in 'data'.\n     */\n    const applyDocumentMask = data => {\n      const remainingPaths = this._sortedPaths.slice(0);\n\n      const processObject = (currentData, currentPath) => {\n        let result = null;\n        Object.keys(currentData).forEach(key => {\n          const childPath = currentPath ? currentPath.append(key) : new path_1.FieldPath(key);\n\n          if (this.contains(childPath)) {\n            DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n            result = result || {};\n            result[key] = currentData[key];\n          } else if (util_1.isObject(currentData[key])) {\n            const childObject = processObject(currentData[key], childPath);\n\n            if (childObject) {\n              result = result || {};\n              result[key] = childObject;\n            }\n          }\n        });\n        return result;\n      }; // processObject() returns 'null' if the DocumentMask is empty.\n\n\n      const filteredData = processObject(data) || {};\n      return {\n        filteredData,\n        remainingPaths\n      };\n    };\n\n    const result = applyDocumentMask(data);\n\n    if (result.remainingPaths.length !== 0) {\n      throw new Error(\"Input data is missing for field \\\"\".concat(result.remainingPaths[0], \"\\\".\"));\n    }\n\n    return result.filteredData;\n  }\n  /**\n   * Converts a document mask to the Firestore 'DocumentMask' Proto.\n   *\n   * @private\n   * @returns A Firestore 'DocumentMask' Proto.\n   */\n\n\n  toProto() {\n    if (this.isEmpty) {\n      return {};\n    }\n\n    const encodedPaths = [];\n\n    for (const fieldPath of this._sortedPaths) {\n      encodedPaths.push(fieldPath.formattedName);\n    }\n\n    return {\n      fieldPaths: encodedPaths\n    };\n  }\n\n}\n\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @class\n */\n\nclass DocumentTransform {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param ref The DocumentReference for this transform.\n   * @param transforms A Map of FieldPaths to FieldTransforms.\n   */\n  constructor(ref, transforms) {\n    this.ref = ref;\n    this.transforms = transforms;\n  }\n  /**\n   * Generates a DocumentTransform from a JavaScript object.\n   *\n   * @private\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param obj The object to extract the transformations from.\n   * @returns The Document Transform.\n   */\n\n\n  static fromObject(ref, obj) {\n    const updateMap = new Map();\n\n    for (const prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n      }\n    }\n\n    return DocumentTransform.fromUpdateMap(ref, updateMap);\n  }\n  /**\n   * Generates a DocumentTransform from an Update Map.\n   *\n   * @private\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param data The update data to extract the transformations from.\n   * @returns The Document Transform.\n   */\n\n\n  static fromUpdateMap(ref, data) {\n    const transforms = new Map();\n\n    function encode_(val, path, allowTransforms) {\n      if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n        if (allowTransforms) {\n          transforms.set(path, val);\n        } else {\n          throw new Error(\"\".concat(val.methodName, \"() is not supported inside of array values.\"));\n        }\n      } else if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; ++i) {\n          // We need to verify that no array value contains a document transform\n          encode_(val[i], path.append(String(i)), false);\n        }\n      } else if (serializer_1.isPlainObject(val)) {\n        for (const prop in val) {\n          if (val.hasOwnProperty(prop)) {\n            encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n          }\n        }\n      }\n    }\n\n    data.forEach((value, key) => {\n      encode_(value, path_1.FieldPath.fromArgument(key), true);\n    });\n    return new DocumentTransform(ref, transforms);\n  }\n  /**\n   * Whether this DocumentTransform contains any actionable transformations.\n   *\n   * @private\n   */\n\n\n  get isEmpty() {\n    return this.transforms.size === 0;\n  }\n  /**\n   * Returns the array of fields in this DocumentTransform.\n   *\n   * @private\n   */\n\n\n  get fields() {\n    return Array.from(this.transforms.keys());\n  }\n  /**\n   * Validates the user provided field values in this document transform.\n   * @private\n   */\n\n\n  validate() {\n    this.transforms.forEach(transform => transform.validate());\n  }\n  /**\n   * Converts a document transform to the Firestore 'DocumentTransform' Proto.\n   *\n   * @private\n   * @param serializer The Firestore serializer\n   * @returns A Firestore 'DocumentTransform' Proto or 'null' if this transform\n   * is empty.\n   */\n\n\n  toProto(serializer) {\n    if (this.isEmpty) {\n      return null;\n    }\n\n    const fieldTransforms = [];\n\n    for (const _ref3 of this.transforms) {\n      var _ref4 = _slicedToArray(_ref3, 2);\n\n      const path = _ref4[0];\n      const transform = _ref4[1];\n      fieldTransforms.push(transform.toProto(serializer, path));\n    }\n\n    return {\n      transform: {\n        document: this.ref.formattedName,\n        fieldTransforms\n      }\n    };\n  }\n\n}\n\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @class\n */\n\nclass Precondition {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param options.exists - Whether the referenced document should exist in\n   * Firestore,\n   * @param options.lastUpdateTime - The last update time of the referenced\n   * document in Firestore.\n   * @param options\n   */\n  constructor(options) {\n    if (options !== undefined) {\n      this._exists = options.exists;\n      this._lastUpdateTime = options.lastUpdateTime;\n    }\n  }\n  /**\n   * Generates the Protobuf `Preconditon` object for this precondition.\n   *\n   * @private\n   * @returns The `Preconditon` Protobuf object or 'null' if there are no\n   * preconditions.\n   */\n\n\n  toProto() {\n    if (this.isEmpty) {\n      return null;\n    }\n\n    const proto = {};\n\n    if (this._lastUpdateTime !== undefined) {\n      const valueProto = this._lastUpdateTime.toProto();\n\n      proto.updateTime = valueProto.timestampValue;\n    } else {\n      proto.exists = this._exists;\n    }\n\n    return proto;\n  }\n  /**\n   * Whether this DocumentTransform contains any enforcement.\n   *\n   * @private\n   */\n\n\n  get isEmpty() {\n    return this._exists === undefined && !this._lastUpdateTime;\n  }\n\n}\n\nexports.Precondition = Precondition;","map":null,"metadata":{},"sourceType":"script"}