{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst client_1 = require(\"./client\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\n\n\nconst requesterFuncs = {\n  unary: client_1.Client.prototype.makeUnaryRequest,\n  server_stream: client_1.Client.prototype.makeServerStreamRequest,\n  client_stream: client_1.Client.prototype.makeClientStreamRequest,\n  bidi: client_1.Client.prototype.makeBidiStreamRequest\n};\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\n\nfunction makeClientConstructor(methods, serviceName, classOptions) {\n  if (!classOptions) {\n    classOptions = {};\n  }\n\n  class ServiceClientImpl extends client_1.Client {}\n\n  Object.keys(methods).forEach(name => {\n    const attrs = methods[name];\n    let methodType; // TODO(murgatroid99): Verify that we don't need this anymore\n\n    if (typeof name === 'string' && name.charAt(0) === '$') {\n      throw new Error('Method names cannot start with $');\n    }\n\n    if (attrs.requestStream) {\n      if (attrs.responseStream) {\n        methodType = 'bidi';\n      } else {\n        methodType = 'client_stream';\n      }\n    } else {\n      if (attrs.responseStream) {\n        methodType = 'server_stream';\n      } else {\n        methodType = 'unary';\n      }\n    }\n\n    const serialize = attrs.requestSerialize;\n    const deserialize = attrs.responseDeserialize;\n    const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n    ServiceClientImpl.prototype[name] = methodFunc; // Associate all provided attributes with the method\n\n    Object.assign(ServiceClientImpl.prototype[name], attrs);\n\n    if (attrs.originalName) {\n      ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];\n    }\n  });\n  ServiceClientImpl.service = methods;\n  return ServiceClientImpl;\n}\n\nexports.makeClientConstructor = makeClientConstructor;\n\nfunction partial(fn, path, serialize, deserialize) {\n  // tslint:disable-next-line:no-any\n  return function (...args) {\n    return fn.call(this, path, serialize, deserialize, ...args);\n  };\n}\n\nfunction isProtobufTypeDefinition(obj) {\n  return 'format' in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */\n\n\nfunction loadPackageDefinition(packageDef) {\n  const result = {};\n\n  for (const serviceFqn in packageDef) {\n    if (packageDef.hasOwnProperty(serviceFqn)) {\n      const service = packageDef[serviceFqn];\n      const nameComponents = serviceFqn.split('.');\n      const serviceName = nameComponents[nameComponents.length - 1];\n      let current = result;\n\n      for (const packageName of nameComponents.slice(0, -1)) {\n        if (!current[packageName]) {\n          current[packageName] = {};\n        }\n\n        current = current[packageName];\n      }\n\n      if (isProtobufTypeDefinition(service)) {\n        current[serviceName] = service;\n      } else {\n        current[serviceName] = makeClientConstructor(service, serviceName, {});\n      }\n    }\n  }\n\n  return result;\n}\n\nexports.loadPackageDefinition = loadPackageDefinition;","map":null,"metadata":{},"sourceType":"script"}