{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tls_1 = require(\"tls\");\n\nconst call_credentials_1 = require(\"./call-credentials\"); // tslint:disable-next-line:no-any\n\n\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(\"\".concat(friendlyName, \", if provided, must be a Buffer.\"));\n  }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\n\n\nclass ChannelCredentials {\n  constructor(callCredentials) {\n    this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n  }\n  /**\n   * Gets the set of per-call credentials associated with this instance.\n   */\n\n\n  _getCallCredentials() {\n    return this.callCredentials;\n  }\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   */\n\n\n  static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n\n    if (privateKey && !certChain) {\n      throw new Error('Private key must be given with accompanying certificate chain');\n    }\n\n    if (!privateKey && certChain) {\n      throw new Error('Certificate chain must be given with accompanying private key');\n    }\n\n    const secureContext = tls_1.createSecureContext({\n      ca: rootCerts || undefined,\n      key: privateKey || undefined,\n      cert: certChain || undefined\n    });\n    const connectionOptions = {\n      secureContext\n    };\n\n    if (verifyOptions && verifyOptions.checkServerIdentity) {\n      connectionOptions.checkServerIdentity = (host, cert) => {\n        return verifyOptions.checkServerIdentity(host, {\n          raw: cert.raw\n        });\n      };\n    }\n\n    return new SecureChannelCredentialsImpl(connectionOptions);\n  }\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n\n\n  static createInsecure() {\n    return new InsecureChannelCredentialsImpl();\n  }\n\n}\n\nexports.ChannelCredentials = ChannelCredentials;\n\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(callCredentials) {\n    super(callCredentials);\n  }\n\n  compose(callCredentials) {\n    throw new Error('Cannot compose insecure credentials');\n  }\n\n  _getConnectionOptions() {\n    return null;\n  }\n\n  _isSecure() {\n    return false;\n  }\n\n}\n\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(connectionOptions, callCredentials) {\n    super(callCredentials);\n    this.connectionOptions = connectionOptions;\n  }\n\n  compose(callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n    return new SecureChannelCredentialsImpl(this.connectionOptions, combinedCallCredentials);\n  }\n\n  _getConnectionOptions() {\n    return this.connectionOptions;\n  }\n\n  _isSecure() {\n    return true;\n  }\n\n}","map":null,"metadata":{},"sourceType":"script"}