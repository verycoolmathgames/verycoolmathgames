{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst http2 = require(\"http2\");\n\nconst tls_1 = require(\"tls\");\n\nconst url = require(\"url\");\n\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst channel_options_1 = require(\"./channel-options\");\n\nconst compression_filter_1 = require(\"./compression-filter\");\n\nconst constants_1 = require(\"./constants\");\n\nconst deadline_filter_1 = require(\"./deadline-filter\");\n\nconst filter_stack_1 = require(\"./filter-stack\");\n\nconst metadata_status_filter_1 = require(\"./metadata-status-filter\");\n\nconst subchannel_1 = require(\"./subchannel\");\n\nconst _require = require('../../package.json'),\n      clientVersion = _require.version;\n\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\nconst _http2$constants = http2.constants,\n      HTTP2_HEADER_AUTHORITY = _http2$constants.HTTP2_HEADER_AUTHORITY,\n      HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,\n      HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD,\n      HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH,\n      HTTP2_HEADER_TE = _http2$constants.HTTP2_HEADER_TE,\n      HTTP2_HEADER_USER_AGENT = _http2$constants.HTTP2_HEADER_USER_AGENT;\nvar ConnectivityState;\n\n(function (ConnectivityState) {\n  ConnectivityState[ConnectivityState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n  ConnectivityState[ConnectivityState[\"READY\"] = 1] = \"READY\";\n  ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n  ConnectivityState[ConnectivityState[\"IDLE\"] = 3] = \"IDLE\";\n  ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nclass Http2Channel extends events_1.EventEmitter {\n  constructor(address, credentials, options) {\n    super();\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = ConnectivityState.IDLE; // Helper Promise object only used in the implementation of connect().\n\n    this.connecting = null;\n    /* For now, we have up to one subchannel, which will exist as long as we are\n     * connecting or trying to connect */\n\n    this.subChannel = null;\n\n    this.subChannelConnectCallback = () => {};\n\n    this.subChannelCloseCallback = () => {};\n\n    this.currentBackoff = INITIAL_BACKOFF_MS;\n\n    for (const option in options) {\n      if (options.hasOwnProperty(option)) {\n        if (!channel_options_1.recognizedOptions.hasOwnProperty(option)) {\n          console.warn(\"Unrecognized channel argument '\".concat(option, \"' will be ignored.\"));\n        }\n      }\n    }\n\n    if (credentials._isSecure()) {\n      this.target = new url.URL(\"https://\".concat(address));\n    } else {\n      this.target = new url.URL(\"http://\".concat(address));\n    } // TODO(murgatroid99): Add more centralized handling of channel options\n\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = this.target.host;\n    }\n\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new metadata_status_filter_1.MetadataStatusFilterFactory(this), new compression_filter_1.CompressionFilterFactory(this)]);\n    this.currentBackoffDeadline = new Date();\n    /* The only purpose of these lines is to ensure that this.backoffTimerId has\n     * a value of type NodeJS.Timer. */\n\n    this.backoffTimerId = setTimeout(() => {}, 0); // Build user-agent string.\n\n    this.userAgent = [options['grpc.primary_user_agent'], \"grpc-node-js/\".concat(clientVersion), options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n  }\n\n  handleStateChange(oldState, newState) {\n    const now = new Date();\n\n    switch (newState) {\n      case ConnectivityState.CONNECTING:\n        if (oldState === ConnectivityState.IDLE) {\n          this.currentBackoff = INITIAL_BACKOFF_MS;\n          this.currentBackoffDeadline = new Date(now.getTime() + INITIAL_BACKOFF_MS);\n        } else if (oldState === ConnectivityState.TRANSIENT_FAILURE) {\n          this.currentBackoff = Math.min(this.currentBackoff * BACKOFF_MULTIPLIER, MAX_BACKOFF_MS);\n          const jitterMagnitude = BACKOFF_JITTER * this.currentBackoff;\n          this.currentBackoffDeadline = new Date(now.getTime() + this.currentBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude));\n        }\n\n        this.startConnecting();\n        break;\n\n      case ConnectivityState.READY:\n        this.emit('connect');\n        break;\n\n      case ConnectivityState.TRANSIENT_FAILURE:\n        this.subChannel = null;\n        this.backoffTimerId = setTimeout(() => {\n          this.transitionToState([ConnectivityState.TRANSIENT_FAILURE], ConnectivityState.CONNECTING);\n        }, this.currentBackoffDeadline.getTime() - now.getTime());\n        break;\n\n      case ConnectivityState.IDLE:\n      case ConnectivityState.SHUTDOWN:\n        if (this.subChannel) {\n          this.subChannel.close();\n          this.subChannel.removeListener('connect', this.subChannelConnectCallback);\n          this.subChannel.removeListener('close', this.subChannelCloseCallback);\n          this.subChannel = null;\n          this.emit('shutdown');\n          clearTimeout(this.backoffTimerId);\n        }\n\n        break;\n\n      default:\n        throw new Error('This should never happen');\n    }\n  } // Transition from any of a set of oldStates to a specific newState\n\n\n  transitionToState(oldStates, newState) {\n    if (oldStates.indexOf(this.connectivityState) > -1) {\n      const oldState = this.connectivityState;\n      this.connectivityState = newState;\n      this.handleStateChange(oldState, newState);\n      this.emit('connectivityStateChanged', newState);\n    }\n  }\n\n  startConnecting() {\n    const connectionOptions = this.credentials._getConnectionOptions() || {};\n\n    if (connectionOptions.secureContext !== null) {\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n\n        connectionOptions.servername = sslTargetNameOverride;\n      }\n    }\n\n    const subChannel = new subchannel_1.Http2SubChannel(this.target, connectionOptions, this.userAgent, this.options);\n    this.subChannel = subChannel;\n    const now = new Date();\n    const connectionTimeout = Math.max(this.currentBackoffDeadline.getTime() - now.getTime(), MIN_CONNECT_TIMEOUT_MS);\n    const connectionTimerId = setTimeout(() => {\n      // This should trigger the 'close' event, which will send us back to\n      // TRANSIENT_FAILURE\n      subChannel.close();\n    }, connectionTimeout);\n\n    this.subChannelConnectCallback = () => {\n      // Connection succeeded\n      clearTimeout(connectionTimerId);\n      this.transitionToState([ConnectivityState.CONNECTING], ConnectivityState.READY);\n    };\n\n    subChannel.once('connect', this.subChannelConnectCallback);\n\n    this.subChannelCloseCallback = () => {\n      // Connection failed\n      clearTimeout(connectionTimerId);\n      /* TODO(murgatroid99): verify that this works for\n       * CONNECTING->TRANSITIVE_FAILURE see nodejs/node#16645 */\n\n      this.transitionToState([ConnectivityState.CONNECTING, ConnectivityState.READY], ConnectivityState.TRANSIENT_FAILURE);\n    };\n\n    subChannel.once('close', this.subChannelCloseCallback);\n  }\n\n  _startHttp2Stream(authority, methodName, stream, metadata) {\n    const connectMetadata = this.connect().then(() => metadata.clone());\n    const finalMetadata = stream.filterStack.sendMetadata(connectMetadata);\n    finalMetadata.then(metadataValue => {\n      const headers = metadataValue.toHttp2Headers();\n      headers[HTTP2_HEADER_AUTHORITY] = authority;\n      headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n      headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n      headers[HTTP2_HEADER_METHOD] = 'POST';\n      headers[HTTP2_HEADER_PATH] = methodName;\n      headers[HTTP2_HEADER_TE] = 'trailers';\n\n      if (this.connectivityState === ConnectivityState.READY) {\n        const subChannel = this.subChannel;\n        subChannel.startCallStream(metadataValue, stream);\n      } else {\n        /* In this case, we lost the connection while finalizing\n         * metadata. That should be very unusual */\n        setImmediate(() => {\n          this._startHttp2Stream(authority, methodName, stream, metadata);\n        });\n      }\n    }).catch(error => {\n      // We assume the error code isn't 0 (Status.OK)\n      stream.cancelWithStatus(error.code || constants_1.Status.UNKNOWN, \"Getting metadata from plugin failed with error: \".concat(error.message));\n    });\n  }\n\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    const finalOptions = {\n      deadline: deadline === null || deadline === undefined ? Infinity : deadline,\n      flags: propagateFlags || 0,\n      host: host || this.defaultAuthority,\n      parentCall: parentCall || null\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory);\n    return stream;\n  }\n  /**\n   * Attempts to connect, returning a Promise that resolves when the connection\n   * is successful, or rejects if the channel is shut down.\n   */\n\n\n  connect() {\n    if (this.connectivityState === ConnectivityState.READY) {\n      return Promise.resolve();\n    } else if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      return Promise.reject(new Error('Channel has been shut down'));\n    } else {\n      // In effect, this.connecting is only assigned upon the first attempt to\n      // transition from IDLE to CONNECTING, so this condition could have also\n      // been (connectivityState === IDLE).\n      if (!this.connecting) {\n        this.connecting = new Promise((resolve, reject) => {\n          this.transitionToState([ConnectivityState.IDLE], ConnectivityState.CONNECTING);\n\n          const onConnect = () => {\n            this.connecting = null;\n            this.removeListener('shutdown', onShutdown);\n            resolve();\n          };\n\n          const onShutdown = () => {\n            this.connecting = null;\n            this.removeListener('connect', onConnect);\n            reject(new Error('Channel has been shut down'));\n          };\n\n          this.once('connect', onConnect);\n          this.once('shutdown', onShutdown);\n        });\n      }\n\n      return this.connecting;\n    }\n  }\n\n  getConnectivityState(tryToConnect) {\n    if (tryToConnect) {\n      this.transitionToState([ConnectivityState.IDLE], ConnectivityState.CONNECTING);\n    }\n\n    return this.connectivityState;\n  }\n\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState !== currentState) {\n      /* If the connectivity state is different from the provided currentState,\n       * we assume that a state change has successfully occurred */\n      setImmediate(callback);\n    } else {\n      let deadlineMs = 0;\n\n      if (deadline instanceof Date) {\n        deadlineMs = deadline.getTime();\n      } else {\n        deadlineMs = deadline;\n      }\n\n      let timeout = deadlineMs - Date.now();\n\n      if (timeout < 0) {\n        timeout = 0;\n      }\n\n      const timeoutId = setTimeout(() => {\n        this.removeListener('connectivityStateChanged', eventCb);\n        callback(new Error('Channel state did not change before deadline'));\n      }, timeout);\n\n      const eventCb = () => {\n        clearTimeout(timeoutId);\n        callback();\n      };\n\n      this.once('connectivityStateChanged', eventCb);\n    }\n  }\n\n  getTarget() {\n    return this.target.toString();\n  }\n\n  close() {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    this.transitionToState([ConnectivityState.CONNECTING, ConnectivityState.READY, ConnectivityState.TRANSIENT_FAILURE, ConnectivityState.IDLE], ConnectivityState.SHUTDOWN);\n  }\n\n}\n\nexports.Http2Channel = Http2Channel;","map":null,"metadata":{},"sourceType":"script"}