{"ast":null,"code":"/**\n * @preserve date-and-time.js (c) KNOWLEDGECODE | MIT\n */\n(function (global) {\n  'use strict';\n\n  var date = {},\n      lang = 'en',\n      locales = {\n    en: {\n      MMMM: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n      dddd: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      ddd: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n      dd: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],\n      A: ['a.m.', 'p.m.'],\n      formatter: {\n        YYYY: function (d\n        /*, formatString*/\n        ) {\n          return ('000' + d.getFullYear()).slice(-4);\n        },\n        YY: function (d\n        /*, formatString*/\n        ) {\n          return ('0' + d.getFullYear()).slice(-2);\n        },\n        Y: function (d\n        /*, formatString*/\n        ) {\n          return '' + d.getFullYear();\n        },\n        MMMM: function (d\n        /*, formatString*/\n        ) {\n          return this.MMMM[d.getMonth()];\n        },\n        MMM: function (d\n        /*, formatString*/\n        ) {\n          return this.MMM[d.getMonth()];\n        },\n        MM: function (d\n        /*, formatString*/\n        ) {\n          return ('0' + (d.getMonth() + 1)).slice(-2);\n        },\n        M: function (d\n        /*, formatString*/\n        ) {\n          return '' + (d.getMonth() + 1);\n        },\n        DD: function (d\n        /*, formatString*/\n        ) {\n          return ('0' + d.getDate()).slice(-2);\n        },\n        D: function (d\n        /*, formatString*/\n        ) {\n          return '' + d.getDate();\n        },\n        HH: function (d\n        /*, formatString*/\n        ) {\n          return ('0' + d.getHours()).slice(-2);\n        },\n        H: function (d\n        /*, formatString*/\n        ) {\n          return '' + d.getHours();\n        },\n        A: function (d\n        /*, formatString*/\n        ) {\n          return this.A[d.getHours() > 11 | 0];\n        },\n        hh: function (d\n        /*, formatString*/\n        ) {\n          return ('0' + (d.getHours() % 12 || 12)).slice(-2);\n        },\n        h: function (d\n        /*, formatString*/\n        ) {\n          return '' + (d.getHours() % 12 || 12);\n        },\n        mm: function (d\n        /*, formatString*/\n        ) {\n          return ('0' + d.getMinutes()).slice(-2);\n        },\n        m: function (d\n        /*, formatString*/\n        ) {\n          return '' + d.getMinutes();\n        },\n        ss: function (d\n        /*, formatString*/\n        ) {\n          return ('0' + d.getSeconds()).slice(-2);\n        },\n        s: function (d\n        /*, formatString*/\n        ) {\n          return '' + d.getSeconds();\n        },\n        SSS: function (d\n        /*, formatString*/\n        ) {\n          return ('00' + d.getMilliseconds()).slice(-3);\n        },\n        SS: function (d\n        /*, formatString*/\n        ) {\n          return ('0' + (d.getMilliseconds() / 10 | 0)).slice(-2);\n        },\n        S: function (d\n        /*, formatString*/\n        ) {\n          return '' + (d.getMilliseconds() / 100 | 0);\n        },\n        dddd: function (d\n        /*, formatString*/\n        ) {\n          return this.dddd[d.getDay()];\n        },\n        ddd: function (d\n        /*, formatString*/\n        ) {\n          return this.ddd[d.getDay()];\n        },\n        dd: function (d\n        /*, formatString*/\n        ) {\n          return this.dd[d.getDay()];\n        },\n        Z: function (d\n        /*, formatString*/\n        ) {\n          var offset = d.utc ? 0 : d.getTimezoneOffset() / 0.6;\n          return (offset > 0 ? '-' : '+') + ('000' + Math.abs(offset - offset % 100 * 0.4)).slice(-4);\n        },\n        post: function (str) {\n          return str;\n        }\n      },\n      parser: {\n        find: function (array, str) {\n          var index = -1,\n              length = 0;\n\n          for (var i = 0, len = array.length, item; i < len; i++) {\n            item = array[i];\n\n            if (!str.indexOf(item) && item.length > length) {\n              index = i;\n              length = item.length;\n            }\n          }\n\n          return {\n            index: index,\n            length: length\n          };\n        },\n        MMMM: function (str\n        /*, formatString*/\n        ) {\n          return this.parser.find(this.MMMM, str);\n        },\n        MMM: function (str\n        /*, formatString*/\n        ) {\n          return this.parser.find(this.MMM, str);\n        },\n        A: function (str\n        /*, formatString*/\n        ) {\n          return this.parser.find(this.A, str);\n        },\n        h: function (h, a) {\n          return (h === 12 ? 0 : h) + a * 12;\n        },\n        pre: function (str) {\n          return str;\n        }\n      }\n    }\n  };\n  /**\n   * formatting a date\n   * @param {Object} dateObj - date object\n   * @param {String} formatString - format string\n   * @param {Boolean} [utc] - output as UTC\n   * @returns {String} the formatted string\n   */\n\n  date.format = function (dateObj, formatString, utc) {\n    var d = date.addMinutes(dateObj, utc ? dateObj.getTimezoneOffset() : 0),\n        locale = locales[lang],\n        formatter = locale.formatter;\n    d.utc = utc;\n    return formatString.replace(/(\\[[^\\[\\]]*]|\\[.*\\][^\\[]*\\]|YYYY|YY|MMM?M?|DD|HH|hh|mm|ss|SSS?|ddd?d?|.)/g, function (token) {\n      var format = formatter[token];\n      return format ? formatter.post(format.call(locale, d, formatString)) : token.replace(/\\[(.*)]/, '$1');\n    });\n  };\n  /**\n   * parsing a date string\n   * @param {String} dateString - date string\n   * @param {String} formatString - format string\n   * @param {Boolean} [utc] - input as UTC\n   * @returns {Object} the constructed date\n   */\n\n\n  date.parse = function (dateString, formatString, utc) {\n    var locale = locales[lang],\n        dString = locale.parser.pre(dateString),\n        offset = 0,\n        keys,\n        i,\n        token,\n        length,\n        p,\n        str,\n        result,\n        dateObj,\n        re = /(MMMM?|A)|(YYYY)|(SSS)|(MM|DD|HH|hh|mm|ss)|(YY|M|D|H|h|m|s|SS)|(S)|(.)/g,\n        exp = {\n      2: /^\\d{1,4}/,\n      3: /^\\d{1,3}/,\n      4: /^\\d\\d/,\n      5: /^\\d\\d?/,\n      6: /^\\d/\n    },\n        last = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        dt = {\n      Y: 1970,\n      M: 1,\n      D: 1,\n      H: 0,\n      m: 0,\n      s: 0,\n      S: 0\n    };\n\n    while (keys = re.exec(formatString)) {\n      for (i = 0, length = 1, token = ''; !token;) {\n        token = keys[++i];\n      }\n\n      p = token.charAt(0);\n      str = dString.slice(offset);\n\n      if (i < 2) {\n        result = locale.parser[token].call(locale, str, formatString);\n        dt[p] = result.index;\n\n        if (p === 'M') {\n          dt[p]++;\n        }\n\n        length = result.length;\n      } else if (i < 7) {\n        result = (str.match(exp[i]) || [''])[0];\n        dt[p] = (p === 'S' ? (result + '000').slice(0, -token.length) : result) | 0;\n        length = result.length;\n      } else if (p !== ' ' && p !== str[0]) {\n        return NaN;\n      }\n\n      if (!length) {\n        return NaN;\n      }\n\n      offset += length;\n    }\n\n    if (offset !== dString.length || !result) {\n      return NaN;\n    }\n\n    dt.Y += dt.Y < 70 ? 2000 : dt.Y < 100 ? 1900 : 0;\n    dt.H = dt.H || locale.parser.h(dt.h || 0, dt.A || 0);\n    dateObj = new Date(dt.Y, dt.M - 1, dt.D, dt.H, dt.m, dt.s, dt.S);\n    last[1] += date.isLeapYear(dateObj) | 0;\n\n    if (dt.M < 1 || dt.M > 12 || dt.D < 1 || dt.D > last[dt.M - 1] || dt.H > 23 || dt.m > 59 || dt.s > 59) {\n      return NaN;\n    }\n\n    return utc ? date.addMinutes(dateObj, -dateObj.getTimezoneOffset()) : dateObj;\n  };\n  /**\n   * validation\n   * @param {String} dateString - date string\n   * @param {String} formatString - format string\n   * @returns {Boolean} whether the date string is a valid date\n   */\n\n\n  date.isValid = function (dateString, formatString) {\n    return !!date.parse(dateString, formatString);\n  };\n  /**\n   * adding years\n   * @param {Object} dateObj - date object\n   * @param {Number} years - adding year\n   * @returns {Object} the date after adding the value\n   */\n\n\n  date.addYears = function (dateObj, years) {\n    return date.addMonths(dateObj, years * 12);\n  };\n  /**\n   * adding months\n   * @param {Object} dateObj - date object\n   * @param {Number} months - adding month\n   * @returns {Object} the date after adding the value\n   */\n\n\n  date.addMonths = function (dateObj, months) {\n    var d = new Date(dateObj.getTime());\n    d.setMonth(d.getMonth() + months);\n    return d;\n  };\n  /**\n   * adding days\n   * @param {Object} dateObj - date object\n   * @param {Number} days - adding day\n   * @returns {Object} the date after adding the value\n   */\n\n\n  date.addDays = function (dateObj, days) {\n    var d = new Date(dateObj.getTime());\n    d.setDate(d.getDate() + days);\n    return d;\n  };\n  /**\n   * adding hours\n   * @param {Object} dateObj - date object\n   * @param {Number} hours - adding hour\n   * @returns {Object} the date after adding the value\n   */\n\n\n  date.addHours = function (dateObj, hours) {\n    return date.addMilliseconds(dateObj, hours * 3600000);\n  };\n  /**\n   * adding minutes\n   * @param {Object} dateObj - date object\n   * @param {Number} minutes - adding minute\n   * @returns {Object} the date after adding the value\n   */\n\n\n  date.addMinutes = function (dateObj, minutes) {\n    return date.addMilliseconds(dateObj, minutes * 60000);\n  };\n  /**\n   * adding seconds\n   * @param {Object} dateObj - date object\n   * @param {Number} seconds - adding second\n   * @returns {Object} the date after adding the value\n   */\n\n\n  date.addSeconds = function (dateObj, seconds) {\n    return date.addMilliseconds(dateObj, seconds * 1000);\n  };\n  /**\n   * adding milliseconds\n   * @param {Object} dateObj - date object\n   * @param {Number} milliseconds - adding millisecond\n   * @returns {Object} the date after adding the value\n   */\n\n\n  date.addMilliseconds = function (dateObj, milliseconds) {\n    return new Date(dateObj.getTime() + milliseconds);\n  };\n  /**\n   * subtracting\n   * @param {Object} date1 - date object\n   * @param {Object} date2 - date object\n   * @returns {Object} the result object after subtracting the date\n   */\n\n\n  date.subtract = function (date1, date2) {\n    var delta = date1.getTime() - date2.getTime();\n    return {\n      toMilliseconds: function () {\n        return delta;\n      },\n      toSeconds: function () {\n        return delta / 1000 | 0;\n      },\n      toMinutes: function () {\n        return delta / 60000 | 0;\n      },\n      toHours: function () {\n        return delta / 3600000 | 0;\n      },\n      toDays: function () {\n        return delta / 86400000 | 0;\n      }\n    };\n  };\n  /**\n   * leap year\n   * @param {Object} dateObj - date object\n   * @returns {Boolean} whether the year is a leap year\n   */\n\n\n  date.isLeapYear = function (dateObj) {\n    var y = dateObj.getFullYear();\n    return !(y % 4) && !!(y % 100) || !(y % 400);\n  };\n  /**\n   * comparison of dates\n   * @param {Object} date1 - target for comparison\n   * @param {Object} date2 - target for comparison\n   * @returns {Boolean} whether the dates are the same day (times are ignored)\n   */\n\n\n  date.isSameDay = function (date1, date2) {\n    return date.format(date1, 'YYYYMMDD') === date.format(date2, 'YYYYMMDD');\n  };\n  /**\n   * setting a locale\n   * @param {String} [code] - language code\n   * @returns {String} current language code\n   */\n\n\n  date.locale = function (code) {\n    if (code) {\n      if (!locales[code] && typeof require === 'function' && global) {\n        require('./locale/' + code);\n      }\n\n      lang = code;\n    }\n\n    return lang;\n  };\n  /**\n   * getting a definition of locale\n   * @param {String} [code] - language code\n   * @returns {Object} definition of locale\n   */\n\n\n  date.getLocales = function (code) {\n    return locales[code || lang];\n  };\n  /**\n   * adding a new definition of locale\n   * @param {String} code - language code\n   * @param {Object} options - definition of locale\n   * @returns {void}\n   */\n\n\n  date.setLocales = function (code, options) {\n    var copy = function (src, proto) {\n      var Locale = function () {},\n          dst,\n          key;\n\n      Locale.prototype = proto;\n      dst = new Locale();\n\n      for (key in src) {\n        if (src.hasOwnProperty(key)) {\n          dst[key] = src[key];\n        }\n      }\n\n      return dst;\n    },\n        base = locales[code] || locales.en,\n        locale = copy(options, base);\n\n    if (options.formatter) {\n      locale.formatter = copy(options.formatter, base.formatter);\n    }\n\n    if (options.parser) {\n      locale.parser = copy(options.parser, base.parser);\n    }\n\n    locales[code] = locale;\n  };\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = date;\n  } else if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return date;\n    });\n  } else {\n    global.date = date;\n  }\n})(this);","map":null,"metadata":{},"sourceType":"script"}