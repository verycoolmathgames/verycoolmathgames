{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst rbtree = require(\"functional-red-black-tree\");\n\nconst backoff_1 = require(\"./backoff\");\n\nconst document_1 = require(\"./document\");\n\nconst document_change_1 = require(\"./document-change\");\n\nconst logger_1 = require(\"./logger\");\n\nconst path_1 = require(\"./path\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst types_1 = require(\"./types\");\n\nconst util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\n\n\nconst WATCH_TARGET_ID = 0x1;\n/*!\n * Sentinel value for a document remove.\n */\n\nconst REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\n\nconst ChangeType = {\n  added: 'added',\n  modified: 'modified',\n  removed: 'removed'\n};\n/*!\n * List of GRPC Error Codes.\n *\n * This corresponds to\n * {@link https://github.com/grpc/grpc/blob/master/doc/statuscodes.md}.\n */\n\nconst GRPC_STATUS_CODE = {\n  // Not an error; returned on success.\n  OK: 0,\n  // The operation was cancelled (typically by the caller).\n  CANCELLED: 1,\n  // Unknown error. An example of where this error may be returned is if a\n  // Status value received from another address space belongs to an error-space\n  // that is not known in this address space. Also errors raised by APIs that\n  // do not return enough error information may be converted to this error.\n  UNKNOWN: 2,\n  // Client specified an invalid argument. Note that this differs from\n  // FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n  // problematic regardless of the state of the system (e.g., a malformed file\n  // name).\n  INVALID_ARGUMENT: 3,\n  // Deadline expired before operation could complete. For operations that\n  // change the state of the system, this error may be returned even if the\n  // operation has completed successfully. For example, a successful response\n  // from a server could have been delayed long enough for the deadline to\n  // expire.\n  DEADLINE_EXCEEDED: 4,\n  // Some requested entity (e.g., file or directory) was not found.\n  NOT_FOUND: 5,\n  // Some entity that we attempted to create (e.g., file or directory) already\n  // exists.\n  ALREADY_EXISTS: 6,\n  // The caller does not have permission to execute the specified operation.\n  // PERMISSION_DENIED must not be used for rejections caused by exhausting\n  // some resource (use RESOURCE_EXHAUSTED instead for those errors).\n  // PERMISSION_DENIED must not be used if the caller can not be identified\n  // (use UNAUTHENTICATED instead for those errors).\n  PERMISSION_DENIED: 7,\n  // The request does not have valid authentication credentials for the\n  // operation.\n  UNAUTHENTICATED: 16,\n  // Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n  // entire file system is out of space.\n  RESOURCE_EXHAUSTED: 8,\n  // Operation was rejected because the system is not in a state required for\n  // the operation's execution. For example, directory to be deleted may be\n  // non-empty, an rmdir operation is applied to a non-directory, etc.\n  //\n  // A litmus test that may help a service implementor in deciding\n  // between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n  //  (a) Use UNAVAILABLE if the client can retry just the failing call.\n  //  (b) Use ABORTED if the client should retry at a higher-level\n  //      (e.g., restarting a read-modify-write sequence).\n  //  (c) Use FAILED_PRECONDITION if the client should not retry until\n  //      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n  //      fails because the directory is non-empty, FAILED_PRECONDITION\n  //      should be returned since the client should not retry unless\n  //      they have first fixed up the directory by deleting files from it.\n  //  (d) Use FAILED_PRECONDITION if the client performs conditional\n  //      REST Get/Update/Delete on a resource and the resource on the\n  //      server does not match the condition. E.g., conflicting\n  //      read-modify-write on the same resource.\n  FAILED_PRECONDITION: 9,\n  // The operation was aborted, typically due to a concurrency issue like\n  // sequencer check failures, transaction aborts, etc.\n  //\n  // See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n  // and UNAVAILABLE.\n  ABORTED: 10,\n  // Operation was attempted past the valid range. E.g., seeking or reading\n  // past end of file.\n  //\n  // Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n  // if the system state changes. For example, a 32-bit file system will\n  // generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n  // range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n  // an offset past the current file size.\n  //\n  // There is a fair bit of overlap between FAILED_PRECONDITION and\n  // OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n  // when it applies so that callers who are iterating through a space can\n  // easily look for an OUT_OF_RANGE error to detect when they are done.\n  OUT_OF_RANGE: 11,\n  // Operation is not implemented or not supported/enabled in this service.\n  UNIMPLEMENTED: 12,\n  // Internal errors. Means some invariants expected by underlying System has\n  // been broken. If you see one of these errors, Something is very broken.\n  INTERNAL: 13,\n  // The service is currently unavailable. This is a most likely a transient\n  // condition and may be corrected by retrying with a backoff.\n  //\n  // See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n  // and UNAVAILABLE.\n  UNAVAILABLE: 14,\n  // Unrecoverable data loss or corruption.\n  DATA_LOSS: 15,\n  // Force users to include a default branch:\n  DO_NOT_USE: -1\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\n\nconst DOCUMENT_WATCH_COMPARATOR = (doc1, doc2) => {\n  assert(doc1 === doc2, 'Document watches only support one document.');\n  return 0;\n};\n\nconst EMPTY_FUNCTION = () => {};\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n */\n\n\nclass Watch {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   */\n  constructor(firestore) {\n    /**\n     * Indicates whether we are interested in data from the stream. Set to false in the\n     * 'unsubscribe()' callback.\n     * @private\n     */\n    this.isActive = true;\n    /**\n     * The current stream to the backend.\n     * @private\n     */\n\n    this.currentStream = null;\n    /**\n     * The server assigns and updates the resume token.\n     * @private\n     */\n\n    this.resumeToken = undefined;\n    /**\n     * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n     * @private\n     */\n\n    this.docMap = new Map();\n    /**\n     * The accumulated map of document changes (keyed by document name) for the\n     * current snapshot.\n     * @private\n     */\n\n    this.changeMap = new Map();\n    /**\n     * The current state of the query results. *\n     * @private\n     */\n\n    this.current = false;\n    /**\n     * We need this to track whether we've pushed an initial set of changes,\n     * since we should push those even when there are no changes, if there\n     * aren't docs.\n     * @private\n     */\n\n    this.hasPushed = false;\n    this.firestore = firestore;\n    this.backoff = new backoff_1.ExponentialBackoff();\n    this.requestTag = util_1.requestTag();\n    this.onNext = EMPTY_FUNCTION;\n    this.onError = EMPTY_FUNCTION;\n  }\n  /**\n   * Starts a watch and attaches a listener for document change events.\n   *\n   * @private\n   * @param onNext A callback to be called every time a new snapshot is\n   * available.\n   * @param onError A callback to be called if the listen fails or is cancelled.\n   * No further callbacks will occur.\n   *\n   * @returns An unsubscribe function that can be called to cancel the snapshot\n   * listener.\n   */\n\n\n  onSnapshot(onNext, onError) {\n    assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n    assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n    assert(this.docTree === undefined, 'docTree should not already be defined.');\n    this.onNext = onNext;\n    this.onError = onError;\n    this.docTree = rbtree(this.getComparator());\n    this.initStream();\n    return () => {\n      logger_1.logger('Watch.onSnapshot', this.requestTag, 'Ending stream'); // Prevent further callbacks.\n\n      this.isActive = false;\n\n      this.onNext = () => {};\n\n      this.onError = () => {};\n\n      if (this.currentStream) {\n        this.currentStream.end();\n      }\n    };\n  }\n  /**\n   * Returns the current count of all documents, including the changes from\n   * the current changeMap.\n   * @private\n   */\n\n\n  currentSize() {\n    const changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n    return this.docMap.size + changes.adds.length - changes.deletes.length;\n  }\n  /**\n   * Splits up document changes into removals, additions, and updates.\n   * @private\n   */\n\n\n  extractCurrentChanges(readTime) {\n    const deletes = [];\n    const adds = [];\n    const updates = [];\n    this.changeMap.forEach((value, name) => {\n      if (value === REMOVED) {\n        if (this.docMap.has(name)) {\n          deletes.push(name);\n        }\n      } else if (this.docMap.has(name)) {\n        value.readTime = readTime;\n        updates.push(value.build());\n      } else {\n        value.readTime = readTime;\n        adds.push(value.build());\n      }\n    });\n    return {\n      deletes,\n      adds,\n      updates\n    };\n  }\n  /**\n   * Helper to clear the docs on RESET or filter mismatch.\n   * @private\n   */\n\n\n  resetDocs() {\n    logger_1.logger('Watch.resetDocs', this.requestTag, 'Resetting documents');\n    this.changeMap.clear();\n    this.resumeToken = undefined;\n    this.docTree.forEach(snapshot => {\n      // Mark each document as deleted. If documents are not deleted, they\n      // will be send again by the server.\n      this.changeMap.set(snapshot.ref.path, REMOVED);\n    });\n    this.current = false;\n  }\n  /**\n   * Closes the stream and calls onError() if the stream is still active.\n   * @private\n   */\n\n\n  closeStream(err) {\n    if (this.currentStream) {\n      this.currentStream.end();\n      this.currentStream = null;\n    }\n\n    if (this.isActive) {\n      this.isActive = false;\n      logger_1.logger('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n      this.onError(err);\n    }\n  }\n  /**\n   * Re-opens the stream unless the specified error is considered permanent.\n   * Clears the change map.\n   * @private\n   */\n\n\n  maybeReopenStream(err) {\n    if (this.currentStream) {\n      this.currentStream = null;\n    }\n\n    if (this.isActive && !this.isPermanentError(err)) {\n      logger_1.logger('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error: ', err);\n      this.changeMap.clear();\n\n      if (this.isResourceExhaustedError(err)) {\n        this.backoff.resetToMax();\n      }\n\n      this.initStream();\n    } else {\n      this.closeStream(err);\n    }\n  }\n  /**\n   * Helper to restart the outgoing stream to the backend.\n   * @private\n   */\n\n\n  resetStream() {\n    logger_1.logger('Watch.resetStream', this.requestTag, 'Restarting stream');\n\n    if (this.currentStream) {\n      this.currentStream.end();\n      this.currentStream = null;\n    }\n\n    this.initStream();\n  }\n  /**\n   * Initializes a new stream to the backend with backoff.\n   * @private\n   */\n\n\n  initStream() {\n    this.backoff.backoffAndWait().then(async () => {\n      if (!this.isActive) {\n        logger_1.logger('Watch.initStream', this.requestTag, 'Not initializing inactive stream');\n        return;\n      }\n\n      await this.firestore.initializeIfNeeded();\n      const request = {};\n      request.database = this.firestore.formattedName;\n      request.addTarget = this.getTarget(this.resumeToken); // Note that we need to call the internal _listen API to pass additional\n      // header values in readWriteStream.\n\n      return this.firestore.readWriteStream('listen', request, this.requestTag, true).then(backendStream => {\n        if (!this.isActive) {\n          logger_1.logger('Watch.initStream', this.requestTag, 'Closing inactive stream');\n          backendStream.end();\n          return;\n        }\n\n        logger_1.logger('Watch.initStream', this.requestTag, 'Opened new stream');\n        this.currentStream = backendStream;\n        this.currentStream.on('data', proto => {\n          this.onData(proto);\n        }).on('error', err => {\n          this.maybeReopenStream(err);\n        }).on('end', () => {\n          const err = new types_1.GrpcError('Stream ended unexpectedly');\n          err.code = GRPC_STATUS_CODE.UNKNOWN;\n          this.maybeReopenStream(err);\n        });\n        this.currentStream.resume();\n      });\n    }).catch(err => {\n      this.closeStream(err);\n    });\n  }\n  /**\n   * Handles 'data' events and closes the stream if the response type is\n   * invalid.\n   * @private\n   */\n\n\n  onData(proto) {\n    if (proto.targetChange) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing target change');\n      const change = proto.targetChange;\n      const noTargetIds = !change.targetIds || change.targetIds.length === 0;\n\n      if (change.targetChangeType === 'NO_CHANGE') {\n        if (noTargetIds && change.readTime && this.current) {\n          // This means everything is up-to-date, so emit the current\n          // set of docs as a snapshot, if there were changes.\n          this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n        }\n      } else if (change.targetChangeType === 'ADD') {\n        if (WATCH_TARGET_ID !== change.targetIds[0]) {\n          this.closeStream(Error('Unexpected target ID sent by server'));\n        }\n      } else if (change.targetChangeType === 'REMOVE') {\n        let code = 13;\n        let message = 'internal error';\n\n        if (change.cause) {\n          code = change.cause.code;\n          message = change.cause.message;\n        } // @todo: Surface a .code property on the exception.\n\n\n        this.closeStream(new Error('Error ' + code + ': ' + message));\n      } else if (change.targetChangeType === 'RESET') {\n        // Whatever changes have happened so far no longer matter.\n        this.resetDocs();\n      } else if (change.targetChangeType === 'CURRENT') {\n        this.current = true;\n      } else {\n        this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n      }\n\n      if (change.resumeToken && this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n        this.backoff.reset();\n      }\n    } else if (proto.documentChange) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing change event'); // No other targetIds can show up here, but we still need to see\n      // if the targetId was in the added list or removed list.\n\n      const targetIds = proto.documentChange.targetIds || [];\n      const removedTargetIds = proto.documentChange.removedTargetIds || [];\n      let changed = false;\n      let removed = false;\n\n      for (let i = 0; i < targetIds.length; i++) {\n        if (targetIds[i] === WATCH_TARGET_ID) {\n          changed = true;\n        }\n      }\n\n      for (let i = 0; i < removedTargetIds.length; i++) {\n        if (removedTargetIds[i] === WATCH_TARGET_ID) {\n          removed = true;\n        }\n      }\n\n      const document = proto.documentChange.document;\n      const name = document.name;\n      const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n\n      if (changed) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Received document change');\n        const snapshot = new document_1.DocumentSnapshotBuilder();\n        snapshot.ref = this.firestore.doc(relativeName);\n        snapshot.fieldsProto = document.fields || {};\n        snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n        snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n        this.changeMap.set(relativeName, snapshot);\n      } else if (removed) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Received document remove');\n        this.changeMap.set(relativeName, REMOVED);\n      }\n    } else if (proto.documentDelete || proto.documentRemove) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing remove event');\n      const name = (proto.documentDelete || proto.documentRemove).document;\n      const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n      this.changeMap.set(relativeName, REMOVED);\n    } else if (proto.filter) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing filter update');\n\n      if (proto.filter.count !== this.currentSize()) {\n        // We need to remove all the current results.\n        this.resetDocs(); // The filter didn't match, so re-issue the query.\n\n        this.resetStream();\n      }\n    } else {\n      this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n    }\n  }\n  /**\n   * Checks if the current target id is included in the list of target ids.\n   * If no targetIds are provided, returns true.\n   * @private\n   */\n\n\n  affectsTarget(targetIds, currentId) {\n    if (targetIds === undefined || targetIds.length === 0) {\n      return true;\n    }\n\n    for (const targetId of targetIds) {\n      if (targetId === currentId) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Assembles a new snapshot from the current set of changes and invokes the\n   * user's callback. Clears the current changes on completion.\n   * @private\n   */\n\n\n  pushSnapshot(readTime, nextResumeToken) {\n    const appliedChanges = this.computeSnapshot(readTime);\n\n    if (!this.hasPushed || appliedChanges.length > 0) {\n      logger_1.logger('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length); // We pass the current set of changes, even if `docTree` is modified later.\n\n      const currentTree = this.docTree;\n      this.onNext(readTime, currentTree.length, () => currentTree.keys, () => appliedChanges);\n      this.hasPushed = true;\n    }\n\n    this.changeMap.clear();\n    this.resumeToken = nextResumeToken;\n  }\n  /**\n   * Applies a document delete to the document tree and the document map.\n   * Returns the corresponding DocumentChange event.\n   * @private\n   */\n\n\n  deleteDoc(name) {\n    assert(this.docMap.has(name), 'Document to delete does not exist');\n    const oldDocument = this.docMap.get(name);\n    const existing = this.docTree.find(oldDocument);\n    const oldIndex = existing.index;\n    this.docTree = existing.remove();\n    this.docMap.delete(name);\n    return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n  }\n  /**\n   * Applies a document add to the document tree and the document map. Returns\n   * the corresponding DocumentChange event.\n   * @private\n   */\n\n\n  addDoc(newDocument) {\n    const name = newDocument.ref.path;\n    assert(!this.docMap.has(name), 'Document to add already exists');\n    this.docTree = this.docTree.insert(newDocument, null);\n    const newIndex = this.docTree.find(newDocument).index;\n    this.docMap.set(name, newDocument);\n    return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n  }\n  /**\n   * Applies a document modification to the document tree and the document map.\n   * Returns the DocumentChange event for successful modifications.\n   * @private\n   */\n\n\n  modifyDoc(newDocument) {\n    const name = newDocument.ref.path;\n    assert(this.docMap.has(name), 'Document to modify does not exist');\n    const oldDocument = this.docMap.get(name);\n\n    if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n      const removeChange = this.deleteDoc(name);\n      const addChange = this.addDoc(newDocument);\n      return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n    }\n\n    return null;\n  }\n  /**\n   * Applies the mutations in changeMap to both the document tree and the\n   * document lookup map. Modified docMap in-place and returns the updated\n   * state.\n   * @private\n   */\n\n\n  computeSnapshot(readTime) {\n    const changeSet = this.extractCurrentChanges(readTime);\n    const appliedChanges = []; // Process the sorted changes in the order that is expected by our clients\n    // (removals, additions, and then modifications). We also need to sort the\n    // individual changes to assure that oldIndex/newIndex keep incrementing.\n\n    changeSet.deletes.sort((name1, name2) => {\n      // Deletes are sorted based on the order of the existing document.\n      return this.getComparator()(this.docMap.get(name1), this.docMap.get(name2));\n    });\n    changeSet.deletes.forEach(name => {\n      const change = this.deleteDoc(name);\n      appliedChanges.push(change);\n    });\n    changeSet.adds.sort(this.getComparator());\n    changeSet.adds.forEach(snapshot => {\n      const change = this.addDoc(snapshot);\n      appliedChanges.push(change);\n    });\n    changeSet.updates.sort(this.getComparator());\n    changeSet.updates.forEach(snapshot => {\n      const change = this.modifyDoc(snapshot);\n\n      if (change) {\n        appliedChanges.push(change);\n      }\n    });\n    assert(this.docTree.length === this.docMap.size, 'The update document ' + 'tree and document map should have the same number of entries.');\n    return appliedChanges;\n  }\n  /**\n   * Determines whether an error is considered permanent and should not be\n   * retried. Errors that don't provide a GRPC error code are always considered\n   * transient in this context.\n   *\n   * @private\n   * @param error An error object.\n   * @return Whether the error is permanent.\n   */\n\n\n  isPermanentError(error) {\n    if (error.code === undefined) {\n      logger_1.logger('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n      return false;\n    }\n\n    switch (error.code) {\n      case GRPC_STATUS_CODE.ABORTED:\n      case GRPC_STATUS_CODE.CANCELLED:\n      case GRPC_STATUS_CODE.UNKNOWN:\n      case GRPC_STATUS_CODE.DEADLINE_EXCEEDED:\n      case GRPC_STATUS_CODE.RESOURCE_EXHAUSTED:\n      case GRPC_STATUS_CODE.INTERNAL:\n      case GRPC_STATUS_CODE.UNAVAILABLE:\n      case GRPC_STATUS_CODE.UNAUTHENTICATED:\n        return false;\n\n      default:\n        return true;\n    }\n  }\n  /**\n   * Determines whether we need to initiate a longer backoff due to system\n   * overload.\n   *\n   * @private\n   * @param error A GRPC Error object that exposes an error code.\n   * @return Whether we need to back off our retries.\n   */\n\n\n  isResourceExhaustedError(error) {\n    return error.code === GRPC_STATUS_CODE.RESOURCE_EXHAUSTED;\n  }\n\n}\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n */\n\n\nclass DocumentWatch extends Watch {\n  constructor(firestore, ref) {\n    super(firestore);\n    this.ref = ref;\n  }\n\n  getComparator() {\n    return DOCUMENT_WATCH_COMPARATOR;\n  }\n\n  getTarget(resumeToken) {\n    const formattedName = this.ref.formattedName;\n    return {\n      documents: {\n        documents: [formattedName]\n      },\n      targetId: WATCH_TARGET_ID,\n      resumeToken\n    };\n  }\n\n}\n\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n */\n\nclass QueryWatch extends Watch {\n  constructor(firestore, query) {\n    super(firestore);\n    this.query = query;\n    this.comparator = query.comparator();\n  }\n\n  getComparator() {\n    return this.query.comparator();\n  }\n\n  getTarget(resumeToken) {\n    const query = this.query.toProto();\n    return {\n      query,\n      targetId: WATCH_TARGET_ID,\n      resumeToken\n    };\n  }\n\n}\n\nexports.QueryWatch = QueryWatch;","map":null,"metadata":{},"sourceType":"script"}