{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst child_process_1 = require(\"child_process\");\n\nconst fs = require(\"fs\");\n\nconst gcpMetadata = require(\"gcp-metadata\");\n\nconst os = require(\"os\");\n\nconst path = require(\"path\");\n\nconst crypto_1 = require(\"../crypto/crypto\");\n\nconst isbrowser_1 = require(\"../isbrowser\");\n\nconst messages = require(\"../messages\");\n\nconst transporters_1 = require(\"../transporters\");\n\nconst computeclient_1 = require(\"./computeclient\");\n\nconst envDetect_1 = require(\"./envDetect\");\n\nconst jwtclient_1 = require(\"./jwtclient\");\n\nconst refreshclient_1 = require(\"./refreshclient\");\n\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\n\nclass GoogleAuth {\n  constructor(opts) {\n    /**\n     * Caches a value indicating whether the auth layer is running on Google\n     * Compute Engine.\n     * @private\n     */\n    this.checkIsGCE = undefined; // To save the contents of the JSON credential file\n\n    this.jsonContent = null;\n    this.cachedCredential = null;\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n    this.clientOptions = opts.clientOptions;\n  } // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n\n\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n\n  getDefaultProjectId(callback) {\n    messages.warn(messages.DEFAULT_PROJECT_ID_DEPRECATED);\n\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  getProjectId(callback) {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  getProjectIdAsync() {\n    if (this._cachedProjectId) {\n      return Promise.resolve(this._cachedProjectId);\n    } // In implicit case, supports three environments. In order of precedence,\n    // the implicit environments are:\n    // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n    // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n    // - Cloud SDK: `gcloud config config-helper --format json`\n    // - GCE project ID from metadata server)\n\n\n    if (!this._getDefaultProjectIdPromise) {\n      this._getDefaultProjectIdPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const projectId = this.getProductionProjectId() || (yield this.getFileProjectId()) || (yield this.getDefaultServiceProjectId()) || (yield this.getGCEProjectId());\n          this._cachedProjectId = projectId;\n          resolve(projectId);\n        } catch (e) {\n          reject(e);\n        }\n      }));\n    }\n\n    return this._getDefaultProjectIdPromise;\n  }\n\n  getApplicationDefault(optionsOrCallback = {}, callback) {\n    let options;\n\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n\n  getApplicationDefaultAsync(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // If we've already got a cached credential, just return it.\n      if (this.cachedCredential) {\n        return {\n          credential: this.cachedCredential,\n          projectId: yield this.getProjectIdAsync()\n        };\n      }\n\n      let credential;\n      let projectId; // Check for the existence of a local environment variable pointing to the\n      // location of the credential file. This is typically used in local\n      // developer scenarios.\n\n      credential = yield this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n\n      if (credential) {\n        if (credential instanceof jwtclient_1.JWT) {\n          credential.scopes = this.scopes;\n        }\n\n        this.cachedCredential = credential;\n        projectId = yield this.getProjectId();\n        return {\n          credential,\n          projectId\n        };\n      } // Look in the well-known credential file location.\n\n\n      credential = yield this._tryGetApplicationCredentialsFromWellKnownFile(options);\n\n      if (credential) {\n        if (credential instanceof jwtclient_1.JWT) {\n          credential.scopes = this.scopes;\n        }\n\n        this.cachedCredential = credential;\n        projectId = yield this.getProjectId();\n        return {\n          credential,\n          projectId\n        };\n      } // Determine if we're running on GCE.\n\n\n      let isGCE;\n\n      try {\n        isGCE = yield this._checkIsGCE();\n      } catch (e) {\n        throw new Error('Unexpected error determining execution environment: ' + e.message);\n      }\n\n      if (!isGCE) {\n        // We failed to find the default credentials. Bail out with an error.\n        throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n      } // For GCE, just return a default ComputeClient. It will take care of\n      // the rest.\n\n\n      this.cachedCredential = new computeclient_1.Compute(options);\n      projectId = yield this.getProjectId();\n      return {\n        projectId,\n        credential: this.cachedCredential\n      };\n    });\n  }\n  /**\n   * Determines whether the auth layer is running on Google Compute Engine.\n   * @returns A promise that resolves with the boolean.\n   * @api private\n   */\n\n\n  _checkIsGCE() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.checkIsGCE === undefined) {\n        this.checkIsGCE = yield gcpMetadata.isAvailable();\n      }\n\n      return this.checkIsGCE;\n    });\n  }\n  /**\n   * Attempts to load default credentials from the environment variable path..\n   * @returns Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n\n\n  _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] || process.env['google_application_credentials'];\n\n      if (!credentialsPath || credentialsPath.length === 0) {\n        return null;\n      }\n\n      try {\n        return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n      } catch (e) {\n        throw this.createError('Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.', e);\n      }\n    });\n  }\n  /**\n   * Attempts to load default credentials from a well-known file location\n   * @return Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n\n\n  _tryGetApplicationCredentialsFromWellKnownFile(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // First, figure out the location of the file, depending upon the OS type.\n      let location = null;\n\n      if (this._isWindows()) {\n        // Windows\n        location = process.env['APPDATA'];\n      } else {\n        // Linux or Mac\n        const home = process.env['HOME'];\n\n        if (home) {\n          location = this._pathJoin(home, '.config');\n        }\n      } // If we found the root path, expand it.\n\n\n      if (location) {\n        location = this._pathJoin(location, 'gcloud');\n        location = this._pathJoin(location, 'application_default_credentials.json');\n        location = this._mockWellKnownFilePath(location); // Check whether the file exists.\n\n        if (!this._fileExists(location)) {\n          location = null;\n        }\n      } // The file does not exist.\n\n\n      if (!location) {\n        return null;\n      } // The file seems to exist. Try to use it.\n\n\n      const client = yield this._getApplicationCredentialsFromFilePath(location, options);\n      this.warnOnProblematicCredentials(client);\n      return client;\n    });\n  }\n  /**\n   * Attempts to load default credentials from a file at the given path..\n   * @param filePath The path to the file to read.\n   * @returns Promise that resolves with the OAuth2Client\n   * @api private\n   */\n\n\n  _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Make sure the path looks like a string.\n      if (!filePath || filePath.length === 0) {\n        throw new Error('The file path is invalid.');\n      } // Make sure there is a file at the path. lstatSync will throw if there is\n      // nothing there.\n\n\n      try {\n        // Resolve path to actual file in case of symlink. Expect a thrown error\n        // if not resolvable.\n        filePath = fs.realpathSync(filePath);\n\n        if (!fs.lstatSync(filePath).isFile()) {\n          throw new Error();\n        }\n      } catch (err) {\n        throw this.createError(\"The file at \".concat(filePath, \" does not exist, or it is not a file.\"), err);\n      } // Now open a read stream on the file, and parse it.\n\n\n      try {\n        const readStream = this._createReadStream(filePath);\n\n        return this.fromStream(readStream, options);\n      } catch (err) {\n        throw this.createError(\"Unable to read the file at \".concat(filePath, \".\"), err);\n      }\n    });\n  }\n  /**\n   * Credentials from the Cloud SDK that are associated with Cloud SDK's project\n   * are problematic because they may not have APIs enabled and have limited\n   * quota. If this is the case, warn about it.\n   */\n\n\n  warnOnProblematicCredentials(client) {\n    if (client.email === exports.CLOUD_SDK_CLIENT_ID) {\n      messages.warn(messages.PROBLEMATIC_CREDENTIALS_WARNING);\n    }\n  }\n  /**\n   * Create a credentials instance using the given input options.\n   * @param json The input object.\n   * @param options The JWT or UserRefresh options for the client\n   * @returns JWT or UserRefresh Client with data\n   */\n\n\n  fromJSON(json, options) {\n    let client;\n\n    if (!json) {\n      throw new Error('Must pass in a JSON object containing the Google auth settings.');\n    }\n\n    this.jsonContent = json;\n    options = options || {};\n\n    if (json.type === 'authorized_user') {\n      client = new refreshclient_1.UserRefreshClient(options);\n    } else {\n      options.scopes = this.scopes;\n      client = new jwtclient_1.JWT(options);\n    }\n\n    client.fromJSON(json);\n    return client;\n  }\n\n  fromStream(inputStream, optionsOrCallback = {}, callback) {\n    let options = {};\n\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n\n    if (callback) {\n      this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n\n  fromStreamAsync(inputStream, options) {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error('Must pass in a stream containing the Google auth settings.');\n      }\n\n      let s = '';\n      inputStream.setEncoding('utf8').on('error', reject).on('data', chunk => s += chunk).on('end', () => {\n        try {\n          const data = JSON.parse(s);\n          const r = this.fromJSON(data, options);\n          return resolve(r);\n        } catch (err) {\n          return reject(err);\n        }\n      });\n    });\n  }\n  /**\n   * Create a credentials instance using the given API key string.\n   * @param apiKey The API key string\n   * @param options An optional options object.\n   * @returns A JWT loaded from the key\n   */\n\n\n  fromAPIKey(apiKey, options) {\n    options = options || {};\n    const client = new jwtclient_1.JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n  /**\n   * Determines whether the current operating system is Windows.\n   * @api private\n   */\n\n\n  _isWindows() {\n    const sys = this._osPlatform();\n\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Creates a file stream. Allows mocking.\n   * @api private\n   */\n\n\n  _createReadStream(filePath) {\n    return fs.createReadStream(filePath);\n  }\n  /**\n   * Gets the current operating system platform. Allows mocking.\n   * @api private\n   */\n\n\n  _osPlatform() {\n    return os.platform();\n  }\n  /**\n   * Determines whether a file exists. Allows mocking.\n   * @api private\n   */\n\n\n  _fileExists(filePath) {\n    return fs.existsSync(filePath);\n  }\n  /**\n   * Joins two parts of a path. Allows mocking.\n   * @api private\n   */\n\n\n  _pathJoin(item1, item2) {\n    return path.join(item1, item2);\n  }\n  /**\n   * Allows mocking of the path to a well-known file.\n   * @api private\n   */\n\n\n  _mockWellKnownFilePath(filePath) {\n    return filePath;\n  } // Creates an Error containing the given message, and includes the message\n  // from the optional err passed in.\n\n\n  createError(message, err) {\n    let s = message || '';\n\n    if (err) {\n      const errorMessage = String(err);\n\n      if (errorMessage && errorMessage.length > 0) {\n        if (s.length > 0) {\n          s += ' ';\n        }\n\n        s += errorMessage;\n      }\n    }\n\n    return Error(s);\n  }\n  /**\n   * Run the Google Cloud SDK command that prints the default project ID\n   */\n\n\n  getDefaultServiceProjectId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise(resolve => {\n        child_process_1.exec('gcloud config config-helper --format json', (err, stdout, stderr) => {\n          if (!err && stdout) {\n            try {\n              const projectId = JSON.parse(stdout).configuration.properties.core.project;\n              resolve(projectId);\n              return;\n            } catch (e) {// ignore errors\n            }\n          }\n\n          resolve(null);\n        });\n      });\n    });\n  }\n  /**\n   * Loads the project id from environment variables.\n   * @api private\n   */\n\n\n  getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'] || process.env['gcloud_project'] || process.env['google_cloud_project'];\n  }\n  /**\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n   * @api private\n   */\n\n\n  getFileProjectId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.cachedCredential) {\n        // Try to read the project ID from the cached credentials file\n        return this.cachedCredential.projectId;\n      } // Ensure the projectId is loaded from the keyFile if available.\n\n\n      if (this.keyFilename) {\n        const creds = yield this.getClient();\n\n        if (creds && creds.projectId) {\n          return creds.projectId;\n        }\n      } // Try to load a credentials file and read its project ID\n\n\n      const r = yield this._tryGetApplicationCredentialsFromEnvironmentVariable();\n\n      if (r) {\n        return r.projectId;\n      } else {\n        return null;\n      }\n    });\n  }\n  /**\n   * Gets the Compute Engine project ID if it can be inferred.\n   */\n\n\n  getGCEProjectId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const r = yield gcpMetadata.project('project-id');\n        return r;\n      } catch (e) {\n        // Ignore any errors\n        return null;\n      }\n    });\n  }\n\n  getCredentials(callback) {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n\n  getCredentialsAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.getClient();\n\n      if (this.jsonContent) {\n        const credential = {\n          client_email: this.jsonContent.client_email,\n          private_key: this.jsonContent.private_key\n        };\n        return credential;\n      }\n\n      const isGCE = yield this._checkIsGCE();\n\n      if (!isGCE) {\n        throw new Error('Unknown error.');\n      } // For GCE, return the service account details from the metadata server\n      // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n      // The GCF metadata server doesn't respect querystring params if this / is\n      // not included.\n\n\n      const data = yield gcpMetadata.instance({\n        property: 'service-accounts/',\n        params: {\n          recursive: 'true'\n        }\n      });\n\n      if (!data || !data.default || !data.default.email) {\n        throw new Error('Failure from metadata server.');\n      }\n\n      return {\n        client_email: data.default.email\n      };\n    });\n  }\n  /**\n   * Automatically obtain a client based on the provided configuration.  If no\n   * options were passed, use Application Default Credentials.\n   */\n\n\n  getClient(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (options) {\n        this.keyFilename = options.keyFilename || options.keyFile || this.keyFilename;\n        this.scopes = options.scopes || this.scopes;\n        this.jsonContent = options.credentials || this.jsonContent;\n        this.clientOptions = options.clientOptions;\n      }\n\n      if (!this.cachedCredential) {\n        if (this.jsonContent) {\n          this.cachedCredential = yield this.fromJSON(this.jsonContent, this.clientOptions);\n        } else if (this.keyFilename) {\n          const filePath = path.resolve(this.keyFilename);\n          const stream = fs.createReadStream(filePath);\n          this.cachedCredential = yield this.fromStreamAsync(stream, this.clientOptions);\n        } else {\n          yield this.getApplicationDefaultAsync(this.clientOptions);\n        }\n      }\n\n      return this.cachedCredential;\n    });\n  }\n  /**\n   * Automatically obtain application default credentials, and return\n   * an access token for making requests.\n   */\n\n\n  getAccessToken() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = yield this.getClient();\n      return (yield client.getAccessToken()).token;\n    });\n  }\n  /**\n   * Obtain the HTTP headers that will provide authorization for a given\n   * request.\n   */\n\n\n  getRequestHeaders(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = yield this.getClient();\n      return client.getRequestHeaders(url);\n    });\n  }\n  /**\n   * Obtain credentials for a request, then attach the appropriate headers to\n   * the request options.\n   * @param opts Axios or Request options on which to attach the headers\n   */\n\n\n  authorizeRequest(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      opts = opts || {};\n      const url = opts.url || opts.uri;\n      const client = yield this.getClient();\n      const headers = yield client.getRequestHeaders(url);\n      opts.headers = Object.assign(opts.headers || {}, headers);\n      return opts;\n    });\n  }\n  /**\n   * Automatically obtain application default credentials, and make an\n   * HTTP request using the given options.\n   * @param opts Axios request options for the HTTP request.\n   */\n  // tslint:disable-next-line no-any\n\n\n  request(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = yield this.getClient();\n      return client.request(opts);\n    });\n  }\n  /**\n   * Determine the compute environment in which the code is running.\n   */\n\n\n  getEnv() {\n    return envDetect_1.getEnv();\n  }\n  /**\n   * Sign the given data with the current private key, or go out\n   * to the IAM API to sign it.\n   * @param data The data to be signed.\n   */\n\n\n  sign(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = yield this.getClient();\n      const crypto = crypto_1.createCrypto();\n\n      if (client instanceof jwtclient_1.JWT && client.key && !isbrowser_1.isBrowser()) {\n        const sign = crypto.createSign('RSA-SHA256');\n        sign.update(data);\n        return sign.sign(client.key, 'base64');\n      }\n\n      const projectId = yield this.getProjectId();\n\n      if (!projectId) {\n        throw new Error('Cannot sign data without a project ID.');\n      }\n\n      const creds = yield this.getCredentials();\n\n      if (!creds.client_email) {\n        throw new Error('Cannot sign data without `client_email`.');\n      }\n\n      const id = \"projects/\".concat(projectId, \"/serviceAccounts/\").concat(creds.client_email);\n      const res = yield this.request({\n        method: 'POST',\n        url: \"https://iam.googleapis.com/v1/\".concat(id, \":signBlob\"),\n        data: {\n          bytesToSign: crypto.encodeBase64StringUtf8(data)\n        }\n      });\n      return res.data.signature;\n    });\n  }\n\n}\n/**\n * Export DefaultTransporter as a static property of the class.\n */\n\n\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\nexports.GoogleAuth = GoogleAuth;","map":null,"metadata":{},"sourceType":"script"}