{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * @module common/paginator\n */\n\nconst arrify = require(\"arrify\");\n\nconst extend = require(\"extend\");\n\nconst split_array_stream_1 = require(\"split-array-stream\");\n\nconst stream_1 = require(\"stream\");\n\nconst streamEvents = require(\"stream-events\");\n/**\n * Limit requests according to a `maxApiCalls` limit.\n *\n * @param {function} makeRequestFn - The function that will be called.\n * @param {object=} options - Configuration object.\n * @param {number} options.maxApiCalls - The maximum number of API calls to make.\n * @param {object} options.streamOptions - Options to pass to the Stream constructor.\n */\n\n\nfunction createLimiter(makeRequestFn, options) {\n  options = options || {};\n  const streamOptions = options.streamOptions || {};\n  streamOptions.objectMode = true;\n  const stream = streamEvents(new stream_1.Transform(streamOptions));\n  let requestsMade = 0;\n  let requestsToMake = -1;\n\n  if (typeof options.maxApiCalls === 'number') {\n    requestsToMake = options.maxApiCalls;\n  }\n\n  return {\n    // tslint:disable-next-line:no-any\n    makeRequest(...args) {\n      requestsMade++;\n\n      if (requestsToMake >= 0 && requestsMade > requestsToMake) {\n        stream.push(null);\n        return;\n      }\n\n      makeRequestFn.apply(null, args);\n      return stream;\n    },\n\n    stream\n  };\n}\n\nexports.createLimiter = createLimiter;\n/*! Developer Documentation\n *\n * paginator is used to auto-paginate `nextQuery` methods as well as\n * streamifying them.\n *\n * Before:\n *\n *   search.query('done=true', function(err, results, nextQuery) {\n *     search.query(nextQuery, function(err, results, nextQuery) {});\n *   });\n *\n * After:\n *\n *   search.query('done=true', function(err, results) {});\n *\n * Methods to extend should be written to accept callbacks and return a\n * `nextQuery`.\n */\n\nclass Paginator {\n  /**\n   * Cache the original method, then overwrite it on the Class's prototype.\n   *\n   * @param {function} Class - The parent class of the methods to extend.\n   * @param {string|string[]} methodNames - Name(s) of the methods to extend.\n   */\n  // tslint:disable-next-line:variable-name\n  extend(Class, methodNames) {\n    methodNames = arrify(methodNames);\n    methodNames.forEach(methodName => {\n      const originalMethod = Class.prototype[methodName]; // map the original method to a private member\n\n      Class.prototype[methodName + '_'] = originalMethod; // overwrite the original to auto-paginate\n      // tslint:disable-next-line:no-any\n\n      Class.prototype[methodName] = function (...args) {\n        const parsedArguments = paginator.parseArguments_(args);\n        return paginator.run_(parsedArguments, originalMethod.bind(this));\n      };\n    });\n  }\n  /**\n   * Wraps paginated API calls in a readable object stream.\n   *\n   * This method simply calls the nextQuery recursively, emitting results to a\n   * stream. The stream ends when `nextQuery` is null.\n   *\n   * `maxResults` will act as a cap for how many results are fetched and emitted\n   * to the stream.\n   *\n   * @param {string} methodName - Name of the method to streamify.\n   * @return {function} - Wrapped function.\n   */\n  // tslint:disable-next-line:no-any\n\n\n  streamify(methodName) {\n    return function (...args) {\n      const parsedArguments = paginator.parseArguments_(args);\n      const originalMethod = this[methodName + '_'] || this[methodName];\n      return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));\n    };\n  }\n  /**\n   * Parse a pseudo-array `arguments` for a query and callback.\n   *\n   * @param {array} args - The original `arguments` pseduo-array that the original\n   *     method received.\n   */\n  // tslint:disable-next-line:no-any\n\n\n  parseArguments_(args) {\n    let query;\n    let autoPaginate = true;\n    let maxApiCalls = -1;\n    let maxResults = -1;\n    let callback;\n    const firstArgument = args[0];\n    const lastArgument = args[args.length - 1];\n\n    if (typeof firstArgument === 'function') {\n      callback = firstArgument;\n    } else {\n      query = firstArgument;\n    }\n\n    if (typeof lastArgument === 'function') {\n      callback = lastArgument;\n    }\n\n    if (typeof query === 'object') {\n      query = extend(true, {}, query); // Check if the user only asked for a certain amount of results.\n\n      if (query.maxResults && typeof query.maxResults === 'number') {\n        // `maxResults` is used API-wide.\n        maxResults = query.maxResults;\n      } else if (typeof query.pageSize === 'number') {\n        // `pageSize` is Pub/Sub's `maxResults`.\n        maxResults = query.pageSize;\n      }\n\n      if (query.maxApiCalls && typeof query.maxApiCalls === 'number') {\n        maxApiCalls = query.maxApiCalls;\n        delete query.maxApiCalls;\n      } // maxResults is the user specified limit.\n\n\n      if (maxResults !== -1 || query.autoPaginate === false) {\n        autoPaginate = false;\n      }\n    }\n\n    const parsedArguments = {\n      query: query || {},\n      autoPaginate,\n      maxApiCalls,\n      maxResults,\n      callback\n    };\n    parsedArguments.streamOptions = extend(true, {}, parsedArguments.query);\n    delete parsedArguments.streamOptions.autoPaginate;\n    delete parsedArguments.streamOptions.maxResults;\n    delete parsedArguments.streamOptions.pageSize;\n    return parsedArguments;\n  }\n  /**\n   * This simply checks to see if `autoPaginate` is set or not, if it's true\n   * then we buffer all results, otherwise simply call the original method.\n   *\n   * @param {array} parsedArguments - Parsed arguments from the original method\n   *     call.\n   * @param {object=|string=} parsedArguments.query - Query object. This is most\n   *     commonly an object, but to make the API more simple, it can also be a\n   *     string in some places.\n   * @param {function=} parsedArguments.callback - Callback function.\n   * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n   * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n   * @param {number} parsedArguments.maxResults - Maximum results to return.\n   * @param {function} originalMethod - The cached method that accepts a callback\n   *     and returns `nextQuery` to receive more results.\n   */\n\n\n  run_(parsedArguments, originalMethod) {\n    const query = parsedArguments.query;\n    const callback = parsedArguments.callback;\n\n    if (!parsedArguments.autoPaginate) {\n      return originalMethod(query, callback);\n    }\n\n    const results = new Array();\n    const promise = new Promise((resolve, reject) => {\n      paginator.runAsStream_(parsedArguments, originalMethod).on('error', reject).on('data', data => results.push(data)).on('end', () => resolve(results));\n    });\n\n    if (!callback) {\n      return promise.then(results => [results]);\n    }\n\n    promise.then(results => callback(null, results), err => callback(err));\n  }\n  /**\n   * This method simply calls the nextQuery recursively, emitting results to a\n   * stream. The stream ends when `nextQuery` is null.\n   *\n   * `maxResults` will act as a cap for how many results are fetched and emitted\n   * to the stream.\n   *\n   * @param {object=|string=} parsedArguments.query - Query object. This is most\n   *     commonly an object, but to make the API more simple, it can also be a\n   *     string in some places.\n   * @param {function=} parsedArguments.callback - Callback function.\n   * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n   * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n   * @param {number} parsedArguments.maxResults - Maximum results to return.\n   * @param {function} originalMethod - The cached method that accepts a callback\n   *     and returns `nextQuery` to receive more results.\n   * @return {stream} - Readable object stream.\n   */\n\n\n  runAsStream_(parsedArguments, originalMethod) {\n    const query = parsedArguments.query;\n    let resultsToSend = parsedArguments.maxResults;\n    const limiter = exports.createLimiter(makeRequest, {\n      maxApiCalls: parsedArguments.maxApiCalls,\n      streamOptions: parsedArguments.streamOptions\n    });\n    const stream = limiter.stream;\n    stream.once('reading', () => {\n      limiter.makeRequest(query);\n    });\n\n    function makeRequest(query) {\n      originalMethod(query, onResultSet);\n    } // tslint:disable-next-line:no-any\n\n\n    function onResultSet(err, results, nextQuery) {\n      if (err) {\n        stream.destroy(err);\n        return;\n      }\n\n      if (resultsToSend >= 0 && results.length > resultsToSend) {\n        results = results.splice(0, resultsToSend);\n      }\n\n      resultsToSend -= results.length;\n      split_array_stream_1.split(results, stream).then(streamEnded => {\n        if (streamEnded) {\n          return;\n        }\n\n        if (nextQuery && resultsToSend !== 0) {\n          limiter.makeRequest(nextQuery);\n          return;\n        }\n\n        stream.push(null);\n      });\n    }\n\n    return limiter.stream;\n  }\n\n}\n\nexports.Paginator = Paginator;\nconst paginator = new Paginator();\nexports.paginator = paginator;","map":null,"metadata":{},"sourceType":"script"}