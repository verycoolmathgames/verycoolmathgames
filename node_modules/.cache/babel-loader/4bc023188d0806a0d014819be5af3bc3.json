{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar Protobuf = require(\"protobufjs\");\n\nvar descriptor = require(\"protobufjs/ext/descriptor\");\n\nvar camelCase = require(\"lodash.camelcase\");\n\nvar descriptorOptions = {\n  longs: String,\n  enums: String,\n  bytes: String,\n  defaults: true,\n  oneofs: true,\n  json: true\n};\n\nfunction joinName(baseName, name) {\n  if (baseName === '') {\n    return name;\n  } else {\n    return baseName + '.' + name;\n  }\n}\n\nfunction isHandledReflectionObject(obj) {\n  return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\n\nfunction isNamespaceBase(obj) {\n  return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\n\nfunction getAllHandledReflectionObjects(obj, parentName) {\n  var objName = joinName(parentName, obj.name);\n\n  if (isHandledReflectionObject(obj)) {\n    return [[objName, obj]];\n  } else {\n    if (isNamespaceBase(obj) && typeof obj.nested !== undefined) {\n      return Object.keys(obj.nested).map(function (name) {\n        return getAllHandledReflectionObjects(obj.nested[name], objName);\n      }).reduce(function (accumulator, currentValue) {\n        return accumulator.concat(currentValue);\n      }, []);\n    }\n  }\n\n  return [];\n}\n\nfunction createDeserializer(cls, options) {\n  return function deserialize(argBuf) {\n    return cls.toObject(cls.decode(argBuf), options);\n  };\n}\n\nfunction createSerializer(cls) {\n  return function serialize(arg) {\n    var message = cls.fromObject(arg);\n    return cls.encode(message).finish();\n  };\n}\n\nfunction createMethodDefinition(method, serviceName, options) {\n  /* This is only ever called after the corresponding root.resolveAll(), so we\n   * can assume that the resolved request and response types are non-null */\n  var requestType = method.resolvedRequestType;\n  var responseType = method.resolvedResponseType;\n  return {\n    path: '/' + serviceName + '/' + method.name,\n    requestStream: !!method.requestStream,\n    responseStream: !!method.responseStream,\n    requestSerialize: createSerializer(requestType),\n    requestDeserialize: createDeserializer(requestType, options),\n    responseSerialize: createSerializer(responseType),\n    responseDeserialize: createDeserializer(responseType, options),\n    // TODO(murgatroid99): Find a better way to handle this\n    originalName: camelCase(method.name),\n    requestType: createMessageDefinition(requestType),\n    responseType: createMessageDefinition(responseType)\n  };\n}\n\nfunction createServiceDefinition(service, name, options) {\n  var def = {};\n\n  for (var _i = 0, _a = service.methodsArray; _i < _a.length; _i++) {\n    var method = _a[_i];\n    def[method.name] = createMethodDefinition(method, name, options);\n  }\n\n  return def;\n}\n\nvar fileDescriptorCache = new Map();\n\nfunction getFileDescriptors(root) {\n  if (fileDescriptorCache.has(root)) {\n    return fileDescriptorCache.get(root);\n  } else {\n    var descriptorList = root.toDescriptor('proto3').file;\n    var bufferList = descriptorList.map(function (value) {\n      return Buffer.from(descriptor.FileDescriptorProto.encode(value).finish());\n    });\n    fileDescriptorCache.set(root, bufferList);\n    return bufferList;\n  }\n}\n\nfunction createMessageDefinition(message) {\n  var messageDescriptor = message.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 DescriptorProto',\n    type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n    fileDescriptorProtos: getFileDescriptors(message.root)\n  };\n}\n\nfunction createEnumDefinition(enumType) {\n  var enumDescriptor = enumType.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 EnumDescriptorProto',\n    type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n    fileDescriptorProtos: getFileDescriptors(enumType.root)\n  };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\n\n\nfunction createDefinition(obj, name, options) {\n  if (obj instanceof Protobuf.Service) {\n    return createServiceDefinition(obj, name, options);\n  } else if (obj instanceof Protobuf.Type) {\n    return createMessageDefinition(obj);\n  } else if (obj instanceof Protobuf.Enum) {\n    return createEnumDefinition(obj);\n  } else {\n    throw new Error('Type mismatch in reflection object handling');\n  }\n}\n\nfunction createPackageDefinition(root, options) {\n  var def = {};\n  root.resolveAll();\n\n  for (var _i = 0, _a = getAllHandledReflectionObjects(root, ''); _i < _a.length; _i++) {\n    var _b = _a[_i],\n        name = _b[0],\n        obj = _b[1];\n    def[name] = createDefinition(obj, name, options);\n  }\n\n  return def;\n}\n\nfunction addIncludePathResolver(root, includePaths) {\n  var originalResolvePath = root.resolvePath;\n\n  root.resolvePath = function (origin, target) {\n    if (path.isAbsolute(target)) {\n      return target;\n    }\n\n    for (var _i = 0, includePaths_1 = includePaths; _i < includePaths_1.length; _i++) {\n      var directory = includePaths_1[_i];\n      var fullPath = path.join(directory, target);\n\n      try {\n        fs.accessSync(fullPath, fs.constants.R_OK);\n        return fullPath;\n      } catch (err) {\n        continue;\n      }\n    }\n\n    return originalResolvePath(origin, target);\n  };\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\n\n\nfunction load(filename, options) {\n  var root = new Protobuf.Root();\n  options = options || {};\n\n  if (!!options.includeDirs) {\n    if (!Array.isArray(options.includeDirs)) {\n      return Promise.reject(new Error('The includeDirs option must be an array'));\n    }\n\n    addIncludePathResolver(root, options.includeDirs);\n  }\n\n  return root.load(filename, options).then(function (loadedRoot) {\n    loadedRoot.resolveAll();\n    return createPackageDefinition(root, options);\n  });\n}\n\nexports.load = load;\n\nfunction loadSync(filename, options) {\n  var root = new Protobuf.Root();\n  options = options || {};\n\n  if (!!options.includeDirs) {\n    if (!Array.isArray(options.includeDirs)) {\n      throw new Error('The includeDirs option must be an array');\n    }\n\n    addIncludePathResolver(root, options.includeDirs);\n  }\n\n  var loadedRoot = root.loadSync(filename, options);\n  loadedRoot.resolveAll();\n  return createPackageDefinition(root, options);\n}\n\nexports.loadSync = loadSync; // Load Google's well-known proto files that aren't exposed by Protobuf.js.\n\n{\n  // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n  // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n  var wellKnownProtos = ['api', 'descriptor', 'source_context', 'type'];\n  var sourceDir = path.join(path.dirname(require.resolve('protobufjs')), 'google', 'protobuf');\n\n  for (var _i = 0, wellKnownProtos_1 = wellKnownProtos; _i < wellKnownProtos_1.length; _i++) {\n    var proto = wellKnownProtos_1[_i];\n    var file = path.join(sourceDir, proto + \".proto\");\n    var descriptor_1 = Protobuf.loadSync(file).toJSON(); // @ts-ignore\n\n    Protobuf.common(proto, descriptor_1.nested.google.nested);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}