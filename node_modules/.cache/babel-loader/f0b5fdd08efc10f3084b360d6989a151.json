{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\n\nfunction isLegalKey(key) {\n  return LEGAL_KEY_REGEX.test(key);\n}\n\nfunction isLegalNonBinaryValue(value) {\n  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\n\nfunction isBinaryKey(key) {\n  return key.endsWith('-bin');\n}\n\nfunction normalizeKey(key) {\n  return key.toLowerCase();\n}\n\nfunction validate(key, value) {\n  if (!isLegalKey(key)) {\n    throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n  }\n\n  if (value != null) {\n    if (isBinaryKey(key)) {\n      if (!(value instanceof Buffer)) {\n        throw new Error(\"keys that end with '-bin' must have Buffer values\");\n      }\n    } else {\n      if (value instanceof Buffer) {\n        throw new Error(\"keys that don't end with '-bin' must have String values\");\n      }\n\n      if (!isLegalNonBinaryValue(value)) {\n        throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n      }\n    }\n  }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\n\n\nclass Metadata {\n  constructor(options) {\n    this.options = options;\n    this.internalRepr = new Map();\n  }\n  /**\n   * Sets the given value for the given key by replacing any other values\n   * associated with that key. Normalizes the key.\n   * @param key The key to whose value should be set.\n   * @param value The value to set. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n\n\n  set(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    this.internalRepr.set(key, [value]);\n  }\n  /**\n   * Adds the given value for the given key by appending to a list of previous\n   * values associated with that key. Normalizes the key.\n   * @param key The key for which a new value should be appended.\n   * @param value The value to add. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n\n\n  add(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    const existingValue = this.internalRepr.get(key);\n\n    if (existingValue === undefined) {\n      this.internalRepr.set(key, [value]);\n    } else {\n      existingValue.push(value);\n    }\n  }\n  /**\n   * Removes the given key and any associated values. Normalizes the key.\n   * @param key The key whose values should be removed.\n   */\n\n\n  remove(key) {\n    key = normalizeKey(key);\n    validate(key);\n    this.internalRepr.delete(key);\n  }\n  /**\n   * Gets a list of all values associated with the key. Normalizes the key.\n   * @param key The key whose value should be retrieved.\n   * @return A list of values associated with the given key.\n   */\n\n\n  get(key) {\n    key = normalizeKey(key);\n    validate(key);\n    return this.internalRepr.get(key) || [];\n  }\n  /**\n   * Gets a plain object mapping each key to the first value associated with it.\n   * This reflects the most common way that people will want to see metadata.\n   * @return A key/value mapping of the metadata.\n   */\n\n\n  getMap() {\n    const result = {};\n    this.internalRepr.forEach((values, key) => {\n      if (values.length > 0) {\n        const v = values[0];\n        result[key] = v instanceof Buffer ? v.slice() : v;\n      }\n    });\n    return result;\n  }\n  /**\n   * Clones the metadata object.\n   * @return The newly cloned object.\n   */\n\n\n  clone() {\n    const newMetadata = new Metadata();\n    const newInternalRepr = newMetadata.internalRepr;\n    this.internalRepr.forEach((value, key) => {\n      const clonedValue = value.map(v => {\n        if (v instanceof Buffer) {\n          return Buffer.from(v);\n        } else {\n          return v;\n        }\n      });\n      newInternalRepr.set(key, clonedValue);\n    });\n    return newMetadata;\n  }\n  /**\n   * Merges all key-value pairs from a given Metadata object into this one.\n   * If both this object and the given object have values in the same key,\n   * values from the other Metadata object will be appended to this object's\n   * values.\n   * @param other A Metadata object.\n   */\n\n\n  merge(other) {\n    other.internalRepr.forEach((values, key) => {\n      const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n      this.internalRepr.set(key, mergedValue);\n    });\n  }\n\n  setOptions(options) {\n    this.options = options;\n  }\n  /**\n   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n   */\n\n\n  toHttp2Headers() {\n    // NOTE: Node <8.9 formats http2 headers incorrectly.\n    const result = {};\n    this.internalRepr.forEach((values, key) => {\n      // We assume that the user's interaction with this object is limited to\n      // through its public API (i.e. keys and values are already validated).\n      result[key] = values.map(value => {\n        if (value instanceof Buffer) {\n          return value.toString('base64');\n        } else {\n          return value;\n        }\n      });\n    });\n    return result;\n  } // For compatibility with the other Metadata implementation\n\n\n  _getCoreRepresentation() {\n    return this.internalRepr;\n  }\n  /**\n   * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n   * object.\n   * @param headers An IncomingHttpHeaders object.\n   */\n\n\n  static fromHttp2Headers(headers) {\n    const result = new Metadata();\n    Object.keys(headers).forEach(key => {\n      // Reserved headers (beginning with `:`) are not valid keys.\n      if (key.charAt(0) === ':') {\n        return;\n      }\n\n      const values = headers[key];\n\n      if (isBinaryKey(key)) {\n        if (Array.isArray(values)) {\n          values.forEach(value => {\n            result.add(key, Buffer.from(value, 'base64'));\n          });\n        } else if (values !== undefined) {\n          values.split(',').forEach(v => {\n            result.add(key, Buffer.from(v.trim(), 'base64'));\n          });\n        }\n      } else {\n        if (Array.isArray(values)) {\n          values.forEach(value => {\n            result.add(key, value);\n          });\n        } else if (values !== undefined) {\n          values.split(',').forEach(v => result.add(key, v.trim()));\n        }\n      }\n    });\n    return result;\n  }\n\n}\n\nexports.Metadata = Metadata;","map":null,"metadata":{},"sourceType":"script"}