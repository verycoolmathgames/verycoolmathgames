{"ast":null,"code":"// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n'use strict';\n\nconst gapicConfig = require('./firestore_client_config.json');\n\nconst gax = require('google-gax');\n\nconst path = require('path');\n\nconst VERSION = require('../../../package.json').version;\n/**\n * The Cloud Firestore service.\n *\n * This service exposes several types of comparable timestamps:\n *\n * *    `create_time` - The time at which a document was created. Changes only\n *      when a document is deleted, then re-created. Increases in a strict\n *       monotonic fashion.\n * *    `update_time` - The time at which a document was last updated. Changes\n *      every time a document is modified. Does not change when a write results\n *      in no modifications. Increases in a strict monotonic fashion.\n * *    `read_time` - The time at which a particular state was observed. Used\n *      to denote a consistent snapshot of the database or the time at which a\n *      Document was observed to not exist.\n * *    `commit_time` - The time at which the writes in a transaction were\n *      committed. Any read with an equal or greater `read_time` is guaranteed\n *      to see the effects of the transaction.\n *\n * @class\n * @memberof v1beta1\n */\n\n\nclass FirestoreClient {\n  /**\n   * Construct an instance of FirestoreClient.\n   *\n   * @param {object} [options] - The configuration object. See the subsequent\n   *   parameters for more details.\n   * @param {object} [options.credentials] - Credentials object.\n   * @param {string} [options.credentials.client_email]\n   * @param {string} [options.credentials.private_key]\n   * @param {string} [options.email] - Account email address. Required when\n   *     using a .pem or .p12 keyFilename.\n   * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or\n   *     .p12 key downloaded from the Google Developers Console. If you provide\n   *     a path to a JSON file, the projectId option below is not necessary.\n   *     NOTE: .pem and .p12 require you to specify options.email as well.\n   * @param {number} [options.port] - The port on which to connect to\n   *     the remote host.\n   * @param {string} [options.projectId] - The project ID from the Google\n   *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check\n   *     the environment variable GCLOUD_PROJECT for your project ID. If your\n   *     app is running in an environment which supports\n   *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},\n   *     your project ID will be detected automatically.\n   * @param {function} [options.promise] - Custom promise module to use instead\n   *     of native Promises.\n   * @param {string} [options.servicePath] - The domain name of the\n   *     API remote host.\n   */\n  constructor(opts) {\n    opts = opts || {};\n    this._descriptors = {};\n    const servicePath = opts.servicePath || opts.apiEndpoint || this.constructor.servicePath; // Ensure that options include the service address and port.\n\n    opts = Object.assign({\n      clientConfig: {},\n      port: this.constructor.port,\n      servicePath\n    }, opts); // Create a `gaxGrpc` object, with any grpc-specific options\n    // sent to the client.\n\n    opts.scopes = this.constructor.scopes;\n    const gaxGrpc = new gax.GrpcClient(opts); // Save the auth object to the client, for use by other methods.\n\n    this.auth = gaxGrpc.auth; // Determine the client header string.\n\n    const clientHeader = [\"gl-node/\".concat(process.version), \"grpc/\".concat(gaxGrpc.grpcVersion), \"gax/\".concat(gax.version), \"gapic/\".concat(VERSION)];\n\n    if (opts.libName && opts.libVersion) {\n      clientHeader.push(\"\".concat(opts.libName, \"/\").concat(opts.libVersion));\n    } // Load the applicable protos.\n\n\n    const protos = gaxGrpc.loadProto(path.join(__dirname, '..', '..', 'protos'), ['google/firestore/v1beta1/firestore.proto']); // This API contains \"path templates\"; forward-slash-separated\n    // identifiers to uniquely identify resources within the API.\n    // Create useful helper objects for these.\n\n    this._pathTemplates = {\n      anyPathPathTemplate: new gax.PathTemplate('projects/{project}/databases/{database}/documents/{document}/{any_path=**}'),\n      databaseRootPathTemplate: new gax.PathTemplate('projects/{project}/databases/{database}'),\n      documentPathPathTemplate: new gax.PathTemplate('projects/{project}/databases/{database}/documents/{document_path=**}'),\n      documentRootPathTemplate: new gax.PathTemplate('projects/{project}/databases/{database}/documents')\n    }; // Some of the methods on this service return \"paged\" results,\n    // (e.g. 50 results at a time, with tokens to get subsequent\n    // pages). Denote the keys used for pagination and results.\n\n    this._descriptors.page = {\n      listDocuments: new gax.PageDescriptor('pageToken', 'nextPageToken', 'documents'),\n      listCollectionIds: new gax.PageDescriptor('pageToken', 'nextPageToken', 'collectionIds')\n    }; // Some of the methods on this service provide streaming responses.\n    // Provide descriptors for these.\n\n    this._descriptors.stream = {\n      batchGetDocuments: new gax.StreamDescriptor(gax.StreamType.SERVER_STREAMING),\n      runQuery: new gax.StreamDescriptor(gax.StreamType.SERVER_STREAMING),\n      write: new gax.StreamDescriptor(gax.StreamType.BIDI_STREAMING),\n      listen: new gax.StreamDescriptor(gax.StreamType.BIDI_STREAMING)\n    }; // Put together the default options sent with requests.\n\n    const defaults = gaxGrpc.constructSettings('google.firestore.v1beta1.Firestore', gapicConfig, opts.clientConfig, {\n      'x-goog-api-client': clientHeader.join(' ')\n    }); // Set up a dictionary of \"inner API calls\"; the core implementation\n    // of calling the API is handled in `google-gax`, with this code\n    // merely providing the destination and request information.\n\n    this._innerApiCalls = {}; // Put together the \"service stub\" for\n    // google.firestore.v1beta1.Firestore.\n\n    const firestoreStub = gaxGrpc.createStub(protos.google.firestore.v1beta1.Firestore, opts); // Iterate over each of the methods that the service provides\n    // and create an API call method for each.\n\n    const firestoreStubMethods = ['getDocument', 'listDocuments', 'createDocument', 'updateDocument', 'deleteDocument', 'batchGetDocuments', 'beginTransaction', 'commit', 'rollback', 'runQuery', 'write', 'listen', 'listCollectionIds'];\n\n    for (const methodName of firestoreStubMethods) {\n      this._innerApiCalls[methodName] = gax.createApiCall(firestoreStub.then(stub => function () {\n        const args = Array.prototype.slice.call(arguments, 0);\n        return stub[methodName].apply(stub, args);\n      }, err => function () {\n        throw err;\n      }), defaults[methodName], this._descriptors.page[methodName] || this._descriptors.stream[methodName]);\n    }\n  }\n  /**\n   * The DNS address for this API service.\n   */\n\n\n  static get servicePath() {\n    return 'firestore.googleapis.com';\n  }\n  /**\n   * The DNS address for this API service - same as servicePath(),\n   * exists for compatibility reasons.\n   */\n\n\n  static get apiEndpoint() {\n    return 'firestore.googleapis.com';\n  }\n  /**\n   * The port for this API service.\n   */\n\n\n  static get port() {\n    return 443;\n  }\n  /**\n   * The scopes needed to make gRPC calls for every method defined\n   * in this service.\n   */\n\n\n  static get scopes() {\n    return ['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/datastore'];\n  }\n  /**\n   * Return the project ID used by this class.\n   * @param {function(Error, string)} callback - the callback to\n   *   be called with the current project Id.\n   */\n\n\n  getProjectId(callback) {\n    return this.auth.getProjectId(callback);\n  } // -------------------\n  // -- Service calls --\n  // -------------------\n\n  /**\n   * Gets a single document.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.name\n   *   The resource name of the Document to get. In the format:\n   *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n   * @param {Object} [request.mask]\n   *   The fields to return. If not set, returns all fields.\n   *\n   *   If the document has a field that is not present in this mask, that field\n   *   will not be returned in the response.\n   *\n   *   This object should have the same structure as [DocumentMask]{@link google.firestore.v1beta1.DocumentMask}\n   * @param {Buffer} [request.transaction]\n   *   Reads the document in a transaction.\n   * @param {Object} [request.readTime]\n   *   Reads the version of the document at the given time.\n   *   This may not be older than 60 seconds.\n   *\n   *   This object should have the same structure as [Timestamp]{@link google.protobuf.Timestamp}\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @param {function(?Error, ?Object)} [callback]\n   *   The function which will be called with the result of the API call.\n   *\n   *   The second parameter to the callback is an object representing [Document]{@link google.firestore.v1beta1.Document}.\n   * @returns {Promise} - The promise which resolves to an array.\n   *   The first element of the array is an object representing [Document]{@link google.firestore.v1beta1.Document}.\n   *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const formattedName = client.anyPathPath('[PROJECT]', '[DATABASE]', '[DOCUMENT]', '[ANY_PATH]');\n   * client.getDocument({name: formattedName})\n   *   .then(responses => {\n   *     const response = responses[0];\n   *     // doThingsWith(response)\n   *   })\n   *   .catch(err => {\n   *     console.error(err);\n   *   });\n   */\n\n\n  getDocument(request, options, callback) {\n    if (options instanceof Function && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    options.otherArgs = options.otherArgs || {};\n    options.otherArgs.headers = options.otherArgs.headers || {};\n    options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n      name: request.name\n    });\n    return this._innerApiCalls.getDocument(request, options, callback);\n  }\n  /**\n   * Lists documents.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.parent\n   *   The parent resource name. In the format:\n   *   `projects/{project_id}/databases/{database_id}/documents` or\n   *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n   *   For example:\n   *   `projects/my-project/databases/my-database/documents` or\n   *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n   * @param {string} request.collectionId\n   *   The collection ID, relative to `parent`, to list. For example: `chatrooms`\n   *   or `messages`.\n   * @param {number} [request.pageSize]\n   *   The maximum number of resources contained in the underlying API\n   *   response. If page streaming is performed per-resource, this\n   *   parameter does not affect the return value. If page streaming is\n   *   performed per-page, this determines the maximum number of\n   *   resources in a page.\n   * @param {string} [request.orderBy]\n   *   The order to sort results by. For example: `priority desc, name`.\n   * @param {Object} [request.mask]\n   *   The fields to return. If not set, returns all fields.\n   *\n   *   If a document has a field that is not present in this mask, that field\n   *   will not be returned in the response.\n   *\n   *   This object should have the same structure as [DocumentMask]{@link google.firestore.v1beta1.DocumentMask}\n   * @param {Buffer} [request.transaction]\n   *   Reads documents in a transaction.\n   * @param {Object} [request.readTime]\n   *   Reads documents as they were at the given time.\n   *   This may not be older than 60 seconds.\n   *\n   *   This object should have the same structure as [Timestamp]{@link google.protobuf.Timestamp}\n   * @param {boolean} [request.showMissing]\n   *   If the list should show missing documents. A missing document is a\n   *   document that does not exist but has sub-documents. These documents will\n   *   be returned with a key but will not have fields, Document.create_time,\n   *   or Document.update_time set.\n   *\n   *   Requests with `show_missing` may not specify `where` or\n   *   `order_by`.\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @param {function(?Error, ?Array, ?Object, ?Object)} [callback]\n   *   The function which will be called with the result of the API call.\n   *\n   *   The second parameter to the callback is Array of [Document]{@link google.firestore.v1beta1.Document}.\n   *\n   *   When autoPaginate: false is specified through options, it contains the result\n   *   in a single response. If the response indicates the next page exists, the third\n   *   parameter is set to be used for the next request object. The fourth parameter keeps\n   *   the raw response object of an object representing [ListDocumentsResponse]{@link google.firestore.v1beta1.ListDocumentsResponse}.\n   * @returns {Promise} - The promise which resolves to an array.\n   *   The first element of the array is Array of [Document]{@link google.firestore.v1beta1.Document}.\n   *\n   *   When autoPaginate: false is specified through options, the array has three elements.\n   *   The first element is Array of [Document]{@link google.firestore.v1beta1.Document} in a single response.\n   *   The second element is the next request object if the response\n   *   indicates the next page exists, or null. The third element is\n   *   an object representing [ListDocumentsResponse]{@link google.firestore.v1beta1.ListDocumentsResponse}.\n   *\n   *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * // Iterate over all elements.\n   * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]', '[DOCUMENT]', '[ANY_PATH]');\n   * const collectionId = '';\n   * const request = {\n   *   parent: formattedParent,\n   *   collectionId: collectionId,\n   * };\n   *\n   * client.listDocuments(request)\n   *   .then(responses => {\n   *     const resources = responses[0];\n   *     for (const resource of resources) {\n   *       // doThingsWith(resource)\n   *     }\n   *   })\n   *   .catch(err => {\n   *     console.error(err);\n   *   });\n   *\n   * // Or obtain the paged response.\n   * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]', '[DOCUMENT]', '[ANY_PATH]');\n   * const collectionId = '';\n   * const request = {\n   *   parent: formattedParent,\n   *   collectionId: collectionId,\n   * };\n   *\n   *\n   * const options = {autoPaginate: false};\n   * const callback = responses => {\n   *   // The actual resources in a response.\n   *   const resources = responses[0];\n   *   // The next request if the response shows that there are more responses.\n   *   const nextRequest = responses[1];\n   *   // The actual response object, if necessary.\n   *   // const rawResponse = responses[2];\n   *   for (const resource of resources) {\n   *     // doThingsWith(resource);\n   *   }\n   *   if (nextRequest) {\n   *     // Fetch the next page.\n   *     return client.listDocuments(nextRequest, options).then(callback);\n   *   }\n   * }\n   * client.listDocuments(request, options)\n   *   .then(callback)\n   *   .catch(err => {\n   *     console.error(err);\n   *   });\n   */\n\n\n  listDocuments(request, options, callback) {\n    if (options instanceof Function && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    return this._innerApiCalls.listDocuments(request, options, callback);\n  }\n  /**\n   * Equivalent to {@link listDocuments}, but returns a NodeJS Stream object.\n   *\n   * This fetches the paged responses for {@link listDocuments} continuously\n   * and invokes the callback registered for 'data' event for each element in the\n   * responses.\n   *\n   * The returned object has 'end' method when no more elements are required.\n   *\n   * autoPaginate option will be ignored.\n   *\n   * @see {@link https://nodejs.org/api/stream.html}\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.parent\n   *   The parent resource name. In the format:\n   *   `projects/{project_id}/databases/{database_id}/documents` or\n   *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n   *   For example:\n   *   `projects/my-project/databases/my-database/documents` or\n   *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n   * @param {string} request.collectionId\n   *   The collection ID, relative to `parent`, to list. For example: `chatrooms`\n   *   or `messages`.\n   * @param {number} [request.pageSize]\n   *   The maximum number of resources contained in the underlying API\n   *   response. If page streaming is performed per-resource, this\n   *   parameter does not affect the return value. If page streaming is\n   *   performed per-page, this determines the maximum number of\n   *   resources in a page.\n   * @param {string} [request.orderBy]\n   *   The order to sort results by. For example: `priority desc, name`.\n   * @param {Object} [request.mask]\n   *   The fields to return. If not set, returns all fields.\n   *\n   *   If a document has a field that is not present in this mask, that field\n   *   will not be returned in the response.\n   *\n   *   This object should have the same structure as [DocumentMask]{@link google.firestore.v1beta1.DocumentMask}\n   * @param {Buffer} [request.transaction]\n   *   Reads documents in a transaction.\n   * @param {Object} [request.readTime]\n   *   Reads documents as they were at the given time.\n   *   This may not be older than 60 seconds.\n   *\n   *   This object should have the same structure as [Timestamp]{@link google.protobuf.Timestamp}\n   * @param {boolean} [request.showMissing]\n   *   If the list should show missing documents. A missing document is a\n   *   document that does not exist but has sub-documents. These documents will\n   *   be returned with a key but will not have fields, Document.create_time,\n   *   or Document.update_time set.\n   *\n   *   Requests with `show_missing` may not specify `where` or\n   *   `order_by`.\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @returns {Stream}\n   *   An object stream which emits an object representing [Document]{@link google.firestore.v1beta1.Document} on 'data' event.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]', '[DOCUMENT]', '[ANY_PATH]');\n   * const collectionId = '';\n   * const request = {\n   *   parent: formattedParent,\n   *   collectionId: collectionId,\n   * };\n   * client.listDocumentsStream(request)\n   *   .on('data', element => {\n   *     // doThingsWith(element)\n   *   }).on('error', err => {\n   *     console.log(err);\n   *   });\n   */\n\n\n  listDocumentsStream(request, options) {\n    options = options || {};\n    return this._descriptors.page.listDocuments.createStream(this._innerApiCalls.listDocuments, request, options);\n  }\n  /**\n   * Creates a new document.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.parent\n   *   The parent resource. For example:\n   *   `projects/{project_id}/databases/{database_id}/documents` or\n   *   `projects/{project_id}/databases/{database_id}/documents/chatrooms/{chatroom_id}`\n   * @param {string} request.collectionId\n   *   The collection ID, relative to `parent`, to list. For example: `chatrooms`.\n   * @param {string} request.documentId\n   *   The client-assigned document ID to use for this document.\n   *\n   *   Optional. If not specified, an ID will be assigned by the service.\n   * @param {Object} request.document\n   *   The document to create. `name` must not be set.\n   *\n   *   This object should have the same structure as [Document]{@link google.firestore.v1beta1.Document}\n   * @param {Object} [request.mask]\n   *   The fields to return. If not set, returns all fields.\n   *\n   *   If the document has a field that is not present in this mask, that field\n   *   will not be returned in the response.\n   *\n   *   This object should have the same structure as [DocumentMask]{@link google.firestore.v1beta1.DocumentMask}\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @param {function(?Error, ?Object)} [callback]\n   *   The function which will be called with the result of the API call.\n   *\n   *   The second parameter to the callback is an object representing [Document]{@link google.firestore.v1beta1.Document}.\n   * @returns {Promise} - The promise which resolves to an array.\n   *   The first element of the array is an object representing [Document]{@link google.firestore.v1beta1.Document}.\n   *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]', '[DOCUMENT]', '[ANY_PATH]');\n   * const collectionId = '';\n   * const documentId = '';\n   * const document = {};\n   * const request = {\n   *   parent: formattedParent,\n   *   collectionId: collectionId,\n   *   documentId: documentId,\n   *   document: document,\n   * };\n   * client.createDocument(request)\n   *   .then(responses => {\n   *     const response = responses[0];\n   *     // doThingsWith(response)\n   *   })\n   *   .catch(err => {\n   *     console.error(err);\n   *   });\n   */\n\n\n  createDocument(request, options, callback) {\n    if (options instanceof Function && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    return this._innerApiCalls.createDocument(request, options, callback);\n  }\n  /**\n   * Updates or inserts a document.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {Object} request.document\n   *   The updated document.\n   *   Creates the document if it does not already exist.\n   *\n   *   This object should have the same structure as [Document]{@link google.firestore.v1beta1.Document}\n   * @param {Object} request.updateMask\n   *   The fields to update.\n   *   None of the field paths in the mask may contain a reserved name.\n   *\n   *   If the document exists on the server and has fields not referenced in the\n   *   mask, they are left unchanged.\n   *   Fields referenced in the mask, but not present in the input document, are\n   *   deleted from the document on the server.\n   *\n   *   This object should have the same structure as [DocumentMask]{@link google.firestore.v1beta1.DocumentMask}\n   * @param {Object} [request.mask]\n   *   The fields to return. If not set, returns all fields.\n   *\n   *   If the document has a field that is not present in this mask, that field\n   *   will not be returned in the response.\n   *\n   *   This object should have the same structure as [DocumentMask]{@link google.firestore.v1beta1.DocumentMask}\n   * @param {Object} [request.currentDocument]\n   *   An optional precondition on the document.\n   *   The request will fail if this is set and not met by the target document.\n   *\n   *   This object should have the same structure as [Precondition]{@link google.firestore.v1beta1.Precondition}\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @param {function(?Error, ?Object)} [callback]\n   *   The function which will be called with the result of the API call.\n   *\n   *   The second parameter to the callback is an object representing [Document]{@link google.firestore.v1beta1.Document}.\n   * @returns {Promise} - The promise which resolves to an array.\n   *   The first element of the array is an object representing [Document]{@link google.firestore.v1beta1.Document}.\n   *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const document = {};\n   * const updateMask = {};\n   * const request = {\n   *   document: document,\n   *   updateMask: updateMask,\n   * };\n   * client.updateDocument(request)\n   *   .then(responses => {\n   *     const response = responses[0];\n   *     // doThingsWith(response)\n   *   })\n   *   .catch(err => {\n   *     console.error(err);\n   *   });\n   */\n\n\n  updateDocument(request, options, callback) {\n    if (options instanceof Function && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    options.otherArgs = options.otherArgs || {};\n    options.otherArgs.headers = options.otherArgs.headers || {};\n    options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n      'document.name': request.document.name\n    });\n    return this._innerApiCalls.updateDocument(request, options, callback);\n  }\n  /**\n   * Deletes a document.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.name\n   *   The resource name of the Document to delete. In the format:\n   *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n   * @param {Object} [request.currentDocument]\n   *   An optional precondition on the document.\n   *   The request will fail if this is set and not met by the target document.\n   *\n   *   This object should have the same structure as [Precondition]{@link google.firestore.v1beta1.Precondition}\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @param {function(?Error)} [callback]\n   *   The function which will be called with the result of the API call.\n   * @returns {Promise} - The promise which resolves when API call finishes.\n   *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const formattedName = client.anyPathPath('[PROJECT]', '[DATABASE]', '[DOCUMENT]', '[ANY_PATH]');\n   * client.deleteDocument({name: formattedName}).catch(err => {\n   *   console.error(err);\n   * });\n   */\n\n\n  deleteDocument(request, options, callback) {\n    if (options instanceof Function && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    options.otherArgs = options.otherArgs || {};\n    options.otherArgs.headers = options.otherArgs.headers || {};\n    options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n      name: request.name\n    });\n    return this._innerApiCalls.deleteDocument(request, options, callback);\n  }\n  /**\n   * Gets multiple documents.\n   *\n   * Documents returned by this method are not guaranteed to be returned in the\n   * same order that they were requested.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.database\n   *   The database name. In the format:\n   *   `projects/{project_id}/databases/{database_id}`.\n   * @param {string[]} request.documents\n   *   The names of the documents to retrieve. In the format:\n   *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n   *   The request will fail if any of the document is not a child resource of the\n   *   given `database`. Duplicate names will be elided.\n   * @param {Object} [request.mask]\n   *   The fields to return. If not set, returns all fields.\n   *\n   *   If a document has a field that is not present in this mask, that field will\n   *   not be returned in the response.\n   *\n   *   This object should have the same structure as [DocumentMask]{@link google.firestore.v1beta1.DocumentMask}\n   * @param {Buffer} [request.transaction]\n   *   Reads documents in a transaction.\n   * @param {Object} [request.newTransaction]\n   *   Starts a new transaction and reads the documents.\n   *   Defaults to a read-only transaction.\n   *   The new transaction ID will be returned as the first response in the\n   *   stream.\n   *\n   *   This object should have the same structure as [TransactionOptions]{@link google.firestore.v1beta1.TransactionOptions}\n   * @param {Object} [request.readTime]\n   *   Reads documents as they were at the given time.\n   *   This may not be older than 60 seconds.\n   *\n   *   This object should have the same structure as [Timestamp]{@link google.protobuf.Timestamp}\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @returns {Stream}\n   *   An object stream which emits [BatchGetDocumentsResponse]{@link google.firestore.v1beta1.BatchGetDocumentsResponse} on 'data' event.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const formattedDatabase = client.databaseRootPath('[PROJECT]', '[DATABASE]');\n   * const documents = [];\n   * const request = {\n   *   database: formattedDatabase,\n   *   documents: documents,\n   * };\n   * client.batchGetDocuments(request).on('data', response => {\n   *   // doThingsWith(response)\n   * });\n   */\n\n\n  batchGetDocuments(request, options) {\n    options = options || {};\n    options.otherArgs = options.otherArgs || {};\n    options.otherArgs.headers = options.otherArgs.headers || {};\n    options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n      database: request.database\n    });\n    return this._innerApiCalls.batchGetDocuments(request, options);\n  }\n  /**\n   * Starts a new transaction.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.database\n   *   The database name. In the format:\n   *   `projects/{project_id}/databases/{database_id}`.\n   * @param {Object} [request.options]\n   *   The options for the transaction.\n   *   Defaults to a read-write transaction.\n   *\n   *   This object should have the same structure as [TransactionOptions]{@link google.firestore.v1beta1.TransactionOptions}\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @param {function(?Error, ?Object)} [callback]\n   *   The function which will be called with the result of the API call.\n   *\n   *   The second parameter to the callback is an object representing [BeginTransactionResponse]{@link google.firestore.v1beta1.BeginTransactionResponse}.\n   * @returns {Promise} - The promise which resolves to an array.\n   *   The first element of the array is an object representing [BeginTransactionResponse]{@link google.firestore.v1beta1.BeginTransactionResponse}.\n   *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const formattedDatabase = client.databaseRootPath('[PROJECT]', '[DATABASE]');\n   * client.beginTransaction({database: formattedDatabase})\n   *   .then(responses => {\n   *     const response = responses[0];\n   *     // doThingsWith(response)\n   *   })\n   *   .catch(err => {\n   *     console.error(err);\n   *   });\n   */\n\n\n  beginTransaction(request, options, callback) {\n    if (options instanceof Function && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    options.otherArgs = options.otherArgs || {};\n    options.otherArgs.headers = options.otherArgs.headers || {};\n    options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n      database: request.database\n    });\n    return this._innerApiCalls.beginTransaction(request, options, callback);\n  }\n  /**\n   * Commits a transaction, while optionally updating documents.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.database\n   *   The database name. In the format:\n   *   `projects/{project_id}/databases/{database_id}`.\n   * @param {Object[]} request.writes\n   *   The writes to apply.\n   *\n   *   Always executed atomically and in order.\n   *\n   *   This object should have the same structure as [Write]{@link google.firestore.v1beta1.Write}\n   * @param {Buffer} [request.transaction]\n   *   If set, applies all writes in this transaction, and commits it.\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @param {function(?Error, ?Object)} [callback]\n   *   The function which will be called with the result of the API call.\n   *\n   *   The second parameter to the callback is an object representing [CommitResponse]{@link google.firestore.v1beta1.CommitResponse}.\n   * @returns {Promise} - The promise which resolves to an array.\n   *   The first element of the array is an object representing [CommitResponse]{@link google.firestore.v1beta1.CommitResponse}.\n   *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const formattedDatabase = client.databaseRootPath('[PROJECT]', '[DATABASE]');\n   * const writes = [];\n   * const request = {\n   *   database: formattedDatabase,\n   *   writes: writes,\n   * };\n   * client.commit(request)\n   *   .then(responses => {\n   *     const response = responses[0];\n   *     // doThingsWith(response)\n   *   })\n   *   .catch(err => {\n   *     console.error(err);\n   *   });\n   */\n\n\n  commit(request, options, callback) {\n    if (options instanceof Function && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    options.otherArgs = options.otherArgs || {};\n    options.otherArgs.headers = options.otherArgs.headers || {};\n    options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n      database: request.database\n    });\n    return this._innerApiCalls.commit(request, options, callback);\n  }\n  /**\n   * Rolls back a transaction.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.database\n   *   The database name. In the format:\n   *   `projects/{project_id}/databases/{database_id}`.\n   * @param {Buffer} request.transaction\n   *   The transaction to roll back.\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @param {function(?Error)} [callback]\n   *   The function which will be called with the result of the API call.\n   * @returns {Promise} - The promise which resolves when API call finishes.\n   *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const formattedDatabase = client.databaseRootPath('[PROJECT]', '[DATABASE]');\n   * const transaction = Buffer.from('');\n   * const request = {\n   *   database: formattedDatabase,\n   *   transaction: transaction,\n   * };\n   * client.rollback(request).catch(err => {\n   *   console.error(err);\n   * });\n   */\n\n\n  rollback(request, options, callback) {\n    if (options instanceof Function && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    options.otherArgs = options.otherArgs || {};\n    options.otherArgs.headers = options.otherArgs.headers || {};\n    options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n      database: request.database\n    });\n    return this._innerApiCalls.rollback(request, options, callback);\n  }\n  /**\n   * Runs a query.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.parent\n   *   The parent resource name. In the format:\n   *   `projects/{project_id}/databases/{database_id}/documents` or\n   *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n   *   For example:\n   *   `projects/my-project/databases/my-database/documents` or\n   *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n   * @param {Object} [request.structuredQuery]\n   *   A structured query.\n   *\n   *   This object should have the same structure as [StructuredQuery]{@link google.firestore.v1beta1.StructuredQuery}\n   * @param {Buffer} [request.transaction]\n   *   Reads documents in a transaction.\n   * @param {Object} [request.newTransaction]\n   *   Starts a new transaction and reads the documents.\n   *   Defaults to a read-only transaction.\n   *   The new transaction ID will be returned as the first response in the\n   *   stream.\n   *\n   *   This object should have the same structure as [TransactionOptions]{@link google.firestore.v1beta1.TransactionOptions}\n   * @param {Object} [request.readTime]\n   *   Reads documents as they were at the given time.\n   *   This may not be older than 60 seconds.\n   *\n   *   This object should have the same structure as [Timestamp]{@link google.protobuf.Timestamp}\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @returns {Stream}\n   *   An object stream which emits [RunQueryResponse]{@link google.firestore.v1beta1.RunQueryResponse} on 'data' event.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]', '[DOCUMENT]', '[ANY_PATH]');\n   * client.runQuery({parent: formattedParent}).on('data', response => {\n   *   // doThingsWith(response)\n   * });\n   */\n\n\n  runQuery(request, options) {\n    options = options || {};\n    options.otherArgs = options.otherArgs || {};\n    options.otherArgs.headers = options.otherArgs.headers || {};\n    options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n      parent: request.parent\n    });\n    return this._innerApiCalls.runQuery(request, options);\n  }\n  /**\n   * Streams batches of document updates and deletes, in order.\n   *\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @returns {Stream}\n   *   An object stream which is both readable and writable. It accepts objects\n   *   representing [WriteRequest]{@link google.firestore.v1beta1.WriteRequest} for write() method, and\n   *   will emit objects representing [WriteResponse]{@link google.firestore.v1beta1.WriteResponse} on 'data' event asynchronously.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const stream = client.write().on('data', response => {\n   *   // doThingsWith(response)\n   * });\n   * const formattedDatabase = client.databaseRootPath('[PROJECT]', '[DATABASE]');\n   * const request = {\n   *   database: formattedDatabase,\n   * };\n   * // Write request objects.\n   * stream.write(request);\n   */\n\n\n  write(options) {\n    options = options || {};\n    return this._innerApiCalls.write(options);\n  }\n  /**\n   * Listens to changes.\n   *\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @returns {Stream}\n   *   An object stream which is both readable and writable. It accepts objects\n   *   representing [ListenRequest]{@link google.firestore.v1beta1.ListenRequest} for write() method, and\n   *   will emit objects representing [ListenResponse]{@link google.firestore.v1beta1.ListenResponse} on 'data' event asynchronously.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const stream = client.listen().on('data', response => {\n   *   // doThingsWith(response)\n   * });\n   * const formattedDatabase = client.databaseRootPath('[PROJECT]', '[DATABASE]');\n   * const request = {\n   *   database: formattedDatabase,\n   * };\n   * // Write request objects.\n   * stream.write(request);\n   */\n\n\n  listen(options) {\n    options = options || {};\n    return this._innerApiCalls.listen({}, options);\n  }\n  /**\n   * Lists all the collection IDs underneath a document.\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.parent\n   *   The parent document. In the format:\n   *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n   *   For example:\n   *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n   * @param {number} [request.pageSize]\n   *   The maximum number of resources contained in the underlying API\n   *   response. If page streaming is performed per-resource, this\n   *   parameter does not affect the return value. If page streaming is\n   *   performed per-page, this determines the maximum number of\n   *   resources in a page.\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @param {function(?Error, ?Array, ?Object, ?Object)} [callback]\n   *   The function which will be called with the result of the API call.\n   *\n   *   The second parameter to the callback is Array of string.\n   *\n   *   When autoPaginate: false is specified through options, it contains the result\n   *   in a single response. If the response indicates the next page exists, the third\n   *   parameter is set to be used for the next request object. The fourth parameter keeps\n   *   the raw response object of an object representing [ListCollectionIdsResponse]{@link google.firestore.v1beta1.ListCollectionIdsResponse}.\n   * @returns {Promise} - The promise which resolves to an array.\n   *   The first element of the array is Array of string.\n   *\n   *   When autoPaginate: false is specified through options, the array has three elements.\n   *   The first element is Array of string in a single response.\n   *   The second element is the next request object if the response\n   *   indicates the next page exists, or null. The third element is\n   *   an object representing [ListCollectionIdsResponse]{@link google.firestore.v1beta1.ListCollectionIdsResponse}.\n   *\n   *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * // Iterate over all elements.\n   * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]', '[DOCUMENT]', '[ANY_PATH]');\n   *\n   * client.listCollectionIds({parent: formattedParent})\n   *   .then(responses => {\n   *     const resources = responses[0];\n   *     for (const resource of resources) {\n   *       // doThingsWith(resource)\n   *     }\n   *   })\n   *   .catch(err => {\n   *     console.error(err);\n   *   });\n   *\n   * // Or obtain the paged response.\n   * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]', '[DOCUMENT]', '[ANY_PATH]');\n   *\n   *\n   * const options = {autoPaginate: false};\n   * const callback = responses => {\n   *   // The actual resources in a response.\n   *   const resources = responses[0];\n   *   // The next request if the response shows that there are more responses.\n   *   const nextRequest = responses[1];\n   *   // The actual response object, if necessary.\n   *   // const rawResponse = responses[2];\n   *   for (const resource of resources) {\n   *     // doThingsWith(resource);\n   *   }\n   *   if (nextRequest) {\n   *     // Fetch the next page.\n   *     return client.listCollectionIds(nextRequest, options).then(callback);\n   *   }\n   * }\n   * client.listCollectionIds({parent: formattedParent}, options)\n   *   .then(callback)\n   *   .catch(err => {\n   *     console.error(err);\n   *   });\n   */\n\n\n  listCollectionIds(request, options, callback) {\n    if (options instanceof Function && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    options.otherArgs = options.otherArgs || {};\n    options.otherArgs.headers = options.otherArgs.headers || {};\n    options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n      parent: request.parent\n    });\n    return this._innerApiCalls.listCollectionIds(request, options, callback);\n  }\n  /**\n   * Equivalent to {@link listCollectionIds}, but returns a NodeJS Stream object.\n   *\n   * This fetches the paged responses for {@link listCollectionIds} continuously\n   * and invokes the callback registered for 'data' event for each element in the\n   * responses.\n   *\n   * The returned object has 'end' method when no more elements are required.\n   *\n   * autoPaginate option will be ignored.\n   *\n   * @see {@link https://nodejs.org/api/stream.html}\n   *\n   * @param {Object} request\n   *   The request object that will be sent.\n   * @param {string} request.parent\n   *   The parent document. In the format:\n   *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n   *   For example:\n   *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n   * @param {number} [request.pageSize]\n   *   The maximum number of resources contained in the underlying API\n   *   response. If page streaming is performed per-resource, this\n   *   parameter does not affect the return value. If page streaming is\n   *   performed per-page, this determines the maximum number of\n   *   resources in a page.\n   * @param {Object} [options]\n   *   Optional parameters. You can override the default settings for this call, e.g, timeout,\n   *   retries, paginations, etc. See [gax.CallOptions]{@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html} for the details.\n   * @returns {Stream}\n   *   An object stream which emits a string on 'data' event.\n   *\n   * @example\n   *\n   * const firestore = require('@google-cloud/firestore');\n   *\n   * const client = new firestore.v1beta1.FirestoreClient({\n   *   // optional auth parameters.\n   * });\n   *\n   * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]', '[DOCUMENT]', '[ANY_PATH]');\n   * client.listCollectionIdsStream({parent: formattedParent})\n   *   .on('data', element => {\n   *     // doThingsWith(element)\n   *   }).on('error', err => {\n   *     console.log(err);\n   *   });\n   */\n\n\n  listCollectionIdsStream(request, options) {\n    options = options || {};\n    return this._descriptors.page.listCollectionIds.createStream(this._innerApiCalls.listCollectionIds, request, options);\n  } // --------------------\n  // -- Path templates --\n  // --------------------\n\n  /**\n   * Return a fully-qualified any_path resource name string.\n   *\n   * @param {String} project\n   * @param {String} database\n   * @param {String} document\n   * @param {String} anyPath\n   * @returns {String}\n   */\n\n\n  anyPathPath(project, database, document, anyPath) {\n    return this._pathTemplates.anyPathPathTemplate.render({\n      project: project,\n      database: database,\n      document: document,\n      any_path: anyPath\n    });\n  }\n  /**\n   * Return a fully-qualified database_root resource name string.\n   *\n   * @param {String} project\n   * @param {String} database\n   * @returns {String}\n   */\n\n\n  databaseRootPath(project, database) {\n    return this._pathTemplates.databaseRootPathTemplate.render({\n      project: project,\n      database: database\n    });\n  }\n  /**\n   * Return a fully-qualified document_path resource name string.\n   *\n   * @param {String} project\n   * @param {String} database\n   * @param {String} documentPath\n   * @returns {String}\n   */\n\n\n  documentPathPath(project, database, documentPath) {\n    return this._pathTemplates.documentPathPathTemplate.render({\n      project: project,\n      database: database,\n      document_path: documentPath\n    });\n  }\n  /**\n   * Return a fully-qualified document_root resource name string.\n   *\n   * @param {String} project\n   * @param {String} database\n   * @returns {String}\n   */\n\n\n  documentRootPath(project, database) {\n    return this._pathTemplates.documentRootPathTemplate.render({\n      project: project,\n      database: database\n    });\n  }\n  /**\n   * Parse the anyPathName from a any_path resource.\n   *\n   * @param {String} anyPathName\n   *   A fully-qualified path representing a any_path resources.\n   * @returns {String} - A string representing the project.\n   */\n\n\n  matchProjectFromAnyPathName(anyPathName) {\n    return this._pathTemplates.anyPathPathTemplate.match(anyPathName).project;\n  }\n  /**\n   * Parse the anyPathName from a any_path resource.\n   *\n   * @param {String} anyPathName\n   *   A fully-qualified path representing a any_path resources.\n   * @returns {String} - A string representing the database.\n   */\n\n\n  matchDatabaseFromAnyPathName(anyPathName) {\n    return this._pathTemplates.anyPathPathTemplate.match(anyPathName).database;\n  }\n  /**\n   * Parse the anyPathName from a any_path resource.\n   *\n   * @param {String} anyPathName\n   *   A fully-qualified path representing a any_path resources.\n   * @returns {String} - A string representing the document.\n   */\n\n\n  matchDocumentFromAnyPathName(anyPathName) {\n    return this._pathTemplates.anyPathPathTemplate.match(anyPathName).document;\n  }\n  /**\n   * Parse the anyPathName from a any_path resource.\n   *\n   * @param {String} anyPathName\n   *   A fully-qualified path representing a any_path resources.\n   * @returns {String} - A string representing the any_path.\n   */\n\n\n  matchAnyPathFromAnyPathName(anyPathName) {\n    return this._pathTemplates.anyPathPathTemplate.match(anyPathName).any_path;\n  }\n  /**\n   * Parse the databaseRootName from a database_root resource.\n   *\n   * @param {String} databaseRootName\n   *   A fully-qualified path representing a database_root resources.\n   * @returns {String} - A string representing the project.\n   */\n\n\n  matchProjectFromDatabaseRootName(databaseRootName) {\n    return this._pathTemplates.databaseRootPathTemplate.match(databaseRootName).project;\n  }\n  /**\n   * Parse the databaseRootName from a database_root resource.\n   *\n   * @param {String} databaseRootName\n   *   A fully-qualified path representing a database_root resources.\n   * @returns {String} - A string representing the database.\n   */\n\n\n  matchDatabaseFromDatabaseRootName(databaseRootName) {\n    return this._pathTemplates.databaseRootPathTemplate.match(databaseRootName).database;\n  }\n  /**\n   * Parse the documentPathName from a document_path resource.\n   *\n   * @param {String} documentPathName\n   *   A fully-qualified path representing a document_path resources.\n   * @returns {String} - A string representing the project.\n   */\n\n\n  matchProjectFromDocumentPathName(documentPathName) {\n    return this._pathTemplates.documentPathPathTemplate.match(documentPathName).project;\n  }\n  /**\n   * Parse the documentPathName from a document_path resource.\n   *\n   * @param {String} documentPathName\n   *   A fully-qualified path representing a document_path resources.\n   * @returns {String} - A string representing the database.\n   */\n\n\n  matchDatabaseFromDocumentPathName(documentPathName) {\n    return this._pathTemplates.documentPathPathTemplate.match(documentPathName).database;\n  }\n  /**\n   * Parse the documentPathName from a document_path resource.\n   *\n   * @param {String} documentPathName\n   *   A fully-qualified path representing a document_path resources.\n   * @returns {String} - A string representing the document_path.\n   */\n\n\n  matchDocumentPathFromDocumentPathName(documentPathName) {\n    return this._pathTemplates.documentPathPathTemplate.match(documentPathName).document_path;\n  }\n  /**\n   * Parse the documentRootName from a document_root resource.\n   *\n   * @param {String} documentRootName\n   *   A fully-qualified path representing a document_root resources.\n   * @returns {String} - A string representing the project.\n   */\n\n\n  matchProjectFromDocumentRootName(documentRootName) {\n    return this._pathTemplates.documentRootPathTemplate.match(documentRootName).project;\n  }\n  /**\n   * Parse the documentRootName from a document_root resource.\n   *\n   * @param {String} documentRootName\n   *   A fully-qualified path representing a document_root resources.\n   * @returns {String} - A string representing the database.\n   */\n\n\n  matchDatabaseFromDocumentRootName(documentRootName) {\n    return this._pathTemplates.documentRootPathTemplate.match(documentRootName).database;\n  }\n\n}\n\nmodule.exports = FirestoreClient;","map":null,"metadata":{},"sourceType":"script"}