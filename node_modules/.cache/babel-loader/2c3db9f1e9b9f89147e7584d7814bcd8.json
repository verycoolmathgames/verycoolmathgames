{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst http2 = require(\"http2\");\n\nconst stream_1 = require(\"stream\");\n\nconst call_credentials_1 = require(\"./call-credentials\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst stream_decoder_1 = require(\"./stream-decoder\");\n\nconst _http2$constants = http2.constants,\n      HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS,\n      HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,\n      NGHTTP2_CANCEL = _http2$constants.NGHTTP2_CANCEL;\n\nclass Http2CallStream extends stream_1.Duplex {\n  constructor(methodName, channel, options, filterStackFactory) {\n    super({\n      objectMode: true\n    });\n    this.methodName = methodName;\n    this.channel = channel;\n    this.options = options;\n    this.credentials = call_credentials_1.CallCredentials.createEmpty();\n    this.http2Stream = null;\n    this.pendingRead = false;\n    this.pendingWrite = null;\n    this.pendingWriteCallback = null;\n    this.pendingFinalCallback = null;\n    this.decoder = new stream_decoder_1.StreamDecoder();\n    this.isReadFilterPending = false;\n    this.canPush = false;\n    this.unpushedReadMessages = [];\n    this.unfilteredReadMessages = []; // Status code mapped from :status. To be used if grpc-status is not received\n\n    this.mappedStatusCode = constants_1.Status.UNKNOWN; // Promise objects that are re-assigned to resolving promises when headers\n    // or trailers received. Processing headers/trailers is asynchronous, so we\n    // can use these objects to await their completion. This helps us establish\n    // order of precedence when obtaining the status of the call.\n\n    this.handlingHeaders = Promise.resolve();\n    this.handlingTrailers = Promise.resolve(); // This is populated (non-null) if and only if the call has ended\n\n    this.finalStatus = null;\n    this.filterStack = filterStackFactory.createFilter(this);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n\n\n  endCall(status) {\n    if (this.finalStatus === null) {\n      this.finalStatus = status;\n      /* We do this asynchronously to ensure that no async function is in the\n       * call stack when we return control to the application. If an async\n       * function is in the call stack, any exception thrown by the application\n       * (or our tests) will bubble up and turn into promise rejection, which\n       * will result in an UnhandledPromiseRejectionWarning. Because that is\n       * a warning, the error will be effectively swallowed and execution will\n       * continue */\n\n      process.nextTick(() => {\n        this.emit('status', status);\n      });\n    }\n  }\n\n  handleFilterError(error) {\n    this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n  }\n\n  handleFilteredRead(message) {\n    /* If we the call has already ended, we don't want to do anything with\n     * this message. Dropping it on the floor is correct behavior */\n    if (this.finalStatus !== null) {\n      return;\n    }\n\n    this.isReadFilterPending = false;\n\n    if (this.canPush) {\n      if (!this.push(message)) {\n        this.canPush = false;\n        this.http2Stream.pause();\n      }\n    } else {\n      this.unpushedReadMessages.push(message);\n    }\n\n    if (this.unfilteredReadMessages.length > 0) {\n      /* nextMessage is guaranteed not to be undefined because\n         unfilteredReadMessages is non-empty */\n      const nextMessage = this.unfilteredReadMessages.shift();\n      this.filterReceivedMessage(nextMessage);\n    }\n  }\n\n  filterReceivedMessage(framedMessage) {\n    /* If we the call has already ended, we don't want to do anything with\n     * this message. Dropping it on the floor is correct behavior */\n    if (this.finalStatus !== null) {\n      return;\n    }\n\n    if (framedMessage === null) {\n      if (this.canPush) {\n        this.push(null);\n      } else {\n        this.unpushedReadMessages.push(null);\n      }\n\n      return;\n    }\n\n    this.isReadFilterPending = true;\n    this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n  }\n\n  tryPush(messageBytes) {\n    if (this.isReadFilterPending) {\n      this.unfilteredReadMessages.push(messageBytes);\n    } else {\n      this.filterReceivedMessage(messageBytes);\n    }\n  }\n\n  handleTrailers(headers) {\n    const code = this.mappedStatusCode;\n    const details = '';\n    let metadata;\n\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n\n    const status = {\n      code,\n      details,\n      metadata\n    };\n\n    this.handlingTrailers = (async () => {\n      let finalStatus;\n\n      try {\n        // Attempt to assign final status.\n        finalStatus = await this.filterStack.receiveTrailers(Promise.resolve(status));\n      } catch (error) {\n        await this.handlingHeaders; // This is a no-op if the call was already ended when handling headers.\n\n        this.endCall({\n          code: constants_1.Status.INTERNAL,\n          details: 'Failed to process received status',\n          metadata: new metadata_1.Metadata()\n        });\n        return;\n      } // It's possible that headers were received but not fully handled yet.\n      // Give the headers handler an opportunity to end the call first,\n      // if an error occurred.\n\n\n      await this.handlingHeaders; // This is a no-op if the call was already ended when handling headers.\n\n      this.endCall(finalStatus);\n    })();\n  }\n\n  attachHttp2Stream(stream) {\n    if (this.finalStatus !== null) {\n      stream.close(NGHTTP2_CANCEL);\n    } else {\n      this.http2Stream = stream;\n      stream.on('response', (headers, flags) => {\n        switch (headers[HTTP2_HEADER_STATUS]) {\n          // TODO(murgatroid99): handle 100 and 101\n          case '400':\n            this.mappedStatusCode = constants_1.Status.INTERNAL;\n            break;\n\n          case '401':\n            this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n            break;\n\n          case '403':\n            this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n            break;\n\n          case '404':\n            this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n            break;\n\n          case '429':\n          case '502':\n          case '503':\n          case '504':\n            this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n            break;\n\n          default:\n            this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        }\n\n        if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n          this.handleTrailers(headers);\n        } else {\n          let metadata;\n\n          try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n          } catch (error) {\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n            return;\n          }\n\n          this.handlingHeaders = this.filterStack.receiveMetadata(Promise.resolve(metadata)).then(finalMetadata => {\n            this.emit('metadata', finalMetadata);\n          }).catch(error => {\n            this.destroyHttp2Stream();\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n          });\n        }\n      });\n      stream.on('trailers', this.handleTrailers.bind(this));\n      stream.on('data', data => {\n        const messages = this.decoder.write(data);\n\n        for (const message of messages) {\n          this.tryPush(message);\n        }\n      });\n      stream.on('end', () => {\n        this.tryPush(null);\n      });\n      stream.on('close', async () => {\n        let code;\n        let details = '';\n\n        switch (stream.rstCode) {\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = constants_1.Status.UNAVAILABLE;\n            break;\n\n          case http2.constants.NGHTTP2_CANCEL:\n            code = constants_1.Status.CANCELLED;\n            break;\n\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = constants_1.Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted';\n            break;\n\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = constants_1.Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n\n          default:\n            code = constants_1.Status.INTERNAL;\n        } // This guarantees that if trailers were received, the value of the\n        // 'grpc-status' header takes precedence for emitted status data.\n\n\n        await this.handlingTrailers; // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n\n        this.endCall({\n          code,\n          details,\n          metadata: new metadata_1.Metadata()\n        });\n      });\n      stream.on('error', err => {\n        /* We need an error handler here to stop \"Uncaught Error\" exceptions\n         * from bubbling up. However, errors here should all correspond to\n         * \"close\" events, where we will handle the error more granularly */\n      });\n\n      if (!this.pendingRead) {\n        stream.pause();\n      }\n\n      if (this.pendingWrite) {\n        if (!this.pendingWriteCallback) {\n          throw new Error('Invalid state in write handling code');\n        }\n\n        stream.write(this.pendingWrite, this.pendingWriteCallback);\n      }\n\n      if (this.pendingFinalCallback) {\n        stream.end(this.pendingFinalCallback);\n      }\n    }\n  }\n\n  sendMetadata(metadata) {\n    this.channel._startHttp2Stream(this.options.host, this.methodName, this, metadata);\n  }\n\n  destroyHttp2Stream() {\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n      /* TODO(murgatroid99): Determine if we want to send different RST_STREAM\n       * codes based on the status code */\n      this.http2Stream.close(NGHTTP2_CANCEL);\n    }\n  }\n\n  cancelWithStatus(status, details) {\n    this.destroyHttp2Stream();\n\n    (async () => {\n      // If trailers are currently being processed, the call should be ended\n      // by handleTrailers instead.\n      await this.handlingTrailers;\n      this.endCall({\n        code: status,\n        details,\n        metadata: new metadata_1.Metadata()\n      });\n    })();\n  }\n\n  getDeadline() {\n    return this.options.deadline;\n  }\n\n  getCredentials() {\n    return this.credentials;\n  }\n\n  setCredentials(credentials) {\n    this.credentials = credentials;\n  }\n\n  getStatus() {\n    return this.finalStatus;\n  }\n\n  getPeer() {\n    throw new Error('Not yet implemented');\n  }\n\n  getMethod() {\n    return this.methodName;\n  }\n\n  getHost() {\n    return this.options.host;\n  }\n\n  _read(size) {\n    /* If we have already emitted a status, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null) {\n      this.push(null);\n      return;\n    }\n\n    this.canPush = true;\n\n    if (this.http2Stream === null) {\n      this.pendingRead = true;\n    } else {\n      while (this.unpushedReadMessages.length > 0) {\n        const nextMessage = this.unpushedReadMessages.shift();\n        this.canPush = this.push(nextMessage);\n\n        if (nextMessage === null || !this.canPush) {\n          this.canPush = false;\n          return;\n        }\n      }\n      /* Only resume reading from the http2Stream if we don't have any pending\n       * messages to emit, and we haven't gotten the signal to stop pushing\n       * messages */\n\n\n      this.http2Stream.resume();\n    }\n  }\n\n  _write(chunk, encoding, cb) {\n    this.filterStack.sendMessage(Promise.resolve(chunk)).then(message => {\n      if (this.http2Stream === null) {\n        this.pendingWrite = message.message;\n        this.pendingWriteCallback = cb;\n      } else {\n        this.http2Stream.write(message.message, cb);\n      }\n    }, this.handleFilterError.bind(this));\n  }\n\n  _final(cb) {\n    if (this.http2Stream === null) {\n      this.pendingFinalCallback = cb;\n    } else {\n      this.http2Stream.end(cb);\n    }\n  }\n\n}\n\nexports.Http2CallStream = Http2CallStream;","map":null,"metadata":{},"sourceType":"script"}