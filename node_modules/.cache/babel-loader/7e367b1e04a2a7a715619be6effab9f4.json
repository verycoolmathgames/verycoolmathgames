{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(require(\"@firebase/app\")) : \"function\" == typeof define && define.amd ? define([\"@firebase/app\"], e) : e((t = t || self).firebase);\n}(this, function (Dh) {\n  \"use strict\";\n\n  try {\n    (function () {\n      var o, t;\n      Dh = Dh && Dh.hasOwnProperty(\"default\") ? Dh.default : Dh, (t = o || (o = {}))[t.DEBUG = 0] = \"DEBUG\", t[t.VERBOSE = 1] = \"VERBOSE\", t[t.INFO = 2] = \"INFO\", t[t.WARN = 3] = \"WARN\", t[t.ERROR = 4] = \"ERROR\", t[t.SILENT = 5] = \"SILENT\";\n\n      var e = o.INFO,\n          n = function (t, e) {\n        for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];\n\n        if (!(e < t.logLevel)) {\n          var i = new Date().toISOString();\n\n          switch (e) {\n            case o.DEBUG:\n            case o.VERBOSE:\n              console.log.apply(console, [\"[\" + i + \"]  \" + t.name + \":\"].concat(n));\n              break;\n\n            case o.INFO:\n              console.info.apply(console, [\"[\" + i + \"]  \" + t.name + \":\"].concat(n));\n              break;\n\n            case o.WARN:\n              console.warn.apply(console, [\"[\" + i + \"]  \" + t.name + \":\"].concat(n));\n              break;\n\n            case o.ERROR:\n              console.error.apply(console, [\"[\" + i + \"]  \" + t.name + \":\"].concat(n));\n              break;\n\n            default:\n              throw new Error(\"Attempted to log a message with an invalid logType (value: \" + e + \")\");\n          }\n        }\n      },\n          r = function () {\n        function t(t) {\n          this.name = t, this._logLevel = e, this._logHandler = n;\n        }\n\n        return Object.defineProperty(t.prototype, \"logLevel\", {\n          get: function () {\n            return this._logLevel;\n          },\n          set: function (t) {\n            if (!(t in o)) throw new TypeError(\"Invalid value assigned to `logLevel`\");\n            this._logLevel = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"logHandler\", {\n          get: function () {\n            return this._logHandler;\n          },\n          set: function (t) {\n            if (\"function\" != typeof t) throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n            this._logHandler = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.debug = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          this._logHandler.apply(this, [this, o.DEBUG].concat(t));\n        }, t.prototype.log = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          this._logHandler.apply(this, [this, o.VERBOSE].concat(t));\n        }, t.prototype.info = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          this._logHandler.apply(this, [this, o.INFO].concat(t));\n        }, t.prototype.warn = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          this._logHandler.apply(this, [this, o.WARN].concat(t));\n        }, t.prototype.error = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          this._logHandler.apply(this, [this, o.ERROR].concat(t));\n        }, t;\n      }(),\n          i = function (t, e) {\n        return (i = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (t, e) {\n          t.__proto__ = e;\n        } || function (t, e) {\n          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);\n        })(t, e);\n      };\n\n      function s(t, e) {\n        function n() {\n          this.constructor = t;\n        }\n\n        i(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n());\n      }\n\n      function h(o, a, s, u) {\n        return new (s || (s = Promise))(function (t, e) {\n          function n(t) {\n            try {\n              i(u.next(t));\n            } catch (t) {\n              e(t);\n            }\n          }\n\n          function r(t) {\n            try {\n              i(u.throw(t));\n            } catch (t) {\n              e(t);\n            }\n          }\n\n          function i(e) {\n            e.done ? t(e.value) : new s(function (t) {\n              t(e.value);\n            }).then(n, r);\n          }\n\n          i((u = u.apply(o, a || [])).next());\n        });\n      }\n\n      function p(n, r) {\n        var i,\n            o,\n            a,\n            t,\n            s = {\n          label: 0,\n          sent: function () {\n            if (1 & a[0]) throw a[1];\n            return a[1];\n          },\n          trys: [],\n          ops: []\n        };\n        return t = {\n          next: e(0),\n          throw: e(1),\n          return: e(2)\n        }, \"function\" == typeof Symbol && (t[Symbol.iterator] = function () {\n          return this;\n        }), t;\n\n        function e(e) {\n          return function (t) {\n            return function (e) {\n              if (i) throw new TypeError(\"Generator is already executing.\");\n\n              for (; s;) try {\n                if (i = 1, o && (a = 2 & e[0] ? o.return : e[0] ? o.throw || ((a = o.return) && a.call(o), 0) : o.next) && !(a = a.call(o, e[1])).done) return a;\n\n                switch (o = 0, a && (e = [2 & e[0], a.value]), e[0]) {\n                  case 0:\n                  case 1:\n                    a = e;\n                    break;\n\n                  case 4:\n                    return s.label++, {\n                      value: e[1],\n                      done: !1\n                    };\n\n                  case 5:\n                    s.label++, o = e[1], e = [0];\n                    continue;\n\n                  case 7:\n                    e = s.ops.pop(), s.trys.pop();\n                    continue;\n\n                  default:\n                    if (!(a = 0 < (a = s.trys).length && a[a.length - 1]) && (6 === e[0] || 2 === e[0])) {\n                      s = 0;\n                      continue;\n                    }\n\n                    if (3 === e[0] && (!a || e[1] > a[0] && e[1] < a[3])) {\n                      s.label = e[1];\n                      break;\n                    }\n\n                    if (6 === e[0] && s.label < a[1]) {\n                      s.label = a[1], a = e;\n                      break;\n                    }\n\n                    if (a && s.label < a[2]) {\n                      s.label = a[2], s.ops.push(e);\n                      break;\n                    }\n\n                    a[2] && s.ops.pop(), s.trys.pop();\n                    continue;\n                }\n\n                e = r.call(n, s);\n              } catch (t) {\n                e = [6, t], o = 0;\n              } finally {\n                i = a = 0;\n              }\n\n              if (5 & e[0]) throw e[1];\n              return {\n                value: e[0] ? e[1] : void 0,\n                done: !0\n              };\n            }([e, t]);\n          };\n        }\n      }\n\n      function a() {\n        return \"undefined\" != typeof navigator && \"string\" == typeof navigator.userAgent ? navigator.userAgent : \"\";\n      }\n\n      var d = function (r) {\n        function i(t, e) {\n          var n = r.call(this, e) || this;\n          return n.code = t, n.name = \"FirebaseError\", Object.setPrototypeOf(n, i.prototype), Error.captureStackTrace && Error.captureStackTrace(n, u.prototype.create), n;\n        }\n\n        return s(i, r), i;\n      }(Error),\n          u = function () {\n        function t(t, e, n) {\n          this.service = t, this.serviceName = e, this.errors = n;\n        }\n\n        return t.prototype.create = function (t) {\n          for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n          for (var r, i = e[0] || {}, o = this.service + \"/\" + t, a = this.errors[t], s = a ? (r = i, a.replace(m, function (t, e) {\n            var n = r[e];\n            return null != n ? n.toString() : \"<\" + e + \"?>\";\n          })) : \"Error\", u = this.serviceName + \": \" + s + \" (\" + o + \").\", c = new d(o, u), h = 0, l = Object.keys(i); h < l.length; h++) {\n            var f = l[h];\n            \"_\" !== f.slice(-1) && (f in c && console.warn('Overwriting FirebaseError base field \"' + f + '\" can cause unexpected behavior.'), c[f] = i[f]);\n          }\n\n          return c;\n        }, t;\n      }();\n\n      var c,\n          m = /\\{\\$([^}]+)}/g,\n          l = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {},\n          f = f || {},\n          y = l;\n\n      function g(t) {\n        return \"string\" == typeof t;\n      }\n\n      function v(t) {\n        return \"number\" == typeof t;\n      }\n\n      function b(t, e) {\n        t = t.split(\".\"), e = e || y;\n\n        for (var n = 0; n < t.length; n++) if (null == (e = e[t[n]])) return null;\n\n        return e;\n      }\n\n      function w() {}\n\n      function E(t) {\n        var e = typeof t;\n\n        if (\"object\" == e) {\n          if (!t) return \"null\";\n          if (t instanceof Array) return \"array\";\n          if (t instanceof Object) return e;\n          var n = Object.prototype.toString.call(t);\n          if (\"[object Window]\" == n) return \"object\";\n          if (\"[object Array]\" == n || \"number\" == typeof t.length && void 0 !== t.splice && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable(\"splice\")) return \"array\";\n          if (\"[object Function]\" == n || void 0 !== t.call && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable(\"call\")) return \"function\";\n        } else if (\"function\" == e && void 0 === t.call) return \"object\";\n\n        return e;\n      }\n\n      function S(t) {\n        return \"array\" == E(t);\n      }\n\n      function T(t) {\n        var e = E(t);\n        return \"array\" == e || \"object\" == e && \"number\" == typeof t.length;\n      }\n\n      function I(t) {\n        var e = typeof t;\n        return \"object\" == e && null != t || \"function\" == e;\n      }\n\n      var C = \"closure_uid_\" + (1e9 * Math.random() >>> 0),\n          D = 0;\n\n      function N(t, e, n) {\n        return t.call.apply(t.bind, arguments);\n      }\n\n      function A(e, n, t) {\n        if (!e) throw Error();\n\n        if (2 < arguments.length) {\n          var r = Array.prototype.slice.call(arguments, 2);\n          return function () {\n            var t = Array.prototype.slice.call(arguments);\n            return Array.prototype.unshift.apply(t, r), e.apply(n, t);\n          };\n        }\n\n        return function () {\n          return e.apply(n, arguments);\n        };\n      }\n\n      function k(t, e, n) {\n        return (k = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf(\"native code\") ? N : A).apply(null, arguments);\n      }\n\n      function R(e, t) {\n        var n = Array.prototype.slice.call(arguments, 1);\n        return function () {\n          var t = n.slice();\n          return t.push.apply(t, arguments), e.apply(this, t);\n        };\n      }\n\n      var M = Date.now || function () {\n        return +new Date();\n      };\n\n      function O(t, o) {\n        function e() {}\n\n        e.prototype = o.prototype, t.N = o.prototype, t.prototype = new e(), (t.prototype.constructor = t).yb = function (t, e, n) {\n          for (var r = Array(arguments.length - 2), i = 2; i < arguments.length; i++) r[i - 2] = arguments[i];\n\n          return o.prototype[e].apply(t, r);\n        };\n      }\n\n      function _() {\n        this.j = this.j, this.i = this.i;\n      }\n\n      _.prototype.j = !1, _.prototype.la = function () {\n        if (!this.j && (this.j = !0, this.G(), 0)) this[C] || (this[C] = ++D);\n      }, _.prototype.G = function () {\n        if (this.i) for (; this.i.length;) this.i.shift()();\n      };\n      var P = Array.prototype.indexOf ? function (t, e) {\n        return Array.prototype.indexOf.call(t, e, void 0);\n      } : function (t, e) {\n        if (g(t)) return g(e) && 1 == e.length ? t.indexOf(e, 0) : -1;\n\n        for (var n = 0; n < t.length; n++) if (n in t && t[n] === e) return n;\n\n        return -1;\n      },\n          L = Array.prototype.forEach ? function (t, e, n) {\n        Array.prototype.forEach.call(t, e, n);\n      } : function (t, e, n) {\n        for (var r = t.length, i = g(t) ? t.split(\"\") : t, o = 0; o < r; o++) o in i && e.call(n, i[o], o, t);\n      };\n\n      function x(t) {\n        return Array.prototype.concat.apply([], arguments);\n      }\n\n      function q(t) {\n        var e = t.length;\n\n        if (0 < e) {\n          for (var n = Array(e), r = 0; r < e; r++) n[r] = t[r];\n\n          return n;\n        }\n\n        return [];\n      }\n\n      function F(t) {\n        return /^[\\s\\xa0]*$/.test(t);\n      }\n\n      var V,\n          U = String.prototype.trim ? function (t) {\n        return t.trim();\n      } : function (t) {\n        return /^[\\s\\xa0]*([\\s\\S]*?)[\\s\\xa0]*$/.exec(t)[1];\n      };\n\n      function B(t, e) {\n        return -1 != t.indexOf(e);\n      }\n\n      function Q(t, e) {\n        return t < e ? -1 : e < t ? 1 : 0;\n      }\n\n      t: {\n        var K = y.navigator;\n\n        if (K) {\n          var j = K.userAgent;\n\n          if (j) {\n            V = j;\n            break t;\n          }\n        }\n\n        V = \"\";\n      }\n\n      function G(t, e, n) {\n        for (var r in t) e.call(n, t[r], r, t);\n      }\n\n      function W(t) {\n        var e,\n            n = {};\n\n        for (e in t) n[e] = t[e];\n\n        return n;\n      }\n\n      var z = \"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\n\n      function H(t, e) {\n        for (var n, r, i = 1; i < arguments.length; i++) {\n          for (n in r = arguments[i]) t[n] = r[n];\n\n          for (var o = 0; o < z.length; o++) n = z[o], Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n        }\n      }\n\n      function Y(t) {\n        return Y[\" \"](t), t;\n      }\n\n      Y[\" \"] = w;\n      var X,\n          J,\n          $ = B(V, \"Opera\"),\n          Z = B(V, \"Trident\") || B(V, \"MSIE\"),\n          tt = B(V, \"Edge\"),\n          et = tt || Z,\n          nt = B(V, \"Gecko\") && !(B(V.toLowerCase(), \"webkit\") && !B(V, \"Edge\")) && !(B(V, \"Trident\") || B(V, \"MSIE\")) && !B(V, \"Edge\"),\n          rt = B(V.toLowerCase(), \"webkit\") && !B(V, \"Edge\");\n\n      function it() {\n        var t = y.document;\n        return t ? t.documentMode : void 0;\n      }\n\n      t: {\n        var ot = \"\",\n            at = (J = V, nt ? /rv:([^\\);]+)(\\)|;)/.exec(J) : tt ? /Edge\\/([\\d\\.]+)/.exec(J) : Z ? /\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(J) : rt ? /WebKit\\/(\\S+)/.exec(J) : $ ? /(?:Version)[ \\/]?(\\S+)/.exec(J) : void 0);\n\n        if (at && (ot = at ? at[1] : \"\"), Z) {\n          var st = it();\n\n          if (null != st && st > parseFloat(ot)) {\n            X = String(st);\n            break t;\n          }\n        }\n\n        X = ot;\n      }\n\n      var ut,\n          ct = {};\n\n      function ht(s) {\n        return t = s, e = function () {\n          for (var t = 0, e = U(String(X)).split(\".\"), n = U(String(s)).split(\".\"), r = Math.max(e.length, n.length), i = 0; 0 == t && i < r; i++) {\n            var o = e[i] || \"\",\n                a = n[i] || \"\";\n\n            do {\n              if (o = /(\\d*)(\\D*)(.*)/.exec(o) || [\"\", \"\", \"\", \"\"], a = /(\\d*)(\\D*)(.*)/.exec(a) || [\"\", \"\", \"\", \"\"], 0 == o[0].length && 0 == a[0].length) break;\n              t = Q(0 == o[1].length ? 0 : parseInt(o[1], 10), 0 == a[1].length ? 0 : parseInt(a[1], 10)) || Q(0 == o[2].length, 0 == a[2].length) || Q(o[2], a[2]), o = o[3], a = a[3];\n            } while (0 == t);\n          }\n\n          return 0 <= t;\n        }, n = ct, Object.prototype.hasOwnProperty.call(n, t) ? n[t] : n[t] = e(t);\n        var t, e, n;\n      }\n\n      var lt = y.document;\n      ut = lt && Z ? it() || (\"CSS1Compat\" == lt.compatMode ? parseInt(X, 10) : 5) : void 0;\n\n      var ft = !Z || 9 <= Number(ut),\n          pt = Z && !ht(\"9\"),\n          dt = function () {\n        if (!y.addEventListener || !Object.defineProperty) return !1;\n        var t = !1,\n            e = Object.defineProperty({}, \"passive\", {\n          get: function () {\n            t = !0;\n          }\n        });\n\n        try {\n          y.addEventListener(\"test\", w, e), y.removeEventListener(\"test\", w, e);\n        } catch (t) {}\n\n        return t;\n      }();\n\n      function mt(t, e) {\n        this.type = t, this.a = this.target = e, this.Ja = !0;\n      }\n\n      function yt(t, e) {\n        if (mt.call(this, t ? t.type : \"\"), this.relatedTarget = this.a = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = \"\", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.pointerId = 0, this.pointerType = \"\", this.c = null, t) {\n          var n = this.type = t.type,\n              r = t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : null;\n\n          if (this.target = t.target || t.srcElement, this.a = e, e = t.relatedTarget) {\n            if (nt) {\n              t: {\n                try {\n                  Y(e.nodeName);\n                  var i = !0;\n                  break t;\n                } catch (t) {}\n\n                i = !1;\n              }\n\n              i || (e = null);\n            }\n          } else \"mouseover\" == n ? e = t.fromElement : \"mouseout\" == n && (e = t.toElement);\n\n          this.relatedTarget = e, this.screenY = r ? (this.clientX = void 0 !== r.clientX ? r.clientX : r.pageX, this.clientY = void 0 !== r.clientY ? r.clientY : r.pageY, this.screenX = r.screenX || 0, r.screenY || 0) : (this.clientX = void 0 !== t.clientX ? t.clientX : t.pageX, this.clientY = void 0 !== t.clientY ? t.clientY : t.pageY, this.screenX = t.screenX || 0, t.screenY || 0), this.button = t.button, this.key = t.key || \"\", this.ctrlKey = t.ctrlKey, this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.metaKey = t.metaKey, this.pointerId = t.pointerId || 0, this.pointerType = g(t.pointerType) ? t.pointerType : gt[t.pointerType] || \"\", (this.c = t).defaultPrevented && this.b();\n        }\n      }\n\n      mt.prototype.b = function () {\n        this.Ja = !1;\n      }, O(yt, mt);\n      var gt = {\n        2: \"touch\",\n        3: \"pen\",\n        4: \"mouse\"\n      };\n\n      yt.prototype.b = function () {\n        yt.N.b.call(this);\n        var t = this.c;\n        if (t.preventDefault) t.preventDefault();else if (t.returnValue = !1, pt) try {\n          (t.ctrlKey || 112 <= t.keyCode && t.keyCode <= 123) && (t.keyCode = -1);\n        } catch (t) {}\n      };\n\n      var vt = \"closure_listenable_\" + (1e6 * Math.random() | 0),\n          bt = 0;\n\n      function wt(t, e, n, r, i) {\n        this.listener = t, this.proxy = null, this.src = e, this.type = n, this.capture = !!r, this.da = i, this.key = ++bt, this.X = this.Z = !1;\n      }\n\n      function Et(t) {\n        t.X = !0, t.listener = null, t.proxy = null, t.src = null, t.da = null;\n      }\n\n      function St(t) {\n        this.src = t, this.a = {}, this.b = 0;\n      }\n\n      function Tt(t, e) {\n        var n = e.type;\n\n        if (n in t.a) {\n          var r,\n              i = t.a[n],\n              o = P(i, e);\n          (r = 0 <= o) && Array.prototype.splice.call(i, o, 1), r && (Et(e), 0 == t.a[n].length && (delete t.a[n], t.b--));\n        }\n      }\n\n      function It(t, e, n, r) {\n        for (var i = 0; i < t.length; ++i) {\n          var o = t[i];\n          if (!o.X && o.listener == e && o.capture == !!n && o.da == r) return i;\n        }\n\n        return -1;\n      }\n\n      St.prototype.add = function (t, e, n, r, i) {\n        var o = t.toString();\n        (t = this.a[o]) || (t = this.a[o] = [], this.b++);\n        var a = It(t, e, r, i);\n        return -1 < a ? (e = t[a], n || (e.Z = !1)) : ((e = new wt(e, this.src, o, !!r, i)).Z = n, t.push(e)), e;\n      };\n\n      var Ct = \"closure_lm_\" + (1e6 * Math.random() | 0),\n          Dt = {};\n\n      function Nt(t, e, n, r, i) {\n        if (r && r.once) return function t(e, n, r, i, o) {\n          if (S(n)) {\n            for (var a = 0; a < n.length; a++) t(e, n[a], r, i, o);\n\n            return null;\n          }\n\n          r = Lt(r);\n          return e && e[vt] ? e.Ba(n, r, I(i) ? !!i.capture : !!i, o) : At(e, n, r, !0, i, o);\n        }(t, e, n, r, i);\n\n        if (S(e)) {\n          for (var o = 0; o < e.length; o++) Nt(t, e[o], n, r, i);\n\n          return null;\n        }\n\n        return n = Lt(n), t && t[vt] ? t.Aa(e, n, I(r) ? !!r.capture : !!r, i) : At(t, e, n, !1, r, i);\n      }\n\n      function At(t, e, n, r, i, o) {\n        if (!e) throw Error(\"Invalid event type\");\n        var a = I(i) ? !!i.capture : !!i;\n        if (a && !ft) return null;\n\n        var s,\n            u,\n            c = _t(t);\n\n        if (c || (t[Ct] = c = new St(t)), (n = c.add(e, n, r, a, o)).proxy) return n;\n        if (s = Ot, r = u = ft ? function (t) {\n          return s.call(u.src, u.listener, t);\n        } : function (t) {\n          if (!(t = s.call(u.src, u.listener, t))) return t;\n        }, (n.proxy = r).src = t, r.listener = n, t.addEventListener) dt || (i = a), void 0 === i && (i = !1), t.addEventListener(e.toString(), r, i);else if (t.attachEvent) t.attachEvent(Rt(e.toString()), r);else {\n          if (!t.addListener || !t.removeListener) throw Error(\"addEventListener and attachEvent are unavailable.\");\n          t.addListener(r);\n        }\n        return n;\n      }\n\n      function kt(t) {\n        if (!v(t) && t && !t.X) {\n          var e = t.src;\n          if (e && e[vt]) Tt(e.c, t);else {\n            var n = t.type,\n                r = t.proxy;\n            e.removeEventListener ? e.removeEventListener(n, r, t.capture) : e.detachEvent ? e.detachEvent(Rt(n), r) : e.addListener && e.removeListener && e.removeListener(r), (n = _t(e)) ? (Tt(n, t), 0 == n.b && (n.src = null, e[Ct] = null)) : Et(t);\n          }\n        }\n      }\n\n      function Rt(t) {\n        return t in Dt ? Dt[t] : Dt[t] = \"on\" + t;\n      }\n\n      function Mt(t, e) {\n        var n = t.listener,\n            r = t.da || t.src;\n        return t.Z && kt(t), n.call(r, e);\n      }\n\n      function Ot(t, e) {\n        return !!t.X || (ft ? Mt(t, new yt(e, this)) : Mt(t, e = new yt(e || b(\"window.event\"), this)));\n      }\n\n      function _t(t) {\n        return (t = t[Ct]) instanceof St ? t : null;\n      }\n\n      var Pt = \"__closure_events_fn_\" + (1e9 * Math.random() >>> 0);\n\n      function Lt(e) {\n        return \"function\" == E(e) ? e : (e[Pt] || (e[Pt] = function (t) {\n          return e.handleEvent(t);\n        }), e[Pt]);\n      }\n\n      function xt() {\n        _.call(this), this.c = new St(this), (this.J = this).B = null;\n      }\n\n      function qt(t, e, n, r) {\n        if (!(e = t.c.a[String(e)])) return !0;\n        e = e.concat();\n\n        for (var i = !0, o = 0; o < e.length; ++o) {\n          var a = e[o];\n\n          if (a && !a.X && a.capture == n) {\n            var s = a.listener,\n                u = a.da || a.src;\n            a.Z && Tt(t.c, a), i = !1 !== s.call(u, r) && i;\n          }\n        }\n\n        return i && 0 != r.Ja;\n      }\n\n      O(xt, _), xt.prototype[vt] = !0, (c = xt.prototype).addEventListener = function (t, e, n, r) {\n        Nt(this, t, e, n, r);\n      }, c.removeEventListener = function (t, e, n, r) {\n        !function t(e, n, r, i, o) {\n          if (S(n)) for (var a = 0; a < n.length; a++) t(e, n[a], r, i, o);else i = I(i) ? !!i.capture : !!i, r = Lt(r), e && e[vt] ? (e = e.c, (n = String(n).toString()) in e.a && -1 < (r = It(a = e.a[n], r, i, o)) && (Et(a[r]), Array.prototype.splice.call(a, r, 1), 0 == a.length && (delete e.a[n], e.b--))) : e && (e = _t(e)) && (n = e.a[n.toString()], e = -1, n && (e = It(n, r, i, o)), (r = -1 < e ? n[e] : null) && kt(r));\n        }(this, t, e, n, r);\n      }, c.dispatchEvent = function (t) {\n        var e,\n            n = this.B;\n        if (n) for (e = []; n; n = n.B) e.push(n);\n        n = this.J;\n        var r = t.type || t;\n        if (g(t)) t = new mt(t, n);else if (t instanceof mt) t.target = t.target || n;else {\n          var i = t;\n          H(t = new mt(r, n), i);\n        }\n        if (i = !0, e) for (var o = e.length - 1; 0 <= o; o--) {\n          var a = t.a = e[o];\n          i = qt(a, r, !0, t) && i;\n        }\n        if (i = qt(a = t.a = n, r, !0, t) && i, i = qt(a, r, !1, t) && i, e) for (o = 0; o < e.length; o++) i = qt(a = t.a = e[o], r, !1, t) && i;\n        return i;\n      }, c.G = function () {\n        if (xt.N.G.call(this), this.c) {\n          var t,\n              e = this.c;\n\n          for (t in e.a) {\n            for (var n = e.a[t], r = 0; r < n.length; r++) Et(n[r]);\n\n            delete e.a[t], e.b--;\n          }\n        }\n\n        this.B = null;\n      }, c.Aa = function (t, e, n, r) {\n        return this.c.add(String(t), e, !1, n, r);\n      }, c.Ba = function (t, e, n, r) {\n        return this.c.add(String(t), e, !0, n, r);\n      };\n      var Ft = y.JSON.stringify;\n\n      function Vt(t, e) {\n        this.c = t, this.f = e, this.b = 0, this.a = null;\n      }\n\n      function Ut() {\n        this.b = this.a = null;\n      }\n\n      Vt.prototype.get = function () {\n        if (0 < this.b) {\n          this.b--;\n          var t = this.a;\n          this.a = t.next, t.next = null;\n        } else t = this.c();\n\n        return t;\n      };\n\n      var Bt,\n          Qt = new Vt(function () {\n        return new Kt();\n      }, function (t) {\n        t.reset();\n      });\n\n      function Kt() {\n        this.next = this.b = this.a = null;\n      }\n\n      function jt(t) {\n        y.setTimeout(function () {\n          throw t;\n        }, 0);\n      }\n\n      function Gt(t, e) {\n        var n;\n        Bt || (n = y.Promise.resolve(void 0), Bt = function () {\n          n.then(Ht);\n        }), Wt || (Bt(), Wt = !0), zt.add(t, e);\n      }\n\n      Ut.prototype.add = function (t, e) {\n        var n = Qt.get();\n        n.set(t, e), this.b ? this.b.next = n : this.a = n, this.b = n;\n      }, Kt.prototype.set = function (t, e) {\n        this.a = t, this.b = e, this.next = null;\n      };\n      var Wt = !(Kt.prototype.reset = function () {\n        this.next = this.b = this.a = null;\n      }),\n          zt = new Ut();\n\n      function Ht() {\n        for (var t; r = n = void 0, r = null, (n = zt).a && (r = n.a, n.a = n.a.next, n.a || (n.b = null), r.next = null), t = r;) {\n          try {\n            t.a.call(t.b);\n          } catch (t) {\n            jt(t);\n          }\n\n          var e = Qt;\n          e.f(t), e.b < 100 && (e.b++, t.next = e.a, e.a = t);\n        }\n\n        var n, r;\n        Wt = !1;\n      }\n\n      function Yt(t, e) {\n        xt.call(this), this.b = t || 1, this.a = e || y, this.f = k(this.gb, this), this.g = M();\n      }\n\n      function Xt(t) {\n        t.ba = !1, t.L && (t.a.clearTimeout(t.L), t.L = null);\n      }\n\n      function Jt(t, e, n) {\n        if (\"function\" == E(t)) n && (t = k(t, n));else {\n          if (!t || \"function\" != typeof t.handleEvent) throw Error(\"Invalid listener argument\");\n          t = k(t.handleEvent, t);\n        }\n        return 2147483647 < Number(e) ? -1 : y.setTimeout(t, e || 0);\n      }\n\n      function $t(t, e, n) {\n        _.call(this), this.f = null != n ? k(t, n) : t, this.c = e, this.b = k(this.ab, this), this.a = [];\n      }\n\n      function Zt(t) {\n        t.U = Jt(t.b, t.c), t.f.apply(null, t.a);\n      }\n\n      function te(t) {\n        _.call(this), this.b = t, this.a = {};\n      }\n\n      O(Yt, xt), (c = Yt.prototype).ba = !1, c.L = null, c.gb = function () {\n        if (this.ba) {\n          var t = M() - this.g;\n          0 < t && t < .8 * this.b ? this.L = this.a.setTimeout(this.f, this.b - t) : (this.L && (this.a.clearTimeout(this.L), this.L = null), this.dispatchEvent(\"tick\"), this.ba && (Xt(this), this.start()));\n        }\n      }, c.start = function () {\n        this.ba = !0, this.L || (this.L = this.a.setTimeout(this.f, this.b), this.g = M());\n      }, c.G = function () {\n        Yt.N.G.call(this), Xt(this), delete this.a;\n      }, O($t, _), (c = $t.prototype).ea = !1, c.U = null, c.Ua = function (t) {\n        this.a = arguments, this.U ? this.ea = !0 : Zt(this);\n      }, c.G = function () {\n        $t.N.G.call(this), this.U && (y.clearTimeout(this.U), this.U = null, this.ea = !1, this.a = []);\n      }, c.ab = function () {\n        this.U = null, this.ea && (this.ea = !1, Zt(this));\n      }, O(te, _);\n      var ee = [];\n\n      function ne(t, e, n, r) {\n        S(n) || (n && (ee[0] = n.toString()), n = ee);\n\n        for (var i = 0; i < n.length; i++) {\n          var o = Nt(e, n[i], r || t.handleEvent, !1, t.b || t);\n          if (!o) break;\n          t.a[o.key] = o;\n        }\n      }\n\n      function re(t) {\n        G(t.a, function (t, e) {\n          this.a.hasOwnProperty(e) && kt(t);\n        }, t), t.a = {};\n      }\n\n      function ie() {}\n\n      te.prototype.G = function () {\n        te.N.G.call(this), re(this);\n      }, te.prototype.handleEvent = function () {\n        throw Error(\"EventHandler.handleEvent not implemented\");\n      };\n      var oe = new xt();\n\n      function ae(t) {\n        mt.call(this, \"serverreachability\", t);\n      }\n\n      function se(t) {\n        oe.dispatchEvent(new ae(oe, t));\n      }\n\n      function ue(t) {\n        mt.call(this, \"statevent\", t);\n      }\n\n      function ce(t) {\n        oe.dispatchEvent(new ue(oe, t));\n      }\n\n      function he(t) {\n        mt.call(this, \"timingevent\", t);\n      }\n\n      function le(t, e) {\n        if (\"function\" != E(t)) throw Error(\"Fn must not be null and must be a function\");\n        return y.setTimeout(function () {\n          t();\n        }, e);\n      }\n\n      O(ae, mt), O(ue, mt), O(he, mt);\n      var fe = {\n        NO_ERROR: 0,\n        hb: 1,\n        ob: 2,\n        nb: 3,\n        kb: 4,\n        mb: 5,\n        pb: 6,\n        Ma: 7,\n        TIMEOUT: 8,\n        sb: 9\n      },\n          pe = {\n        jb: \"complete\",\n        wb: \"success\",\n        Na: \"error\",\n        Ma: \"abort\",\n        ub: \"ready\",\n        vb: \"readystatechange\",\n        TIMEOUT: \"timeout\",\n        qb: \"incrementaldata\",\n        tb: \"progress\",\n        lb: \"downloadprogress\",\n        xb: \"uploadprogress\"\n      };\n\n      function de() {}\n\n      function me(t) {\n        var e;\n        return (e = t.a) || (e = t.a = {}), e;\n      }\n\n      function ye() {}\n\n      de.prototype.a = null;\n      var ge,\n          ve = {\n        OPEN: \"a\",\n        ib: \"b\",\n        Na: \"c\",\n        rb: \"d\"\n      };\n\n      function be() {\n        mt.call(this, \"d\");\n      }\n\n      function we() {\n        mt.call(this, \"c\");\n      }\n\n      function Ee() {}\n\n      function Se(t, e, n) {\n        this.g = t, this.W = e, this.V = n || 1, this.I = new te(this), this.O = Te, t = et ? 125 : void 0, this.P = new Yt(t), this.h = null, this.b = !1, this.l = this.D = this.f = this.F = this.v = this.R = this.i = null, this.j = [], this.a = null, this.A = 0, this.c = this.w = null, this.o = -1, this.m = !1, this.J = 0, this.B = null, this.s = this.S = this.H = !1;\n      }\n\n      O(be, mt), O(we, mt), O(Ee, de), ge = new Ee();\n      var Te = 45e3,\n          Ie = {},\n          Ce = {};\n\n      function De(t, e, n) {\n        t.F = 1, t.f = Je(je(e)), t.l = n, t.H = !0, Ae(t, null);\n      }\n\n      function Ne(t, e, n, r) {\n        t.F = 1, t.f = Je(je(e)), t.l = null, t.H = n, Ae(t, r);\n      }\n\n      function Ae(t, e) {\n        t.v = M(), Me(t), t.D = je(t.f), Xe(t.D, \"t\", t.V), t.A = 0, t.a = t.g.$(t.g.Y() ? e : null), 0 < t.J && (t.B = new $t(k(t.Ka, t, t.a), t.J)), ne(t.I, t.a, \"readystatechange\", t.eb), e = t.h ? W(t.h) : {}, t.l ? (t.w || (t.w = \"POST\"), e[\"Content-Type\"] = \"application/x-www-form-urlencoded\", t.a.ca(t.D, t.w, t.l, e)) : (t.w = \"GET\", t.a.ca(t.D, t.w, null, e)), se(1);\n      }\n\n      function ke(t, e, n) {\n        for (var r = !0; !t.m && t.A < n.length;) {\n          var i = Re(t, n);\n\n          if (i == Ce) {\n            4 == e && (t.c = 4, ce(14), r = !1);\n            break;\n          }\n\n          if (i == Ie) {\n            t.c = 4, ce(15), r = !1;\n            break;\n          }\n\n          xe(t, i);\n        }\n\n        4 == e && 0 == n.length && (t.c = 1, ce(16), r = !1), t.b = t.b && r, r || (Le(t), Pe(t));\n      }\n\n      function Re(t, e) {\n        var n = t.A,\n            r = e.indexOf(\"\\n\", n);\n        return -1 == r ? Ce : (n = Number(e.substring(n, r)), isNaN(n) ? Ie : (r += 1) + n > e.length ? Ce : (e = e.substr(r, n), t.A = r + n, e));\n      }\n\n      function Me(t) {\n        t.R = M() + t.O, Oe(t, t.O);\n      }\n\n      function Oe(t, e) {\n        if (null != t.i) throw Error(\"WatchDog timer not null\");\n        t.i = le(k(t.bb, t), e);\n      }\n\n      function _e(t) {\n        t.i && (y.clearTimeout(t.i), t.i = null);\n      }\n\n      function Pe(t) {\n        t.g.Da() || t.m || t.g.na(t);\n      }\n\n      function Le(t) {\n        _e(t);\n\n        var e = t.B;\n        e && \"function\" == typeof e.la && e.la(), t.B = null, Xt(t.P), re(t.I), t.a && (e = t.a, t.a = null, e.abort(), e.la());\n      }\n\n      function xe(t, e) {\n        try {\n          t.g.Ga(t, e), se(4);\n        } catch (t) {}\n      }\n\n      function qe(t, e) {\n        if (t.forEach && \"function\" == typeof t.forEach) t.forEach(e, void 0);else if (T(t) || g(t)) L(t, e, void 0);else {\n          if (t.K && \"function\" == typeof t.K) var n = t.K();else if (t.C && \"function\" == typeof t.C) n = void 0;else if (T(t) || g(t)) {\n            n = [];\n\n            for (var r = t.length, i = 0; i < r; i++) n.push(i);\n          } else for (i in n = [], r = 0, t) n[r++] = i;\n\n          i = (r = function (t) {\n            if (t.C && \"function\" == typeof t.C) return t.C();\n            if (g(t)) return t.split(\"\");\n\n            if (T(t)) {\n              for (var e = [], n = t.length, r = 0; r < n; r++) e.push(t[r]);\n\n              return e;\n            }\n\n            for (r in e = [], n = 0, t) e[n++] = t[r];\n\n            return e;\n          }(t)).length;\n\n          for (var o = 0; o < i; o++) e.call(void 0, r[o], n && n[o], t);\n        }\n      }\n\n      function Fe(t, e) {\n        this.b = {}, this.a = [], this.c = 0;\n        var n = arguments.length;\n\n        if (1 < n) {\n          if (n % 2) throw Error(\"Uneven number of arguments\");\n\n          for (var r = 0; r < n; r += 2) this.set(arguments[r], arguments[r + 1]);\n        } else if (t) if (t instanceof Fe) for (n = t.K(), r = 0; r < n.length; r++) this.set(n[r], t.get(n[r]));else for (r in t) this.set(r, t[r]);\n      }\n\n      function Ve(t, e) {\n        Be(t.b, e) && (delete t.b[e], t.c--, t.a.length > 2 * t.c && Ue(t));\n      }\n\n      function Ue(t) {\n        if (t.c != t.a.length) {\n          for (var e = 0, n = 0; e < t.a.length;) {\n            var r = t.a[e];\n            Be(t.b, r) && (t.a[n++] = r), e++;\n          }\n\n          t.a.length = n;\n        }\n\n        if (t.c != t.a.length) {\n          var i = {};\n\n          for (n = e = 0; e < t.a.length;) Be(i, r = t.a[e]) || (i[t.a[n++] = r] = 1), e++;\n\n          t.a.length = n;\n        }\n      }\n\n      function Be(t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }\n\n      (c = Se.prototype).setTimeout = function (t) {\n        this.O = t;\n      }, c.eb = function (t) {\n        t = t.target;\n        var e = this.B;\n        e && 3 == jn(t) ? e.Ua() : this.Ka(t);\n      }, c.Ka = function (t) {\n        try {\n          if (t == this.a) t: {\n            var e = jn(this.a),\n                n = this.a.ya(),\n                r = this.a.T();\n\n            if (!(e < 3 || 3 == e && !et && !this.a.aa())) {\n              this.m || 4 != e || 7 == n || se(8 == n || r <= 0 ? 3 : 2), _e(this);\n              var i = this.a.T();\n              this.o = i;\n              var o = this.a.aa();\n\n              if (this.b = 200 == i) {\n                if (this.S && !this.s) {\n                  e: {\n                    if (this.a) {\n                      var a = Gn(this.a, \"X-HTTP-Initial-Response\");\n\n                      if (a && !F(a)) {\n                        var s = a;\n                        break e;\n                      }\n                    }\n\n                    s = null;\n                  }\n\n                  if (!s) {\n                    this.b = !1, this.c = 3, ce(12), Le(this), Pe(this);\n                    break t;\n                  }\n\n                  this.s = !0, xe(this, s);\n                }\n\n                this.H ? (ke(this, e, o), et && this.b && 3 == e && (ne(this.I, this.P, \"tick\", this.cb), this.P.start())) : xe(this, o), 4 == e && Le(this), this.b && !this.m && (4 == e ? this.g.na(this) : (this.b = !1, Me(this)));\n              } else 400 == i && 0 < o.indexOf(\"Unknown SID\") ? (this.c = 3, ce(12)) : (this.c = 0, ce(13)), Le(this), Pe(this);\n            }\n          }\n        } catch (t) {}\n      }, c.cb = function () {\n        if (this.a) {\n          var t = jn(this.a),\n              e = this.a.aa();\n          this.A < e.length && (_e(this), ke(this, t, e), this.b && 4 != t && Me(this));\n        }\n      }, c.cancel = function () {\n        this.m = !0, Le(this);\n      }, c.bb = function () {\n        this.i = null;\n        var t = M();\n        0 <= t - this.R ? (2 != this.F && (se(3), ce(17)), Le(this), this.c = 2, Pe(this)) : Oe(this, this.R - t);\n      }, (c = Fe.prototype).C = function () {\n        Ue(this);\n\n        for (var t = [], e = 0; e < this.a.length; e++) t.push(this.b[this.a[e]]);\n\n        return t;\n      }, c.K = function () {\n        return Ue(this), this.a.concat();\n      }, c.get = function (t, e) {\n        return Be(this.b, t) ? this.b[t] : e;\n      }, c.set = function (t, e) {\n        Be(this.b, t) || (this.c++, this.a.push(t)), this.b[t] = e;\n      }, c.forEach = function (t, e) {\n        for (var n = this.K(), r = 0; r < n.length; r++) {\n          var i = n[r],\n              o = this.get(i);\n          t.call(e, o, i, this);\n        }\n      };\n      var Qe = /^(?:([^:/?#.]+):)?(?:\\/\\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$/;\n\n      function Ke(t, e) {\n        var n;\n        this.b = this.j = this.f = \"\", this.i = null, this.g = this.a = \"\", this.h = !1, t instanceof Ke ? (this.h = void 0 !== e ? e : t.h, Ge(this, t.f), this.j = t.j, We(this, t.b), ze(this, t.i), this.a = t.a, He(this, fn(t.c)), this.g = t.g) : t && (n = String(t).match(Qe)) ? (this.h = !!e, Ge(this, n[1] || \"\", !0), this.j = $e(n[2] || \"\"), We(this, n[3] || \"\", !0), ze(this, n[4]), this.a = $e(n[5] || \"\", !0), He(this, n[6] || \"\", !0), this.g = $e(n[7] || \"\")) : (this.h = !!e, this.c = new sn(null, this.h));\n      }\n\n      function je(t) {\n        return new Ke(t);\n      }\n\n      function Ge(t, e, n) {\n        t.f = n ? $e(e, !0) : e, t.f && (t.f = t.f.replace(/:$/, \"\"));\n      }\n\n      function We(t, e, n) {\n        t.b = n ? $e(e, !0) : e;\n      }\n\n      function ze(t, e) {\n        if (e) {\n          if (e = Number(e), isNaN(e) || e < 0) throw Error(\"Bad port number \" + e);\n          t.i = e;\n        } else t.i = null;\n      }\n\n      function He(t, e, n) {\n        var r, i;\n        e instanceof sn ? (t.c = e, r = t.c, (i = t.h) && !r.f && (un(r), r.c = null, r.a.forEach(function (t, e) {\n          var n = e.toLowerCase();\n          e != n && (cn(this, e), ln(this, n, t));\n        }, r)), r.f = i) : (n || (e = Ze(e, on)), t.c = new sn(e, t.h));\n      }\n\n      function Ye(t, e, n) {\n        t.c.set(e, n);\n      }\n\n      function Xe(t, e, n) {\n        S(n) || (n = [String(n)]), ln(t.c, e, n);\n      }\n\n      function Je(t) {\n        return Ye(t, \"zx\", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ M()).toString(36)), t;\n      }\n\n      function $e(t, e) {\n        return t ? e ? decodeURI(t.replace(/%25/g, \"%2525\")) : decodeURIComponent(t) : \"\";\n      }\n\n      function Ze(t, e, n) {\n        return g(t) ? (t = encodeURI(t).replace(e, tn), n && (t = t.replace(/%25([0-9a-fA-F]{2})/g, \"%$1\")), t) : null;\n      }\n\n      function tn(t) {\n        return \"%\" + ((t = t.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & t).toString(16);\n      }\n\n      Ke.prototype.toString = function () {\n        var t = [],\n            e = this.f;\n        e && t.push(Ze(e, en, !0), \":\");\n        var n = this.b;\n        return (n || \"file\" == e) && (t.push(\"//\"), (e = this.j) && t.push(Ze(e, en, !0), \"@\"), t.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g, \"%$1\")), null != (n = this.i) && t.push(\":\", String(n))), (n = this.a) && (this.b && \"/\" != n.charAt(0) && t.push(\"/\"), t.push(Ze(n, \"/\" == n.charAt(0) ? rn : nn, !0))), (n = this.c.toString()) && t.push(\"?\", n), (n = this.g) && t.push(\"#\", Ze(n, an)), t.join(\"\");\n      }, Ke.prototype.resolve = function (t) {\n        var e = je(this),\n            n = !!t.f;\n        n ? Ge(e, t.f) : n = !!t.j, n ? e.j = t.j : n = !!t.b, n ? We(e, t.b) : n = null != t.i;\n        var r = t.a;\n        if (n) ze(e, t.i);else if (n = !!t.a) {\n          if (\"/\" != r.charAt(0)) if (this.b && !this.a) r = \"/\" + r;else {\n            var i = e.a.lastIndexOf(\"/\");\n            -1 != i && (r = e.a.substr(0, i + 1) + r);\n          }\n          if (\"..\" == (i = r) || \".\" == i) r = \"\";else if (B(i, \"./\") || B(i, \"/.\")) {\n            r = 0 == i.lastIndexOf(\"/\", 0), i = i.split(\"/\");\n\n            for (var o = [], a = 0; a < i.length;) {\n              var s = i[a++];\n              \".\" == s ? r && a == i.length && o.push(\"\") : \"..\" == s ? ((1 < o.length || 1 == o.length && \"\" != o[0]) && o.pop(), r && a == i.length && o.push(\"\")) : (o.push(s), r = !0);\n            }\n\n            r = o.join(\"/\");\n          } else r = i;\n        }\n        return n ? e.a = r : n = \"\" !== t.c.toString(), n ? He(e, fn(t.c)) : n = !!t.g, n && (e.g = t.g), e;\n      };\n      var en = /[#\\/\\?@]/g,\n          nn = /[#\\?:]/g,\n          rn = /[#\\?]/g,\n          on = /[#\\?@]/g,\n          an = /#/g;\n\n      function sn(t, e) {\n        this.b = this.a = null, this.c = t || null, this.f = !!e;\n      }\n\n      function un(n) {\n        n.a || (n.a = new Fe(), n.b = 0, n.c && function (t, e) {\n          if (t) {\n            t = t.split(\"&\");\n\n            for (var n = 0; n < t.length; n++) {\n              var r = t[n].indexOf(\"=\"),\n                  i = null;\n\n              if (0 <= r) {\n                var o = t[n].substring(0, r);\n                i = t[n].substring(r + 1);\n              } else o = t[n];\n\n              e(o, i ? decodeURIComponent(i.replace(/\\+/g, \" \")) : \"\");\n            }\n          }\n        }(n.c, function (t, e) {\n          n.add(decodeURIComponent(t.replace(/\\+/g, \" \")), e);\n        }));\n      }\n\n      function cn(t, e) {\n        un(t), e = pn(t, e), Be(t.a.b, e) && (t.c = null, t.b -= t.a.get(e).length, Ve(t.a, e));\n      }\n\n      function hn(t, e) {\n        return un(t), e = pn(t, e), Be(t.a.b, e);\n      }\n\n      function ln(t, e, n) {\n        cn(t, e), 0 < n.length && (t.c = null, t.a.set(pn(t, e), q(n)), t.b += n.length);\n      }\n\n      function fn(t) {\n        var e = new sn();\n        return e.c = t.c, t.a && (e.a = new Fe(t.a), e.b = t.b), e;\n      }\n\n      function pn(t, e) {\n        return e = String(e), t.f && (e = e.toLowerCase()), e;\n      }\n\n      function dn(t) {\n        this.a = t, this.b = this.h = null, this.g = !1, this.i = null, this.c = -1, this.l = this.f = null;\n      }\n\n      function mn(t) {\n        var e = t.a.F.a;\n        if (null != e) ce(4), e ? (ce(10), rr(t.a, t, !1)) : (ce(11), rr(t.a, t, !0));else {\n          t.b = new Se(t, void 0, void 0), t.b.h = t.h, e = ur(e = t.a, e.Y() ? t.f : null, t.i), ce(4), Xe(e, \"TYPE\", \"xmlhttp\");\n          var n = t.a.j,\n              r = t.a.I;\n          n && r && Ye(e, n, r), Ne(t.b, e, !1, t.f);\n        }\n      }\n\n      function yn() {\n        this.a = this.b = null;\n      }\n\n      function gn() {\n        this.a = new Fe();\n      }\n\n      function vn(t) {\n        var e = typeof t;\n        return \"object\" == e && t || \"function\" == e ? \"o\" + (t[C] || (t[C] = ++D)) : e.charAt(0) + t;\n      }\n\n      function bn(t, e) {\n        this.b = t, this.a = e;\n      }\n\n      function wn(t) {\n        this.g = t || En, t = y.PerformanceNavigationTiming ? 0 < (t = y.performance.getEntriesByType(\"navigation\")).length && (\"hq\" == t[0].nextHopProtocol || \"h2\" == t[0].nextHopProtocol) : !!(y.ka && y.ka.Ea && y.ka.Ea() && y.ka.Ea().zb), this.f = t ? this.g : 1, this.a = null, 1 < this.f && (this.a = new gn()), this.b = null, this.c = [];\n      }\n\n      (c = sn.prototype).add = function (t, e) {\n        un(this), this.c = null, t = pn(this, t);\n        var n = this.a.get(t);\n        return n || this.a.set(t, n = []), n.push(e), this.b += 1, this;\n      }, c.forEach = function (n, r) {\n        un(this), this.a.forEach(function (t, e) {\n          L(t, function (t) {\n            n.call(r, t, e, this);\n          }, this);\n        }, this);\n      }, c.K = function () {\n        un(this);\n\n        for (var t = this.a.C(), e = this.a.K(), n = [], r = 0; r < e.length; r++) for (var i = t[r], o = 0; o < i.length; o++) n.push(e[r]);\n\n        return n;\n      }, c.C = function (t) {\n        un(this);\n        var e = [];\n        if (g(t)) hn(this, t) && (e = x(e, this.a.get(pn(this, t))));else {\n          t = this.a.C();\n\n          for (var n = 0; n < t.length; n++) e = x(e, t[n]);\n        }\n        return e;\n      }, c.set = function (t, e) {\n        return un(this), this.c = null, hn(this, t = pn(this, t)) && (this.b -= this.a.get(t).length), this.a.set(t, [e]), this.b += 1, this;\n      }, c.get = function (t, e) {\n        return t && 0 < (t = this.C(t)).length ? String(t[0]) : e;\n      }, c.toString = function () {\n        if (this.c) return this.c;\n        if (!this.a) return \"\";\n\n        for (var t = [], e = this.a.K(), n = 0; n < e.length; n++) {\n          var r = e[n],\n              i = encodeURIComponent(String(r));\n          r = this.C(r);\n\n          for (var o = 0; o < r.length; o++) {\n            var a = i;\n            \"\" !== r[o] && (a += \"=\" + encodeURIComponent(String(r[o]))), t.push(a);\n          }\n        }\n\n        return this.c = t.join(\"&\");\n      }, O(function () {}, function () {}), (c = dn.prototype).M = null, c.$ = function (t) {\n        return this.a.$(t);\n      }, c.abort = function () {\n        this.b && (this.b.cancel(), this.b = null), this.c = -1;\n      }, c.Da = function () {\n        return !1;\n      }, c.Ga = function (t, e) {\n        if (this.c = t.o, 0 == this.M) {\n          if (!this.a.o && (t = t.a)) {\n            var n = Gn(t, \"X-Client-Wire-Protocol\");\n            this.l = n || null, this.a.j && (t = Gn(t, \"X-HTTP-Session-Id\")) && (this.a.I = t);\n          }\n\n          if (e) {\n            try {\n              var r = this.a.ja.a.parse(e);\n            } catch (t) {\n              return (e = this.a).m = this.c, void ar(e, 2);\n            }\n\n            this.f = r[0];\n          } else (e = this.a).m = this.c, ar(e, 2);\n        } else 1 == this.M && (this.g ? ce(6) : \"11111\" == e ? (ce(5), this.g = !0, (!Z || 10 <= Number(ut)) && (this.c = 200, this.b.cancel(), ce(11), rr(this.a, this, !0))) : (ce(7), this.g = !1));\n      }, c.na = function () {\n        if (this.c = this.b.o, this.b.b) 0 == this.M ? (this.M = 1, mn(this)) : 1 == this.M && (this.g ? (ce(11), rr(this.a, this, !0)) : (ce(10), rr(this.a, this, !1)));else {\n          0 == this.M ? ce(8) : 1 == this.M && ce(9);\n          var t = this.a;\n          t.m = this.c, ar(t, 2);\n        }\n      }, c.Y = function () {\n        return this.a.Y();\n      }, c.ma = function () {\n        return this.a.ma();\n      }, gn.prototype.add = function (t) {\n        this.a.set(vn(t), t);\n      }, gn.prototype.C = function () {\n        return this.a.C();\n      };\n      var En = 10;\n\n      function Sn(t, e) {\n        !t.a && (B(e, \"spdy\") || B(e, \"quic\") || B(e, \"h2\")) && (t.f = t.g, t.a = new gn(), t.b && (Dn(t, t.b), t.b = null));\n      }\n\n      function Tn(t) {\n        return !!t.b || !!t.a && t.a.a.c >= t.f;\n      }\n\n      function In(t) {\n        return t.b ? 1 : t.a ? t.a.a.c : 0;\n      }\n\n      function Cn(t, e) {\n        return t = t.b ? t.b == e : !!t.a && (e = vn(e), Be(t.a.a.b, e));\n      }\n\n      function Dn(t, e) {\n        t.a ? t.a.add(e) : t.b = e;\n      }\n\n      function Nn(t, e) {\n        var n;\n        t.b && t.b == e ? t.b = null : ((n = t.a) && (n = vn(e), n = Be(t.a.a.b, n)), n && Ve(t.a.a, vn(e)));\n      }\n\n      function An(t) {\n        if (null != t.b) return t.c.concat(t.b.j);\n        if (null == t.a || 0 == t.a.a.c) return q(t.c);\n        var e = t.c;\n        return L(t.a.C(), function (t) {\n          e = e.concat(t.j);\n        }), e;\n      }\n\n      function kn() {}\n\n      function Rn() {\n        this.a = new kn();\n      }\n\n      function Mn(t, r, e) {\n        var i = e || \"\";\n\n        try {\n          qe(t, function (t, e) {\n            var n = t;\n            I(t) && (n = Ft(t)), r.push(i + e + \"=\" + encodeURIComponent(n));\n          });\n        } catch (t) {\n          throw r.push(i + \"type=\" + encodeURIComponent(\"_badmap\")), t;\n        }\n      }\n\n      function On(t, e, n, r, i) {\n        try {\n          e.onload = null, e.onerror = null, e.onabort = null, e.ontimeout = null, i(r);\n        } catch (t) {}\n      }\n\n      wn.prototype.cancel = function () {\n        var t;\n        this.c = An(this), this.b ? (this.b.cancel(), this.b = null) : this.a && 0 != this.a.a.c && (L(this.a.C(), function (t) {\n          t.cancel();\n        }), (t = this.a.a).b = {}, t.a.length = 0, t.c = 0);\n      }, kn.prototype.stringify = function (t) {\n        return y.JSON.stringify(t, void 0);\n      }, kn.prototype.parse = function (t) {\n        return y.JSON.parse(t, void 0);\n      };\n      var _n = y.JSON.parse;\n\n      function Pn(t) {\n        xt.call(this), this.headers = new Fe(), this.H = t || null, this.b = !1, this.s = this.a = null, this.A = \"\", this.h = 0, this.f = \"\", this.g = this.w = this.l = this.v = !1, this.o = 0, this.m = null, this.I = Ln, this.D = this.F = !1;\n      }\n\n      O(Pn, xt);\n      var Ln = \"\",\n          xn = /^https?$/i,\n          qn = [\"POST\", \"PUT\"];\n\n      function Fn(t) {\n        return \"content-type\" == t.toLowerCase();\n      }\n\n      function Vn(t, e) {\n        t.b = !1, t.a && (t.g = !0, t.a.abort(), t.g = !1), t.f = e, t.h = 5, Un(t), Qn(t);\n      }\n\n      function Un(t) {\n        t.v || (t.v = !0, t.dispatchEvent(\"complete\"), t.dispatchEvent(\"error\"));\n      }\n\n      function Bn(t) {\n        if (t.b && void 0 !== f && (!t.s[1] || 4 != jn(t) || 2 != t.T())) if (t.l && 4 == jn(t)) Jt(t.Fa, 0, t);else if (t.dispatchEvent(\"readystatechange\"), 4 == jn(t)) {\n          t.b = !1;\n\n          try {\n            var e,\n                n = t.T();\n\n            t: switch (n) {\n              case 200:\n              case 201:\n              case 202:\n              case 204:\n              case 206:\n              case 304:\n              case 1223:\n                var r = !0;\n                break t;\n\n              default:\n                r = !1;\n            }\n\n            if (!(e = r)) {\n              var i;\n\n              if (i = 0 === n) {\n                var o = String(t.A).match(Qe)[1] || null;\n\n                if (!o && y.self && y.self.location) {\n                  var a = y.self.location.protocol;\n                  o = a.substr(0, a.length - 1);\n                }\n\n                i = !xn.test(o ? o.toLowerCase() : \"\");\n              }\n\n              e = i;\n            }\n\n            e ? (t.dispatchEvent(\"complete\"), t.dispatchEvent(\"success\")) : (t.h = 6, t.f = t.za() + \" [\" + t.T() + \"]\", Un(t));\n          } finally {\n            Qn(t);\n          }\n        }\n      }\n\n      function Qn(t, e) {\n        if (t.a) {\n          Kn(t);\n          var n = t.a,\n              r = t.s[0] ? w : null;\n          t.a = null, t.s = null, e || t.dispatchEvent(\"ready\");\n\n          try {\n            n.onreadystatechange = r;\n          } catch (t) {}\n        }\n      }\n\n      function Kn(t) {\n        t.a && t.D && (t.a.ontimeout = null), t.m && (y.clearTimeout(t.m), t.m = null);\n      }\n\n      function jn(t) {\n        return t.a ? t.a.readyState : 0;\n      }\n\n      function Gn(t, e) {\n        return t.a ? t.a.getResponseHeader(e) : null;\n      }\n\n      function Wn(t, e, n) {\n        t: {\n          for (r in n) {\n            var r = !1;\n            break t;\n          }\n\n          r = !0;\n        }\n\n        if (r) return t;\n        var i;\n\n        if (i = \"\", G(n, function (t, e) {\n          i += e, i += \":\", i += t, i += \"\\r\\n\";\n        }), n = i, g(t)) {\n          if (e = encodeURIComponent(String(e)), e += n = null != n ? \"=\" + encodeURIComponent(String(n)) : \"\") {\n            if ((n = t.indexOf(\"#\")) < 0 && (n = t.length), (r = t.indexOf(\"?\")) < 0 || n < r) {\n              r = n;\n              var o = \"\";\n            } else o = t.substring(r + 1, n);\n\n            n = (t = [t.substr(0, r), o, t.substr(n)])[1], t[1] = e ? n ? n + \"&\" + e : e : n, t = t[0] + (t[1] ? \"?\" + t[1] : \"\") + t[2];\n          }\n\n          return t;\n        }\n\n        return Ye(t, e, n), t;\n      }\n\n      function zn(t) {\n        this.f = [], this.F = new yn(), this.ga = this.pa = this.B = this.ha = this.a = this.I = this.j = this.V = this.g = this.J = this.i = null, this.Ra = this.P = 0, this.Pa = !!b(\"internalChannelParams.failFast\", t), this.ia = this.w = this.s = this.l = this.h = this.c = null, this.oa = !0, this.m = this.ra = this.O = -1, this.S = this.v = this.A = 0, this.Oa = b(\"internalChannelParams.baseRetryDelayMs\", t) || 5e3, this.Sa = b(\"internalChannelParams.retryDelaySeedMs\", t) || 1e4, this.Qa = b(\"internalChannelParams.forwardChannelMaxRetries\", t) || 2, this.qa = b(\"internalChannelParams.forwardChannelRequestTimeoutMs\", t) || 2e4, this.La = t && t.Ab || void 0, this.D = void 0, this.R = t && t.supportsCrossDomainXhr || !1, this.H = \"\", this.b = new wn(t && t.concurrentRequestLimit), this.ja = new Rn(), this.o = !t || void 0 === t.backgroundChannelTest || t.backgroundChannelTest, (this.W = t && t.fastHandshake || !1) && !this.o && (this.o = !0), t && t.forceLongPolling && (this.oa = !1), this.fa = void 0;\n      }\n\n      function Hn(t) {\n        if (Yn(t), 3 == t.u) {\n          var e = t.P++,\n              n = je(t.B);\n          Ye(n, \"SID\", t.H), Ye(n, \"RID\", e), Ye(n, \"TYPE\", \"terminate\"), Zn(t, n), (e = new Se(t, e, void 0)).F = 2, e.f = Je(je(n)), n = !1, y.navigator && y.navigator.sendBeacon && (n = y.navigator.sendBeacon(e.f.toString(), \"\")), !n && y.Image && (new Image().src = e.f, n = !0), n || (e.a = e.g.$(null), e.a.ca(e.f)), e.v = M(), Me(e);\n        }\n\n        sr(t);\n      }\n\n      function Yn(t) {\n        t.w && (t.w.abort(), t.w = null), t.a && (t.a.cancel(), t.a = null), t.l && (y.clearTimeout(t.l), t.l = null), ir(t), t.b.cancel(), t.h && (v(t.h) && y.clearTimeout(t.h), t.h = null);\n      }\n\n      function Xn(t, e) {\n        t.f.push(new bn(t.Ra++, e)), 3 == t.u && Jn(t);\n      }\n\n      function Jn(t) {\n        Tn(t.b) || t.h || (t.h = !0, Gt(t.Ia, t), t.A = 0);\n      }\n\n      function $n(t, e) {\n        var n;\n        n = e ? e.W : t.P++;\n        var r = je(t.B);\n        Ye(r, \"SID\", t.H), Ye(r, \"RID\", n), Ye(r, \"AID\", t.O), Zn(t, r), t.g && t.i && Wn(r, t.g, t.i), n = new Se(t, n, t.A + 1), null === t.g && (n.h = t.i), e && (t.f = e.j.concat(t.f)), e = tr(t, n, 1e3), n.setTimeout(Math.round(.5 * t.qa) + Math.round(.5 * t.qa * Math.random())), Dn(t.b, n), De(n, r, e);\n      }\n\n      function Zn(t, n) {\n        t.c && qe({}, function (t, e) {\n          Ye(n, e, t);\n        });\n      }\n\n      function tr(t, e, n) {\n        n = Math.min(t.f.length, n);\n        var r = t.c ? k(t.c.Ta, t.c, t) : null;\n\n        t: for (var i = t.f, o = -1;;) {\n          var a = [\"count=\" + n];\n          -1 == o ? 0 < n ? (o = i[0].b, a.push(\"ofs=\" + o)) : o = 0 : a.push(\"ofs=\" + o);\n\n          for (var s = !0, u = 0; u < n; u++) {\n            var c = i[u].b,\n                h = i[u].a;\n            if ((c -= o) < 0) o = Math.max(0, i[u].b - 100), s = !1;else try {\n              Mn(h, a, \"req\" + c + \"_\");\n            } catch (t) {\n              r && r(h);\n            }\n          }\n\n          if (s) {\n            r = a.join(\"&\");\n            break t;\n          }\n        }\n\n        return t = t.f.splice(0, n), e.j = t, r;\n      }\n\n      function er(t) {\n        t.a || t.l || (t.S = 1, Gt(t.Ha, t), t.v = 0);\n      }\n\n      function nr(t) {\n        return !(t.a || t.l || 3 <= t.v) && (t.S++, t.l = le(k(t.Ha, t), or(t, t.v)), t.v++, !0);\n      }\n\n      function rr(t, e, n) {\n        var r = e.l;\n        r && Sn(t.b, r), t.ia = t.oa && n, t.m = e.c, t.B = ur(t, null, t.ha), Jn(t);\n      }\n\n      function ir(t) {\n        null != t.s && (y.clearTimeout(t.s), t.s = null);\n      }\n\n      function or(t, e) {\n        var n = t.Oa + Math.floor(Math.random() * t.Sa);\n        return t.ma() || (n *= 2), n * e;\n      }\n\n      function ar(t, e) {\n        if (2 == e) {\n          var n = null;\n          t.c && (n = null);\n          var r = k(t.fb, t);\n          n || (n = new Ke(\"//www.google.com/images/cleardot.gif\"), y.location && \"http\" == y.location.protocol || Ge(n, \"https\"), Je(n)), function (t, e) {\n            var n = new ie();\n\n            if (y.Image) {\n              var r = new Image();\n              r.onload = R(On, n, r, \"TestLoadImage: loaded\", !0, e), r.onerror = R(On, n, r, \"TestLoadImage: error\", !1, e), r.onabort = R(On, n, r, \"TestLoadImage: abort\", !1, e), r.ontimeout = R(On, n, r, \"TestLoadImage: timeout\", !1, e), y.setTimeout(function () {\n                r.ontimeout && r.ontimeout();\n              }, 1e4), r.src = t;\n            } else e(!1);\n          }(n.toString(), r);\n        } else ce(2);\n\n        t.u = 0, t.c && t.c.ta(e), sr(t), Yn(t);\n      }\n\n      function sr(t) {\n        t.u = 0, t.m = -1, t.c && (0 == An(t.b).length && 0 == t.f.length || (t.b.c.length = 0, q(t.f), t.f.length = 0), t.c.sa());\n      }\n\n      function ur(t, e, n) {\n        var r,\n            i,\n            o,\n            a,\n            s,\n            u,\n            c = (r = n) instanceof Ke ? je(r) : new Ke(r, void 0);\n        if (\"\" != c.b) e && We(c, e + \".\" + c.b), ze(c, c.i);else {\n          var h,\n              l = y.location;\n          h = e ? e + \".\" + l.hostname : l.hostname, i = l.protocol, o = h, a = +l.port, s = n, u = new Ke(null, void 0), i && Ge(u, i), o && We(u, o), a && ze(u, a), s && (u.a = s), c = u;\n        }\n        return t.V && G(t.V, function (t, e) {\n          Ye(c, e, t);\n        }), e = t.j, n = t.I, e && n && Ye(c, e, n), Ye(c, \"VER\", t.wa), Zn(t, c), c;\n      }\n\n      function cr() {}\n\n      function hr() {\n        if (Z && !(10 <= Number(ut))) throw Error(\"Environmental error: no available transport.\");\n      }\n\n      function lr(t, e) {\n        xt.call(this), this.a = new zn(e), this.g = t, this.m = e && e.testUrl ? e.testUrl : function (t) {\n          for (var e = t, n = 1; n < arguments.length; n++) {\n            var r,\n                i = arguments[n];\n            0 == i.lastIndexOf(\"/\", 0) ? e = i : ((r = \"\" == e) || (r = 0 <= (r = e.length - 1) && e.indexOf(\"/\", r) == r), e += r ? i : \"/\" + i);\n          }\n\n          return e;\n        }(this.g, \"test\"), this.b = e && e.messageUrlParams || null, t = e && e.messageHeaders || null, e && e.clientProtocolHeaderRequired && (t ? t[\"X-Client-Protocol\"] = \"webchannel\" : t = {\n          \"X-Client-Protocol\": \"webchannel\"\n        }), this.a.i = t, t = e && e.initMessageHeaders || null, e && e.messageContentType && (t ? t[\"X-WebChannel-Content-Type\"] = e.messageContentType : t = {\n          \"X-WebChannel-Content-Type\": e.messageContentType\n        }), e && e.xa && (t ? t[\"X-WebChannel-Client-Profile\"] = e.xa : t = {\n          \"X-WebChannel-Client-Profile\": e.xa\n        }), this.a.J = t, (t = e && e.httpHeadersOverwriteParam) && !F(t) && (this.a.g = t), this.l = e && e.supportsCrossDomainXhr || !1, this.h = e && e.sendRawJson || !1, (e = e && e.httpSessionIdParam) && !F(e) && (this.a.j = e, null !== (t = this.b) && e in t && e in (t = this.b) && delete t[e]), this.f = new dr(this);\n      }\n\n      function fr(t) {\n        be.call(this);\n        var e = t.__sm__;\n\n        if (e) {\n          t: {\n            for (var n in e) {\n              t = n;\n              break t;\n            }\n\n            t = void 0;\n          }\n\n          (this.c = t) ? (t = this.c, this.data = null !== e && t in e ? e[t] : void 0) : this.data = e;\n        } else this.data = t;\n      }\n\n      function pr() {\n        we.call(this), this.status = 1;\n      }\n\n      function dr(t) {\n        this.a = t;\n      }\n\n      (c = Pn.prototype).ca = function (t, e, n, r) {\n        if (this.a) throw Error(\"[goog.net.XhrIo] Object is active with another request=\" + this.A + \"; newUri=\" + t);\n        e = e ? e.toUpperCase() : \"GET\", this.A = t, this.f = \"\", this.h = 0, this.v = !1, this.b = !0, this.a = new XMLHttpRequest(), this.s = this.H ? me(this.H) : me(ge), this.a.onreadystatechange = k(this.Fa, this);\n\n        try {\n          this.w = !0, this.a.open(e, String(t), !0), this.w = !1;\n        } catch (t) {\n          return void Vn(this, t);\n        }\n\n        t = n || \"\";\n        var i,\n            o = new Fe(this.headers);\n        r && qe(r, function (t, e) {\n          o.set(e, t);\n        }), r = function (t) {\n          t: {\n            for (var e = Fn, n = t.length, r = g(t) ? t.split(\"\") : t, i = 0; i < n; i++) if (i in r && e.call(void 0, r[i], i, t)) {\n              e = i;\n              break t;\n            }\n\n            e = -1;\n          }\n\n          return e < 0 ? null : g(t) ? t.charAt(e) : t[e];\n        }(o.K()), n = y.FormData && t instanceof y.FormData, !(0 <= P(qn, e)) || r || n || o.set(\"Content-Type\", \"application/x-www-form-urlencoded;charset=utf-8\"), o.forEach(function (t, e) {\n          this.a.setRequestHeader(e, t);\n        }, this), this.I && (this.a.responseType = this.I), \"withCredentials\" in this.a && this.a.withCredentials !== this.F && (this.a.withCredentials = this.F);\n\n        try {\n          Kn(this), 0 < this.o && ((this.D = (i = this.a, Z && ht(9) && v(i.timeout) && void 0 !== i.ontimeout)) ? (this.a.timeout = this.o, this.a.ontimeout = k(this.Ca, this)) : this.m = Jt(this.Ca, this.o, this)), this.l = !0, this.a.send(t), this.l = !1;\n        } catch (t) {\n          Vn(this, t);\n        }\n      }, c.Ca = function () {\n        void 0 !== f && this.a && (this.f = \"Timed out after \" + this.o + \"ms, aborting\", this.h = 8, this.dispatchEvent(\"timeout\"), this.abort(8));\n      }, c.abort = function (t) {\n        this.a && this.b && (this.b = !1, this.g = !0, this.a.abort(), this.g = !1, this.h = t || 7, this.dispatchEvent(\"complete\"), this.dispatchEvent(\"abort\"), Qn(this));\n      }, c.G = function () {\n        this.a && (this.b && (this.b = !1, this.g = !0, this.a.abort(), this.g = !1), Qn(this, !0)), Pn.N.G.call(this);\n      }, c.Fa = function () {\n        this.j || (this.w || this.l || this.g ? Bn(this) : this.$a());\n      }, c.$a = function () {\n        Bn(this);\n      }, c.T = function () {\n        try {\n          return 2 < jn(this) ? this.a.status : -1;\n        } catch (t) {\n          return -1;\n        }\n      }, c.za = function () {\n        try {\n          return 2 < jn(this) ? this.a.statusText : \"\";\n        } catch (t) {\n          return \"\";\n        }\n      }, c.aa = function () {\n        try {\n          return this.a ? this.a.responseText : \"\";\n        } catch (t) {\n          return \"\";\n        }\n      }, c.Va = function (t) {\n        if (this.a) {\n          var e = this.a.responseText;\n          return t && 0 == e.indexOf(t) && (e = e.substring(t.length)), _n(e);\n        }\n      }, c.ya = function () {\n        return this.h;\n      }, c.Ya = function () {\n        return g(this.f) ? this.f : String(this.f);\n      }, (c = zn.prototype).wa = 8, c.u = 1, c.Da = function () {\n        return 0 == this.u;\n      }, c.Ia = function (t) {\n        if (this.h) if (this.h = null, 1 == this.u) {\n          if (!t) {\n            this.P = Math.floor(1e5 * Math.random());\n            var e,\n                n = new Se(this, t = this.P++, void 0),\n                r = this.i;\n            if (this.J && (r ? H(r = W(r), this.J) : r = this.J), null === this.g && (n.h = r), this.W) t: {\n              for (var i = e = 0; i < this.f.length; i++) {\n                var o = this.f[i];\n                if (void 0 === (o = \"__data__\" in o.a && g(o = o.a.__data__) ? o.length : void 0)) break;\n\n                if (4096 < (e += o)) {\n                  e = i;\n                  break t;\n                }\n\n                if (4096 === e || i === this.f.length - 1) {\n                  e = i + 1;\n                  break t;\n                }\n              }\n\n              e = 1e3;\n            } else e = 1e3;\n            e = tr(this, n, e), Ye(i = je(this.B), \"RID\", t), Ye(i, \"CVER\", 22), this.o && this.j && Ye(i, \"X-HTTP-Session-Id\", this.j), Zn(this, i), this.g && r && Wn(i, this.g, r), Dn(this.b, n), this.W ? (Ye(i, \"$req\", e), Ye(i, \"SID\", \"null\"), n.S = !0, De(n, i, null)) : De(n, i, e), this.u = 2;\n          }\n        } else 3 == this.u && (t ? $n(this, t) : 0 == this.f.length || Tn(this.b) || $n(this));\n      }, c.Ha = function () {\n        this.l = null, this.a = new Se(this, \"rpc\", this.S), null === this.g && (this.a.h = this.i), this.a.J = 0;\n        var t = je(this.pa);\n        Ye(t, \"RID\", \"rpc\"), Ye(t, \"SID\", this.H), Ye(t, \"CI\", this.ia ? \"0\" : \"1\"), Ye(t, \"AID\", this.O), Zn(this, t), Ye(t, \"TYPE\", \"xmlhttp\"), this.g && this.i && Wn(t, this.g, this.i), this.D && this.a.setTimeout(this.D), Ne(this.a, t, !0, this.ga);\n      }, c.Ga = function (t, e) {\n        if (0 != this.u && (this.a == t || Cn(this.b, t))) if (this.m = t.o, !t.s && Cn(this.b, t) && 3 == this.u) {\n          try {\n            var n = this.ja.a.parse(e);\n          } catch (t) {\n            n = null;\n          }\n\n          if (S(n) && 3 == n.length) {\n            if (0 == (e = n)[0]) {\n              t: if (!this.l) {\n                if (this.a) {\n                  if (!(this.a.v + 3e3 < t.v)) break t;\n                  ir(this), this.a.cancel(), this.a = null;\n                }\n\n                nr(this), ce(18);\n              }\n            } else this.ra = e[1], 0 < this.ra - this.O && e[2] < 37500 && this.ia && 0 == this.v && !this.s && (this.s = le(k(this.Za, this), 6e3));\n\n            if (In(this.b) <= 1 && this.fa) {\n              try {\n                this.fa();\n              } catch (t) {}\n\n              this.fa = void 0;\n            }\n          } else ar(this, 11);\n        } else if ((t.s || this.a == t) && ir(this), !F(e)) for (e = n = this.ja.a.parse(e), n = 0; n < e.length; n++) {\n          var r = e[n];\n          if (this.O = r[0], r = r[1], 2 == this.u) {\n            if (\"c\" == r[0]) {\n              this.H = r[1], this.ga = r[2];\n              var i = r[3];\n              null != i && (this.wa = i), null != (r = r[5]) && v(r) && 0 < r && (this.D = 1.5 * r), this.o && (r = t.a) && ((i = Gn(r, \"X-Client-Wire-Protocol\")) && Sn(this.b, i), this.j && (r = Gn(r, \"X-HTTP-Session-Id\"))) && (this.I = r, Ye(this.B, this.j, r)), this.u = 3, this.c && this.c.va(), r = t, this.pa = ur(this, this.Y() ? this.ga : null, this.ha), r.s ? (Nn(this.b, r), (i = this.D) && r.setTimeout(i), r.i && (_e(r), Me(r)), this.a = r) : er(this), 0 < this.f.length && Jn(this);\n            } else \"stop\" != r[0] && \"close\" != r[0] || ar(this, 7);\n          } else 3 == this.u && (\"stop\" == r[0] || \"close\" == r[0] ? \"stop\" == r[0] ? ar(this, 7) : Hn(this) : \"noop\" != r[0] && this.c && this.c.ua(r), this.v = 0);\n        }\n      }, c.Za = function () {\n        null != this.s && (this.s = null, this.a.cancel(), this.a = null, nr(this), ce(19));\n      }, c.na = function (t) {\n        var e,\n            n,\n            r = null;\n\n        if (this.a == t) {\n          ir(this), this.a = null;\n          var i = 2;\n        } else {\n          if (!Cn(this.b, t)) return;\n          r = t.j, Nn(this.b, t), i = 1;\n        }\n\n        if (this.m = t.o, 0 != this.u) if (t.b) 1 == i ? (r = M() - t.v, oe.dispatchEvent(new he(oe, t.l ? t.l.length : 0, r, this.A)), Jn(this)) : er(this);else {\n          var o = t.c;\n          if (3 == o || 0 == o && 0 < this.m || (1 != i || (n = t, In((e = this).b) >= e.b.f - (e.h ? 1 : 0) || (e.h ? (e.f = n.j.concat(e.f), 0) : 1 == e.u || 2 == e.u || e.A >= (e.Pa ? 0 : e.Qa) || (e.h = le(k(e.Ia, e, n), or(e, e.A)), e.A++, 0)))) && (2 != i || !nr(this))) switch (r && 0 < r.length && (t = this.b, t.c = t.c.concat(r)), o) {\n            case 1:\n              ar(this, 5);\n              break;\n\n            case 4:\n              ar(this, 10);\n              break;\n\n            case 3:\n              ar(this, 6);\n              break;\n\n            default:\n              ar(this, 2);\n          }\n        }\n      }, c.fb = function (t) {\n        ce(t ? 2 : 1);\n      }, c.$ = function (t) {\n        if (t && !this.R) throw Error(\"Can't create secondary domain capable XhrIo object.\");\n        return (t = new Pn(this.La)).F = this.R, t;\n      }, c.ma = function () {\n        return !!this.c && !0;\n      }, c.Y = function () {\n        return this.R;\n      }, (c = cr.prototype).va = function () {}, c.ua = function () {}, c.ta = function () {}, c.sa = function () {}, c.Ta = function () {}, hr.prototype.a = function (t, e) {\n        return new lr(t, e);\n      }, O(lr, xt), (c = lr.prototype).addEventListener = function (t, e, n, r) {\n        lr.N.addEventListener.call(this, t, e, n, r);\n      }, c.removeEventListener = function (t, e, n, r) {\n        lr.N.removeEventListener.call(this, t, e, n, r);\n      }, c.Wa = function () {\n        this.a.c = this.f, this.l && (this.a.R = !0);\n        var t = this.a,\n            e = this.m,\n            n = this.g,\n            r = this.b || void 0;\n        ce(0), t.ha = n, t.V = r || {}, t.o && (t.F.b = [], t.F.a = !1), t.w = new dn(t), null === t.g && (t.w.h = t.i), n = e, t.g && t.i && (n = Wn(e, t.g, t.i)), (t = t.w).i = n, e = ur(t.a, null, t.i), ce(3), null != (n = t.a.F.b) ? (t.f = n[0], t.M = 1, mn(t)) : (Xe(e, \"MODE\", \"init\"), !t.a.o && t.a.j && Xe(e, \"X-HTTP-Session-Id\", t.a.j), t.b = new Se(t, void 0, void 0), t.b.h = t.h, Ne(t.b, e, !1, null), t.M = 0);\n      }, c.close = function () {\n        Hn(this.a);\n      }, c.Xa = function (t) {\n        if (g(t)) {\n          var e = {};\n          e.__data__ = t, Xn(this.a, e);\n        } else this.h ? ((e = {}).__data__ = Ft(t), Xn(this.a, e)) : Xn(this.a, t);\n      }, c.G = function () {\n        this.a.c = null, delete this.f, Hn(this.a), delete this.a, lr.N.G.call(this);\n      }, O(fr, be), O(pr, we), O(dr, cr), dr.prototype.va = function () {\n        this.a.dispatchEvent(\"a\");\n      }, dr.prototype.ua = function (t) {\n        this.a.dispatchEvent(new fr(t));\n      }, dr.prototype.ta = function (t) {\n        this.a.dispatchEvent(new pr(t));\n      }, dr.prototype.sa = function () {\n        this.a.dispatchEvent(\"b\");\n      };\n      var mr = R(function (t, e) {\n        function n() {}\n\n        n.prototype = t.prototype;\n        var r = new n();\n        return t.apply(r, Array.prototype.slice.call(arguments, 1)), r;\n      }, hr);\n      hr.prototype.createWebChannel = hr.prototype.a, lr.prototype.send = lr.prototype.Xa, lr.prototype.open = lr.prototype.Wa, lr.prototype.close = lr.prototype.close, fe.NO_ERROR = 0, fe.TIMEOUT = 8, fe.HTTP_ERROR = 6, pe.COMPLETE = \"complete\", (ye.EventType = ve).OPEN = \"a\", ve.CLOSE = \"b\", ve.ERROR = \"c\", ve.MESSAGE = \"d\", xt.prototype.listen = xt.prototype.Aa, Pn.prototype.listenOnce = Pn.prototype.Ba, Pn.prototype.getLastError = Pn.prototype.Ya, Pn.prototype.getLastErrorCode = Pn.prototype.ya, Pn.prototype.getStatus = Pn.prototype.T, Pn.prototype.getStatusText = Pn.prototype.za, Pn.prototype.getResponseJson = Pn.prototype.Va, Pn.prototype.getResponseText = Pn.prototype.aa, Pn.prototype.send = Pn.prototype.ca;\n      var yr,\n          gr,\n          vr = {\n        createWebChannelTransport: mr,\n        ErrorCode: fe,\n        EventType: pe,\n        WebChannel: ye,\n        XhrIo: Pn\n      },\n          br = vr.createWebChannelTransport,\n          wr = vr.ErrorCode,\n          Er = vr.EventType,\n          Sr = vr.WebChannel,\n          Tr = vr.XhrIo,\n          Ir = Dh.SDK_VERSION,\n          Cr = new r(\"@firebase/firestore\");\n\n      function Dr() {\n        return Cr.logLevel === o.DEBUG ? yr.DEBUG : Cr.logLevel === o.SILENT ? yr.SILENT : yr.ERROR;\n      }\n\n      function Nr(t) {\n        switch (t) {\n          case yr.DEBUG:\n            Cr.logLevel = o.DEBUG;\n            break;\n\n          case yr.ERROR:\n            Cr.logLevel = o.ERROR;\n            break;\n\n          case yr.SILENT:\n            Cr.logLevel = o.SILENT;\n            break;\n\n          default:\n            Cr.error(\"Firestore (\" + Ir + \"): Invalid value passed to `setLogLevel`\");\n        }\n      }\n\n      function Ar(t, e) {\n        for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];\n\n        if (Cr.logLevel <= o.DEBUG) {\n          var i = n.map(Rr);\n          Cr.debug.apply(Cr, [\"Firestore (\" + Ir + \") [\" + t + \"]: \" + e].concat(i));\n        }\n      }\n\n      function kr(t) {\n        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n        if (Cr.logLevel <= o.ERROR) {\n          var r = e.map(Rr);\n          Cr.error.apply(Cr, [\"Firestore (\" + Ir + \"): \" + t].concat(r));\n        }\n      }\n\n      function Rr(e) {\n        if (\"string\" == typeof e) return e;\n\n        var t = _r.getPlatform();\n\n        try {\n          return t.formatJSON(e);\n        } catch (t) {\n          return e;\n        }\n      }\n\n      function Mr(t) {\n        var e = \"FIRESTORE (\" + Ir + \") INTERNAL ASSERTION FAILED: \" + t;\n        throw kr(e), new Error(e);\n      }\n\n      function Or(t, e) {\n        t || Mr(e);\n      }\n\n      (gr = yr || (yr = {}))[gr.DEBUG = 0] = \"DEBUG\", gr[gr.ERROR = 1] = \"ERROR\", gr[gr.SILENT = 2] = \"SILENT\";\n\n      var _r = function () {\n        function e() {}\n\n        return e.setPlatform = function (t) {\n          e.platform && Mr(\"Platform already defined\"), e.platform = t;\n        }, e.getPlatform = function () {\n          return e.platform || Mr(\"Platform not set\"), e.platform;\n        }, e;\n      }();\n\n      function Pr() {\n        return _r.getPlatform().emptyByteString;\n      }\n\n      var Lr = {\n        OK: \"ok\",\n        CANCELLED: \"cancelled\",\n        UNKNOWN: \"unknown\",\n        INVALID_ARGUMENT: \"invalid-argument\",\n        DEADLINE_EXCEEDED: \"deadline-exceeded\",\n        NOT_FOUND: \"not-found\",\n        ALREADY_EXISTS: \"already-exists\",\n        PERMISSION_DENIED: \"permission-denied\",\n        UNAUTHENTICATED: \"unauthenticated\",\n        RESOURCE_EXHAUSTED: \"resource-exhausted\",\n        FAILED_PRECONDITION: \"failed-precondition\",\n        ABORTED: \"aborted\",\n        OUT_OF_RANGE: \"out-of-range\",\n        UNIMPLEMENTED: \"unimplemented\",\n        INTERNAL: \"internal\",\n        UNAVAILABLE: \"unavailable\",\n        DATA_LOSS: \"data-loss\"\n      },\n          xr = function (r) {\n        function t(t, e) {\n          var n = r.call(this, e) || this;\n          return n.code = t, n.message = e, n.name = \"FirebaseError\", n.toString = function () {\n            return n.name + \": [code=\" + n.code + \"]: \" + n.message;\n          }, n;\n        }\n\n        return s(t, r), t;\n      }(Error);\n\n      function qr(t, e) {\n        function n() {\n          var t = \"This constructor is private.\";\n          throw e && (t += \" \", t += e), new xr(Lr.INVALID_ARGUMENT, t);\n        }\n\n        for (var r in n.prototype = t.prototype, t) t.hasOwnProperty(r) && (n[r] = t[r]);\n\n        return n;\n      }\n\n      function Fr(t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }\n\n      function Vr(t, e) {\n        return void 0 !== t ? t : e;\n      }\n\n      function Ur(t, e) {\n        for (var n in t) if (Object.prototype.hasOwnProperty.call(t, n)) {\n          var r = Number(n);\n          isNaN(r) || e(r, t[n]);\n        }\n      }\n\n      function Br(t, e) {\n        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n]);\n      }\n\n      function Qr(t) {\n        for (var e in Or(null != t && \"object\" == typeof t, \"isEmpty() expects object parameter.\"), t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1;\n\n        return !0;\n      }\n\n      function Kr(t, e) {\n        if (0 !== e.length) throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() does not support arguments, but was called with \" + ai(e.length, \"argument\") + \".\");\n      }\n\n      function jr(t, e, n) {\n        if (e.length !== n) throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() requires \" + ai(n, \"argument\") + \", but was called with \" + ai(e.length, \"argument\") + \".\");\n      }\n\n      function Gr(t, e, n) {\n        if (e.length < n) throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() requires at least \" + ai(n, \"argument\") + \", but was called with \" + ai(e.length, \"argument\") + \".\");\n      }\n\n      function Wr(t, e, n, r) {\n        if (e.length < n || e.length > r) throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() requires between \" + n + \" and \" + r + \" arguments, but was called with \" + ai(e.length, \"argument\") + \".\");\n      }\n\n      function zr(t, e, n, r) {\n        Zr(t, e, oi(n) + \" argument\", r);\n      }\n\n      function Hr(t, e, n, r) {\n        void 0 !== r && zr(t, e, n, r);\n      }\n\n      function Yr(t, e, n, r) {\n        Zr(t, e, n + \" option\", r);\n      }\n\n      function Xr(t, e, n, r) {\n        void 0 !== r && Yr(t, e, n, r);\n      }\n\n      function Jr(t, e, n, r, i) {\n        void 0 !== r && function (t, e, n, r, i) {\n          if (!(r instanceof Array)) throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + e + \" option to be an array, but it was: \" + ei(r));\n\n          for (var o = 0; o < r.length; ++o) if (!i(r[o])) throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() requires all \" + e + \" elements to be \" + n + \", but the value at index \" + o + \" was: \" + ei(r[o]));\n        }(t, e, n, r, i);\n      }\n\n      function $r(t, e, n, r, i) {\n        void 0 !== r && function (t, e, n, r, i) {\n          for (var o = [], a = 0, s = i; a < s.length; a++) {\n            var u = s[a];\n            if (u === r) return;\n            o.push(ei(u));\n          }\n\n          var c = ei(r);\n          throw new xr(Lr.INVALID_ARGUMENT, \"Invalid value \" + c + \" provided to function \" + t + '() for option \"' + n + '\". Acceptable values: ' + o.join(\", \"));\n        }(t, 0, n, r, i);\n      }\n\n      function Zr(t, e, n, r) {\n        if (!(\"object\" === e ? ti(r) : \"non-empty string\" === e ? \"string\" == typeof r && \"\" !== r : typeof r === e)) {\n          var i = ei(r);\n          throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + n + \" to be of type \" + e + \", but it was: \" + i);\n        }\n      }\n\n      function ti(t) {\n        return \"object\" == typeof t && null !== t && (Object.getPrototypeOf(t) === Object.prototype || null === Object.getPrototypeOf(t));\n      }\n\n      function ei(t) {\n        if (void 0 === t) return \"undefined\";\n        if (null === t) return \"null\";\n        if (\"string\" == typeof t) return 20 < t.length && (t = t.substring(0, 20) + \"...\"), JSON.stringify(t);\n        if (\"number\" == typeof t || \"boolean\" == typeof t) return \"\" + t;\n        if (\"object\" != typeof t) return \"function\" == typeof t ? \"a function\" : Mr(\"Unknown wrong type: \" + typeof t);\n        if (t instanceof Array) return \"an array\";\n\n        var e = function (t) {\n          if (t.constructor) {\n            var e = /function\\s+([^\\s(]+)\\s*\\(/.exec(t.constructor.toString());\n            if (e && 1 < e.length) return e[1];\n          }\n\n          return null;\n        }(t);\n\n        return e ? \"a custom \" + e + \" object\" : \"an object\";\n      }\n\n      function ni(t, e, n) {\n        if (void 0 === n) throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() requires a valid \" + oi(e) + \" argument, but it was undefined.\");\n      }\n\n      function ri(n, t, r) {\n        Br(t, function (t, e) {\n          if (r.indexOf(t) < 0) throw new xr(Lr.INVALID_ARGUMENT, \"Unknown option '\" + t + \"' passed to function \" + n + \"(). Available options: \" + r.join(\", \"));\n        });\n      }\n\n      function ii(t, e, n, r) {\n        var i = ei(r);\n        return new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + oi(n) + \" argument to be a \" + e + \", but it was: \" + i);\n      }\n\n      function oi(t) {\n        switch (t) {\n          case 1:\n            return \"first\";\n\n          case 2:\n            return \"second\";\n\n          case 3:\n            return \"third\";\n\n          default:\n            return t + \"th\";\n        }\n      }\n\n      function ai(t, e) {\n        return t + \" \" + e + (1 === t ? \"\" : \"s\");\n      }\n\n      var si = function () {\n        function t() {}\n\n        return t.newId = function () {\n          for (var t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", e = \"\", n = 0; n < 20; n++) e += t.charAt(Math.floor(Math.random() * t.length));\n\n          return Or(20 === e.length, \"Invalid auto ID: \" + e), e;\n        }, t;\n      }();\n\n      function ui(t, e) {\n        return t < e ? -1 : e < t ? 1 : 0;\n      }\n\n      function ci(t, e) {\n        if (t.length !== e.length) return !1;\n\n        for (var n = 0; n < t.length; n++) if (!t[n].isEqual(e[n])) return !1;\n\n        return !0;\n      }\n\n      function hi(t) {\n        return t + \"\\0\";\n      }\n\n      function li() {\n        if (\"undefined\" == typeof Uint8Array) throw new xr(Lr.UNIMPLEMENTED, \"Uint8Arrays are not available in this environment.\");\n      }\n\n      function fi() {\n        if (!_r.getPlatform().base64Available) throw new xr(Lr.UNIMPLEMENTED, \"Blobs are unavailable in Firestore in this environment.\");\n      }\n\n      var pi,\n          di,\n          mi = function () {\n        function e(t) {\n          fi(), this._binaryString = t;\n        }\n\n        return e.fromBase64String = function (t) {\n          jr(\"Blob.fromBase64String\", arguments, 1), zr(\"Blob.fromBase64String\", \"string\", 1, t), fi();\n\n          try {\n            return new e(_r.getPlatform().atob(t));\n          } catch (t) {\n            throw new xr(Lr.INVALID_ARGUMENT, \"Failed to construct Blob from Base64 string: \" + t);\n          }\n        }, e.fromUint8Array = function (t) {\n          if (jr(\"Blob.fromUint8Array\", arguments, 1), li(), !(t instanceof Uint8Array)) throw ii(\"Blob.fromUint8Array\", \"Uint8Array\", 1, t);\n          return new e(Array.prototype.map.call(t, function (t) {\n            return String.fromCharCode(t);\n          }).join(\"\"));\n        }, e.prototype.toBase64 = function () {\n          return jr(\"Blob.toBase64\", arguments, 0), fi(), _r.getPlatform().btoa(this._binaryString);\n        }, e.prototype.toUint8Array = function () {\n          jr(\"Blob.toUint8Array\", arguments, 0), li();\n\n          for (var t = new Uint8Array(this._binaryString.length), e = 0; e < this._binaryString.length; e++) t[e] = this._binaryString.charCodeAt(e);\n\n          return t;\n        }, e.prototype.toString = function () {\n          return \"Blob(base64: \" + this.toBase64() + \")\";\n        }, e.prototype.isEqual = function (t) {\n          return this._binaryString === t._binaryString;\n        }, e.prototype._compareTo = function (t) {\n          return ui(this._binaryString, t._binaryString);\n        }, e;\n      }(),\n          yi = qr(mi, \"Use Blob.fromUint8Array() or Blob.fromBase64String() instead.\"),\n          gi = function (t, e, n, r, i) {\n        this.databaseId = t, this.persistenceKey = e, this.host = n, this.ssl = r, this.forceLongPolling = i;\n      },\n          vi = \"(default)\",\n          bi = function () {\n        function e(t, e) {\n          this.projectId = t, this.database = e || vi;\n        }\n\n        return Object.defineProperty(e.prototype, \"isDefaultDatabase\", {\n          get: function () {\n            return this.database === vi;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && t.projectId === this.projectId && t.database === this.database;\n        }, e.prototype.compareTo = function (t) {\n          return ui(this.projectId, t.projectId) || ui(this.database, t.database);\n        }, e;\n      }(),\n          wi = function () {\n        function t(t, e) {\n          var n = this;\n          this.previousValue = t, e && (e.sequenceNumberHandler = function (t) {\n            return n.setPreviousValue(t);\n          }, this.writeNewSequenceNumber = function (t) {\n            return e.writeSequenceNumber(t);\n          });\n        }\n\n        return t.prototype.setPreviousValue = function (t) {\n          return this.previousValue = Math.max(t, this.previousValue), this.previousValue;\n        }, t.prototype.next = function () {\n          var t = ++this.previousValue;\n          return this.writeNewSequenceNumber && this.writeNewSequenceNumber(t), t;\n        }, t.INVALID = -1, t;\n      }(),\n          Ei = \"__name__\",\n          Si = function () {\n        function n(t, e, n) {\n          this.init(t, e, n);\n        }\n\n        return n.prototype.init = function (t, e, n) {\n          void 0 === e ? e = 0 : e > t.length && Mr(\"offset \" + e + \" out of range \" + t.length), void 0 === n ? n = t.length - e : n > t.length - e && Mr(\"length \" + n + \" out of range \" + (t.length - e)), this.segments = t, this.offset = e, this.len = n;\n        }, n.prototype.construct = function (t, e, n) {\n          var r = Object.create(Object.getPrototypeOf(this));\n          return r.init(t, e, n), r;\n        }, Object.defineProperty(n.prototype, \"length\", {\n          get: function () {\n            return this.len;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), n.prototype.isEqual = function (t) {\n          return 0 === n.comparator(this, t);\n        }, n.prototype.child = function (t) {\n          var e = this.segments.slice(this.offset, this.limit());\n          return t instanceof n ? t.forEach(function (t) {\n            e.push(t);\n          }) : \"string\" == typeof t ? e.push(t) : Mr(\"Unknown parameter type for Path.child(): \" + t), this.construct(e);\n        }, n.prototype.limit = function () {\n          return this.offset + this.length;\n        }, n.prototype.popFirst = function (t) {\n          return t = void 0 === t ? 1 : t, Or(this.length >= t, \"Can't call popFirst() with less segments\"), this.construct(this.segments, this.offset + t, this.length - t);\n        }, n.prototype.popLast = function () {\n          return Or(!this.isEmpty(), \"Can't call popLast() on empty path\"), this.construct(this.segments, this.offset, this.length - 1);\n        }, n.prototype.firstSegment = function () {\n          return Or(!this.isEmpty(), \"Can't call firstSegment() on empty path\"), this.segments[this.offset];\n        }, n.prototype.lastSegment = function () {\n          return this.get(this.length - 1);\n        }, n.prototype.get = function (t) {\n          return Or(t < this.length, \"Index out of range\"), this.segments[this.offset + t];\n        }, n.prototype.isEmpty = function () {\n          return 0 === this.length;\n        }, n.prototype.isPrefixOf = function (t) {\n          if (t.length < this.length) return !1;\n\n          for (var e = 0; e < this.length; e++) if (this.get(e) !== t.get(e)) return !1;\n\n          return !0;\n        }, n.prototype.isImmediateParentOf = function (t) {\n          if (this.length + 1 !== t.length) return !1;\n\n          for (var e = 0; e < this.length; e++) if (this.get(e) !== t.get(e)) return !1;\n\n          return !0;\n        }, n.prototype.forEach = function (t) {\n          for (var e = this.offset, n = this.limit(); e < n; e++) t(this.segments[e]);\n        }, n.prototype.toArray = function () {\n          return this.segments.slice(this.offset, this.limit());\n        }, n.comparator = function (t, e) {\n          for (var n = Math.min(t.length, e.length), r = 0; r < n; r++) {\n            var i = t.get(r),\n                o = e.get(r);\n            if (i < o) return -1;\n            if (o < i) return 1;\n          }\n\n          return t.length < e.length ? -1 : t.length > e.length ? 1 : 0;\n        }, n;\n      }(),\n          Ti = function (t) {\n        function e() {\n          return null !== t && t.apply(this, arguments) || this;\n        }\n\n        return s(e, t), e.prototype.canonicalString = function () {\n          return this.toArray().join(\"/\");\n        }, e.prototype.toString = function () {\n          return this.canonicalString();\n        }, e.fromString = function (t) {\n          if (0 <= t.indexOf(\"//\")) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid path (\" + t + \"). Paths must not contain // in them.\");\n          return new e(t.split(\"/\").filter(function (t) {\n            return 0 < t.length;\n          }));\n        }, e.EMPTY_PATH = new e([]), e;\n      }(Si),\n          Ii = /^[_a-zA-Z][_a-zA-Z0-9]*$/,\n          Ci = function (t) {\n        function u() {\n          return null !== t && t.apply(this, arguments) || this;\n        }\n\n        return s(u, t), u.isValidIdentifier = function (t) {\n          return Ii.test(t);\n        }, u.prototype.canonicalString = function () {\n          return this.toArray().map(function (t) {\n            return t = t.replace(\"\\\\\", \"\\\\\\\\\").replace(\"`\", \"\\\\`\"), u.isValidIdentifier(t) || (t = \"`\" + t + \"`\"), t;\n          }).join(\".\");\n        }, u.prototype.toString = function () {\n          return this.canonicalString();\n        }, u.prototype.isKeyField = function () {\n          return 1 === this.length && this.get(0) === Ei;\n        }, u.keyField = function () {\n          return new u([Ei]);\n        }, u.fromServerFormat = function (t) {\n          for (var e = [], n = \"\", r = 0, i = function () {\n            if (0 === n.length) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid field path (\" + t + \"). Paths must not be empty, begin with '.', end with '.', or contain '..'\");\n            e.push(n), n = \"\";\n          }, o = !1; r < t.length;) {\n            var a = t[r];\n\n            if (\"\\\\\" === a) {\n              if (r + 1 === t.length) throw new xr(Lr.INVALID_ARGUMENT, \"Path has trailing escape character: \" + t);\n              var s = t[r + 1];\n              if (\"\\\\\" !== s && \".\" !== s && \"`\" !== s) throw new xr(Lr.INVALID_ARGUMENT, \"Path has invalid escape sequence: \" + t);\n              n += s, r += 2;\n            } else \"`\" === a ? o = !o : \".\" !== a || o ? n += a : i(), r++;\n          }\n\n          if (i(), o) throw new xr(Lr.INVALID_ARGUMENT, \"Unterminated ` in path: \" + t);\n          return new u(e);\n        }, u.EMPTY_PATH = new u([]), u;\n      }(Si),\n          Di = function () {\n        function e(t) {\n          this.path = t, Or(e.isDocumentKey(t), \"Invalid DocumentKey with an odd number of segments: \" + t.toArray().join(\"/\"));\n        }\n\n        return e.prototype.hasCollectionId = function (t) {\n          return 2 <= this.path.length && this.path.get(this.path.length - 2) === t;\n        }, e.prototype.isEqual = function (t) {\n          return null !== t && 0 === Ti.comparator(this.path, t.path);\n        }, e.prototype.toString = function () {\n          return this.path.toString();\n        }, e.comparator = function (t, e) {\n          return Ti.comparator(t.path, e.path);\n        }, e.isDocumentKey = function (t) {\n          return t.length % 2 == 0;\n        }, e.fromSegments = function (t) {\n          return new e(new Ti(t.slice()));\n        }, e.fromPathString = function (t) {\n          return new e(Ti.fromString(t));\n        }, e.EMPTY = new e(new Ti([])), e;\n      }(),\n          Ni = function () {\n        var n = this;\n        this.promise = new Promise(function (t, e) {\n          n.resolve = t, n.reject = e;\n        });\n      };\n\n      (di = pi || (pi = {})).All = \"all\", di.ListenStreamIdle = \"listen_stream_idle\", di.ListenStreamConnectionBackoff = \"listen_stream_connection_backoff\", di.WriteStreamIdle = \"write_stream_idle\", di.WriteStreamConnectionBackoff = \"write_stream_connection_backoff\", di.OnlineStateTimeout = \"online_state_timeout\", di.ClientMetadataRefresh = \"client_metadata_refresh\", di.LruGarbageCollection = \"lru_garbage_collection\";\n\n      var Ai = function () {\n        function a(t, e, n, r, i) {\n          this.asyncQueue = t, this.timerId = e, this.targetTimeMs = n, this.op = r, this.removalCallback = i, this.deferred = new Ni(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.catch = this.deferred.promise.catch.bind(this.deferred.promise), this.deferred.promise.catch(function (t) {});\n        }\n\n        return a.createAndSchedule = function (t, e, n, r, i) {\n          var o = new a(t, e, Date.now() + n, r, i);\n          return o.start(n), o;\n        }, a.prototype.start = function (t) {\n          var e = this;\n          this.timerHandle = setTimeout(function () {\n            return e.handleDelayElapsed();\n          }, t);\n        }, a.prototype.skipDelay = function () {\n          return this.handleDelayElapsed();\n        }, a.prototype.cancel = function (t) {\n          null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new xr(Lr.CANCELLED, \"Operation cancelled\" + (t ? \": \" + t : \"\"))));\n        }, a.prototype.handleDelayElapsed = function () {\n          var e = this;\n          this.asyncQueue.enqueueAndForget(function () {\n            return null !== e.timerHandle ? (e.clearTimeout(), e.op().then(function (t) {\n              return e.deferred.resolve(t);\n            })) : Promise.resolve();\n          });\n        }, a.prototype.clearTimeout = function () {\n          null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);\n        }, a;\n      }(),\n          ki = function () {\n        function t() {\n          this.tail = Promise.resolve(), this.delayedOperations = [], this.operationInProgress = !1;\n        }\n\n        return t.prototype.enqueueAndForget = function (t) {\n          this.enqueue(t);\n        }, t.prototype.enqueue = function (t) {\n          var n = this;\n          this.verifyNotFailed();\n          var e = this.tail.then(function () {\n            return n.operationInProgress = !0, t().catch(function (t) {\n              n.failure = t, n.operationInProgress = !1;\n              var e = t.stack || t.message || \"\";\n              throw kr(\"INTERNAL UNHANDLED ERROR: \", e), e.indexOf(\"Firestore Test Simulated Error\") < 0 && setTimeout(function () {\n                throw t;\n              }, 0), t;\n            }).then(function (t) {\n              return n.operationInProgress = !1, t;\n            });\n          });\n          return this.tail = e;\n        }, t.prototype.enqueueAfterDelay = function (t, e, n) {\n          var r = this;\n          this.verifyNotFailed(), Or(0 <= e, \"Attempted to schedule an operation with a negative delay of \" + e), Or(!this.containsDelayedOperation(t), \"Attempted to schedule multiple operations with timer id \" + t + \".\");\n          var i = Ai.createAndSchedule(this, t, e, n, function (t) {\n            return r.removeDelayedOperation(t);\n          });\n          return this.delayedOperations.push(i), i;\n        }, t.prototype.verifyNotFailed = function () {\n          this.failure && Mr(\"AsyncQueue is already failed: \" + (this.failure.stack || this.failure.message));\n        }, t.prototype.verifyOperationInProgress = function () {\n          Or(this.operationInProgress, \"verifyOpInProgress() called when no op in progress on this queue.\");\n        }, t.prototype.drain = function () {\n          return this.enqueue(function () {\n            return Promise.resolve();\n          });\n        }, t.prototype.containsDelayedOperation = function (t) {\n          for (var e = 0, n = this.delayedOperations; e < n.length; e++) {\n            if (n[e].timerId === t) return !0;\n          }\n\n          return !1;\n        }, t.prototype.runDelayedOperationsEarly = function (r) {\n          var i = this;\n          return this.drain().then(function () {\n            Or(r === pi.All || i.containsDelayedOperation(r), \"Attempted to drain to missing operation \" + r), i.delayedOperations.sort(function (t, e) {\n              return t.targetTimeMs - e.targetTimeMs;\n            });\n\n            for (var t = 0, e = i.delayedOperations; t < e.length; t++) {\n              var n = e[t];\n              if (n.skipDelay(), r !== pi.All && n.timerId === r) break;\n            }\n\n            return i.drain();\n          });\n        }, t.prototype.removeDelayedOperation = function (t) {\n          var e = this.delayedOperations.indexOf(t);\n          Or(0 <= e, \"Delayed operation not found.\"), this.delayedOperations.splice(e, 1);\n        }, t;\n      }(),\n          Ri = \"\u0001\",\n          Mi = \"\u0001\",\n          Oi = \"\u0010\",\n          _i = \"\u0011\";\n\n      function Pi(t) {\n        for (var e = \"\", n = 0; n < t.length; n++) 0 < e.length && (e = xi(e)), e = Li(t.get(n), e);\n\n        return xi(e);\n      }\n\n      function Li(t, e) {\n        for (var n = e, r = t.length, i = 0; i < r; i++) {\n          var o = t.charAt(i);\n\n          switch (o) {\n            case \"\\0\":\n              n += Ri + Oi;\n              break;\n\n            case Ri:\n              n += Ri + _i;\n              break;\n\n            default:\n              n += o;\n          }\n        }\n\n        return n;\n      }\n\n      function xi(t) {\n        return t + Ri + Mi;\n      }\n\n      function qi(t) {\n        var e = t.length;\n        if (Or(2 <= e, \"Invalid path \" + t), 2 === e) return Or(t.charAt(0) === Ri && t.charAt(1) === Mi, \"Non-empty path \" + t + \" had length 2\"), Ti.EMPTY_PATH;\n\n        for (var n = e - 2, r = [], i = \"\", o = 0; o < e;) {\n          var a = t.indexOf(Ri, o);\n\n          switch ((a < 0 || n < a) && Mr('Invalid encoded resource path: \"' + t + '\"'), t.charAt(a + 1)) {\n            case Mi:\n              var s = t.substring(o, a),\n                  u = void 0;\n              0 === i.length ? u = s : (u = i += s, i = \"\"), r.push(u);\n              break;\n\n            case Oi:\n              i += t.substring(o, a), i += \"\\0\";\n              break;\n\n            case _i:\n              i += t.substring(o, a + 1);\n              break;\n\n            default:\n              Mr('Invalid encoded resource path: \"' + t + '\"');\n          }\n\n          o = a + 2;\n        }\n\n        return new Ti(r);\n      }\n\n      var Fi = function () {\n        function n(t, e) {\n          if (this.seconds = t, (this.nanoseconds = e) < 0) throw new xr(Lr.INVALID_ARGUMENT, \"Timestamp nanoseconds out of range: \" + e);\n          if (1e9 <= e) throw new xr(Lr.INVALID_ARGUMENT, \"Timestamp nanoseconds out of range: \" + e);\n          if (t < -62135596800) throw new xr(Lr.INVALID_ARGUMENT, \"Timestamp seconds out of range: \" + t);\n          if (253402300800 <= t) throw new xr(Lr.INVALID_ARGUMENT, \"Timestamp seconds out of range: \" + t);\n        }\n\n        return n.now = function () {\n          return n.fromMillis(Date.now());\n        }, n.fromDate = function (t) {\n          return n.fromMillis(t.getTime());\n        }, n.fromMillis = function (t) {\n          var e = Math.floor(t / 1e3);\n          return new n(e, 1e6 * (t - 1e3 * e));\n        }, n.prototype.toDate = function () {\n          return new Date(this.toMillis());\n        }, n.prototype.toMillis = function () {\n          return 1e3 * this.seconds + this.nanoseconds / 1e6;\n        }, n.prototype._compareTo = function (t) {\n          return this.seconds === t.seconds ? ui(this.nanoseconds, t.nanoseconds) : ui(this.seconds, t.seconds);\n        }, n.prototype.isEqual = function (t) {\n          return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds;\n        }, n.prototype.toString = function () {\n          return \"Timestamp(seconds=\" + this.seconds + \", nanoseconds=\" + this.nanoseconds + \")\";\n        }, n;\n      }(),\n          Vi = function () {\n        function n(t) {\n          this.timestamp = t;\n        }\n\n        return n.fromMicroseconds = function (t) {\n          var e = Math.floor(t / 1e6);\n          return new n(new Fi(e, t % 1e6 * 1e3));\n        }, n.fromTimestamp = function (t) {\n          return new n(t);\n        }, n.forDeletedDoc = function () {\n          return n.MIN;\n        }, n.prototype.compareTo = function (t) {\n          return this.timestamp._compareTo(t.timestamp);\n        }, n.prototype.isEqual = function (t) {\n          return this.timestamp.isEqual(t.timestamp);\n        }, n.prototype.toMicroseconds = function () {\n          return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;\n        }, n.prototype.toString = function () {\n          return \"SnapshotVersion(\" + this.timestamp.toString() + \")\";\n        }, n.prototype.toTimestamp = function () {\n          return this.timestamp;\n        }, n.MIN = new n(new Fi(0, 0)), n;\n      }(),\n          Ui = function () {\n        function n(t, e) {\n          this.comparator = t, this.root = e || Qi.EMPTY;\n        }\n\n        return n.prototype.insert = function (t, e) {\n          return new n(this.comparator, this.root.insert(t, e, this.comparator).copy(null, null, Qi.BLACK, null, null));\n        }, n.prototype.remove = function (t) {\n          return new n(this.comparator, this.root.remove(t, this.comparator).copy(null, null, Qi.BLACK, null, null));\n        }, n.prototype.get = function (t) {\n          for (var e = this.root; !e.isEmpty();) {\n            var n = this.comparator(t, e.key);\n            if (0 === n) return e.value;\n            n < 0 ? e = e.left : 0 < n && (e = e.right);\n          }\n\n          return null;\n        }, n.prototype.indexOf = function (t) {\n          for (var e = 0, n = this.root; !n.isEmpty();) {\n            var r = this.comparator(t, n.key);\n            if (0 === r) return e + n.left.size;\n            n = r < 0 ? n.left : (e += n.left.size + 1, n.right);\n          }\n\n          return -1;\n        }, n.prototype.isEmpty = function () {\n          return this.root.isEmpty();\n        }, Object.defineProperty(n.prototype, \"size\", {\n          get: function () {\n            return this.root.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), n.prototype.minKey = function () {\n          return this.root.minKey();\n        }, n.prototype.maxKey = function () {\n          return this.root.maxKey();\n        }, n.prototype.inorderTraversal = function (t) {\n          return this.root.inorderTraversal(t);\n        }, n.prototype.forEach = function (n) {\n          this.inorderTraversal(function (t, e) {\n            return n(t, e), !1;\n          });\n        }, n.prototype.toString = function () {\n          var n = [];\n          return this.inorderTraversal(function (t, e) {\n            return n.push(t + \":\" + e), !1;\n          }), \"{\" + n.join(\", \") + \"}\";\n        }, n.prototype.reverseTraversal = function (t) {\n          return this.root.reverseTraversal(t);\n        }, n.prototype.getIterator = function () {\n          return new Bi(this.root, null, this.comparator, !1);\n        }, n.prototype.getIteratorFrom = function (t) {\n          return new Bi(this.root, t, this.comparator, !1);\n        }, n.prototype.getReverseIterator = function () {\n          return new Bi(this.root, null, this.comparator, !0);\n        }, n.prototype.getReverseIteratorFrom = function (t) {\n          return new Bi(this.root, t, this.comparator, !0);\n        }, n;\n      }(),\n          Bi = function () {\n        function t(t, e, n, r) {\n          this.isReverse = r, this.nodeStack = [];\n\n          for (var i = 1; !t.isEmpty();) if (i = e ? n(t.key, e) : 1, r && (i *= -1), i < 0) t = this.isReverse ? t.left : t.right;else {\n            if (0 === i) {\n              this.nodeStack.push(t);\n              break;\n            }\n\n            this.nodeStack.push(t), t = this.isReverse ? t.right : t.left;\n          }\n        }\n\n        return t.prototype.getNext = function () {\n          Or(0 < this.nodeStack.length, \"getNext() called on iterator when hasNext() is false.\");\n          var t = this.nodeStack.pop(),\n              e = {\n            key: t.key,\n            value: t.value\n          };\n          if (this.isReverse) for (t = t.left; !t.isEmpty();) this.nodeStack.push(t), t = t.right;else for (t = t.right; !t.isEmpty();) this.nodeStack.push(t), t = t.left;\n          return e;\n        }, t.prototype.hasNext = function () {\n          return 0 < this.nodeStack.length;\n        }, t.prototype.peek = function () {\n          if (0 === this.nodeStack.length) return null;\n          var t = this.nodeStack[this.nodeStack.length - 1];\n          return {\n            key: t.key,\n            value: t.value\n          };\n        }, t;\n      }(),\n          Qi = function () {\n        function o(t, e, n, r, i) {\n          this.key = t, this.value = e, this.color = null != n ? n : o.RED, this.left = null != r ? r : o.EMPTY, this.right = null != i ? i : o.EMPTY, this.size = this.left.size + 1 + this.right.size;\n        }\n\n        return o.prototype.copy = function (t, e, n, r, i) {\n          return new o(null != t ? t : this.key, null != e ? e : this.value, null != n ? n : this.color, null != r ? r : this.left, null != i ? i : this.right);\n        }, o.prototype.isEmpty = function () {\n          return !1;\n        }, o.prototype.inorderTraversal = function (t) {\n          return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t);\n        }, o.prototype.reverseTraversal = function (t) {\n          return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t);\n        }, o.prototype.min = function () {\n          return this.left.isEmpty() ? this : this.left.min();\n        }, o.prototype.minKey = function () {\n          return this.min().key;\n        }, o.prototype.maxKey = function () {\n          return this.right.isEmpty() ? this.key : this.right.maxKey();\n        }, o.prototype.insert = function (t, e, n) {\n          var r = this,\n              i = n(t, r.key);\n          return (r = i < 0 ? r.copy(null, null, null, r.left.insert(t, e, n), null) : 0 === i ? r.copy(null, e, null, null, null) : r.copy(null, null, null, null, r.right.insert(t, e, n))).fixUp();\n        }, o.prototype.removeMin = function () {\n          if (this.left.isEmpty()) return o.EMPTY;\n          var t = this;\n          return t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()), (t = t.copy(null, null, null, t.left.removeMin(), null)).fixUp();\n        }, o.prototype.remove = function (t, e) {\n          var n,\n              r = this;\n          if (e(t, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(t, e), null);else {\n            if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), 0 === e(t, r.key)) {\n              if (r.right.isEmpty()) return o.EMPTY;\n              n = r.right.min(), r = r.copy(n.key, n.value, null, null, r.right.removeMin());\n            }\n\n            r = r.copy(null, null, null, null, r.right.remove(t, e));\n          }\n          return r.fixUp();\n        }, o.prototype.isRed = function () {\n          return this.color;\n        }, o.prototype.fixUp = function () {\n          var t = this;\n          return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t;\n        }, o.prototype.moveRedLeft = function () {\n          var t = this.colorFlip();\n          return t.right.left.isRed() && (t = (t = (t = t.copy(null, null, null, null, t.right.rotateRight())).rotateLeft()).colorFlip()), t;\n        }, o.prototype.moveRedRight = function () {\n          var t = this.colorFlip();\n          return t.left.left.isRed() && (t = (t = t.rotateRight()).colorFlip()), t;\n        }, o.prototype.rotateLeft = function () {\n          var t = this.copy(null, null, o.RED, null, this.right.left);\n          return this.right.copy(null, null, this.color, t, null);\n        }, o.prototype.rotateRight = function () {\n          var t = this.copy(null, null, o.RED, this.left.right, null);\n          return this.left.copy(null, null, this.color, null, t);\n        }, o.prototype.colorFlip = function () {\n          var t = this.left.copy(null, null, !this.left.color, null, null),\n              e = this.right.copy(null, null, !this.right.color, null, null);\n          return this.copy(null, null, !this.color, t, e);\n        }, o.prototype.checkMaxDepth = function () {\n          var t = this.check();\n          return Math.pow(2, t) <= this.size + 1;\n        }, o.prototype.check = function () {\n          if (this.isRed() && this.left.isRed()) throw Mr(\"Red node has red child(\" + this.key + \",\" + this.value + \")\");\n          if (this.right.isRed()) throw Mr(\"Right child of (\" + this.key + \",\" + this.value + \") is red\");\n          var t = this.left.check();\n          if (t !== this.right.check()) throw Mr(\"Black depths differ\");\n          return t + (this.isRed() ? 0 : 1);\n        }, o.EMPTY = null, o.RED = !0, o.BLACK = !1, o;\n      }(),\n          Ki = function () {\n        function t() {\n          this.size = 0;\n        }\n\n        return t.prototype.copy = function (t, e, n, r, i) {\n          return this;\n        }, t.prototype.insert = function (t, e, n) {\n          return new Qi(t, e);\n        }, t.prototype.remove = function (t, e) {\n          return this;\n        }, t.prototype.isEmpty = function () {\n          return !0;\n        }, t.prototype.inorderTraversal = function (t) {\n          return !1;\n        }, t.prototype.reverseTraversal = function (t) {\n          return !1;\n        }, t.prototype.minKey = function () {\n          return null;\n        }, t.prototype.maxKey = function () {\n          return null;\n        }, t.prototype.isRed = function () {\n          return !1;\n        }, t.prototype.checkMaxDepth = function () {\n          return !0;\n        }, t.prototype.check = function () {\n          return 0;\n        }, t;\n      }();\n\n      Qi.EMPTY = new Ki();\n\n      var ji = function () {\n        function o(t) {\n          this.comparator = t, this.data = new Ui(this.comparator);\n        }\n\n        return o.fromMapKeys = function (t) {\n          var e = new o(t.comparator);\n          return t.forEach(function (t) {\n            e = e.add(t);\n          }), e;\n        }, o.prototype.has = function (t) {\n          return null !== this.data.get(t);\n        }, o.prototype.first = function () {\n          return this.data.minKey();\n        }, o.prototype.last = function () {\n          return this.data.maxKey();\n        }, Object.defineProperty(o.prototype, \"size\", {\n          get: function () {\n            return this.data.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), o.prototype.indexOf = function (t) {\n          return this.data.indexOf(t);\n        }, o.prototype.forEach = function (n) {\n          this.data.inorderTraversal(function (t, e) {\n            return n(t), !1;\n          });\n        }, o.prototype.forEachInRange = function (t, e) {\n          for (var n = this.data.getIteratorFrom(t[0]); n.hasNext();) {\n            var r = n.getNext();\n            if (0 <= this.comparator(r.key, t[1])) return;\n            e(r.key);\n          }\n        }, o.prototype.forEachWhile = function (t, e) {\n          var n;\n\n          for (n = void 0 !== e ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext();) {\n            if (!t(n.getNext().key)) return;\n          }\n        }, o.prototype.firstAfterOrEqual = function (t) {\n          var e = this.data.getIteratorFrom(t);\n          return e.hasNext() ? e.getNext().key : null;\n        }, o.prototype.getIterator = function () {\n          return new Gi(this.data.getIterator());\n        }, o.prototype.getIteratorFrom = function (t) {\n          return new Gi(this.data.getIteratorFrom(t));\n        }, o.prototype.add = function (t) {\n          return this.copy(this.data.remove(t).insert(t, !0));\n        }, o.prototype.delete = function (t) {\n          return this.has(t) ? this.copy(this.data.remove(t)) : this;\n        }, o.prototype.isEmpty = function () {\n          return this.data.isEmpty();\n        }, o.prototype.unionWith = function (t) {\n          var e = this;\n          return t.forEach(function (t) {\n            e = e.add(t);\n          }), e;\n        }, o.prototype.isEqual = function (t) {\n          if (!(t instanceof o)) return !1;\n          if (this.size !== t.size) return !1;\n\n          for (var e = this.data.getIterator(), n = t.data.getIterator(); e.hasNext();) {\n            var r = e.getNext().key,\n                i = n.getNext().key;\n            if (0 !== this.comparator(r, i)) return !1;\n          }\n\n          return !0;\n        }, o.prototype.toArray = function () {\n          var e = [];\n          return this.forEach(function (t) {\n            e.push(t);\n          }), e;\n        }, o.prototype.toString = function () {\n          var e = [];\n          return this.forEach(function (t) {\n            return e.push(t);\n          }), \"SortedSet(\" + e.toString() + \")\";\n        }, o.prototype.copy = function (t) {\n          var e = new o(this.comparator);\n          return e.data = t, e;\n        }, o;\n      }(),\n          Gi = function () {\n        function t(t) {\n          this.iter = t;\n        }\n\n        return t.prototype.getNext = function () {\n          return this.iter.getNext().key;\n        }, t.prototype.hasNext = function () {\n          return this.iter.hasNext();\n        }, t;\n      }(),\n          Wi = new Ui(Di.comparator);\n\n      function zi() {\n        return Wi;\n      }\n\n      function Hi() {\n        return zi();\n      }\n\n      var Yi = new Ui(Di.comparator);\n\n      function Xi() {\n        return Yi;\n      }\n\n      var Ji = new Ui(Di.comparator);\n\n      function $i() {\n        return Ji;\n      }\n\n      var Zi = new ji(Di.comparator);\n\n      function to() {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        for (var n = Zi, r = 0, i = t; r < i.length; r++) {\n          var o = i[r];\n          n = n.add(o);\n        }\n\n        return n;\n      }\n\n      var eo = new ji(ui);\n\n      function no() {\n        return eo;\n      }\n\n      var ro = function () {\n        function t(t, e, n, r) {\n          this.batchId = t, this.localWriteTime = e, this.baseMutations = n, Or(0 < (this.mutations = r).length, \"Cannot create an empty mutation batch\");\n        }\n\n        return t.prototype.applyToRemoteDocument = function (t, e, n) {\n          e && Or(e.key.isEqual(t), \"applyToRemoteDocument: key \" + t + \" should match maybeDoc key\\n        \" + e.key);\n          var r = n.mutationResults;\n          Or(r.length === this.mutations.length, \"Mismatch between mutations length\\n      (\" + this.mutations.length + \") and mutation results length\\n      (\" + r.length + \").\");\n\n          for (var i = 0; i < this.mutations.length; i++) {\n            var o = this.mutations[i];\n\n            if (o.key.isEqual(t)) {\n              var a = r[i];\n              e = o.applyToRemoteDocument(e, a);\n            }\n          }\n\n          return e;\n        }, t.prototype.applyToLocalView = function (t, e) {\n          e && Or(e.key.isEqual(t), \"applyToLocalDocument: key \" + t + \" should match maybeDoc key\\n        \" + e.key);\n\n          for (var n = 0, r = this.baseMutations; n < r.length; n++) {\n            (s = r[n]).key.isEqual(t) && (e = s.applyToLocalView(e, e, this.localWriteTime));\n          }\n\n          for (var i = e, o = 0, a = this.mutations; o < a.length; o++) {\n            var s;\n            (s = a[o]).key.isEqual(t) && (e = s.applyToLocalView(e, i, this.localWriteTime));\n          }\n\n          return e;\n        }, t.prototype.applyToLocalDocumentSet = function (n) {\n          var r = this,\n              i = n;\n          return this.mutations.forEach(function (t) {\n            var e = r.applyToLocalView(t.key, n.get(t.key));\n            e && (i = i.insert(t.key, e));\n          }), i;\n        }, t.prototype.keys = function () {\n          return this.mutations.reduce(function (t, e) {\n            return t.add(e.key);\n          }, to());\n        }, t.prototype.isEqual = function (t) {\n          return this.batchId === t.batchId && ci(this.mutations, t.mutations) && ci(this.baseMutations, t.baseMutations);\n        }, t;\n      }(),\n          io = function () {\n        function s(t, e, n, r, i) {\n          this.batch = t, this.commitVersion = e, this.mutationResults = n, this.streamToken = r, this.docVersions = i;\n        }\n\n        return s.from = function (t, e, n, r) {\n          Or(t.mutations.length === n.length, \"Mutations sent \" + t.mutations.length + \" must equal results received \" + n.length);\n\n          for (var i = $i(), o = t.mutations, a = 0; a < o.length; a++) i = i.insert(o[a].key, n[a].version);\n\n          return new s(t, e, n, r, i);\n        }, s;\n      }(),\n          oo = function () {\n        function a(t) {\n          var e = this;\n          this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, t(function (t) {\n            e.isDone = !0, e.result = t, e.nextCallback && e.nextCallback(t);\n          }, function (t) {\n            e.isDone = !0, e.error = t, e.catchCallback && e.catchCallback(t);\n          });\n        }\n\n        return a.prototype.catch = function (t) {\n          return this.next(void 0, t);\n        }, a.prototype.next = function (r, i) {\n          var o = this;\n          return this.callbackAttached && Mr(\"Called next() or catch() twice for PersistencePromise\"), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(i, this.error) : this.wrapSuccess(r, this.result) : new a(function (e, n) {\n            o.nextCallback = function (t) {\n              o.wrapSuccess(r, t).next(e, n);\n            }, o.catchCallback = function (t) {\n              o.wrapFailure(i, t).next(e, n);\n            };\n          });\n        }, a.prototype.toPromise = function () {\n          var n = this;\n          return new Promise(function (t, e) {\n            n.next(t, e);\n          });\n        }, a.prototype.wrapUserFunction = function (t) {\n          try {\n            var e = t();\n            return e instanceof a ? e : a.resolve(e);\n          } catch (t) {\n            return a.reject(t);\n          }\n        }, a.prototype.wrapSuccess = function (t, e) {\n          return t ? this.wrapUserFunction(function () {\n            return t(e);\n          }) : a.resolve(e);\n        }, a.prototype.wrapFailure = function (t, e) {\n          return t ? this.wrapUserFunction(function () {\n            return t(e);\n          }) : a.reject(e);\n        }, a.resolve = function (n) {\n          return new a(function (t, e) {\n            t(n);\n          });\n        }, a.reject = function (n) {\n          return new a(function (t, e) {\n            e(n);\n          });\n        }, a.waitFor = function (t) {\n          return new a(function (e, n) {\n            var r = 0,\n                i = 0,\n                o = !1;\n            t.forEach(function (t) {\n              ++r, t.next(function () {\n                ++i, o && i === r && e();\n              }, function (t) {\n                return n(t);\n              });\n            }), o = !0, i === r && e();\n          });\n        }, a.or = function (t) {\n          for (var n = a.resolve(!1), e = function (e) {\n            n = n.next(function (t) {\n              return t ? a.resolve(t) : e();\n            });\n          }, r = 0, i = t; r < i.length; r++) {\n            e(i[r]);\n          }\n\n          return n;\n        }, a.forEach = function (t, n) {\n          var r = this,\n              i = [];\n          return t.forEach(function (t, e) {\n            i.push(n.call(r, t, e));\n          }), this.waitFor(i);\n        }, a;\n      }(),\n          ao = function () {\n        function i(t, e, n, r) {\n          this.userId = t, this.serializer = e, this.indexManager = n, this.referenceDelegate = r, this.documentKeysByBatchId = {};\n        }\n\n        return i.forUser = function (t, e, n, r) {\n          return Or(\"\" !== t.uid, \"UserID must not be an empty string.\"), new i(t.isAuthenticated() ? t.uid : \"\", e, n, r);\n        }, i.prototype.checkEmpty = function (t) {\n          var r = !0,\n              e = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\n          return ho(t).iterate({\n            index: Jo.userMutationsIndex,\n            range: e\n          }, function (t, e, n) {\n            r = !1, n.done();\n          }).next(function () {\n            return r;\n          });\n        }, i.prototype.acknowledgeBatch = function (e, t, n) {\n          return this.getMutationQueueMetadata(e).next(function (t) {\n            return t.lastStreamToken = co(n), fo(e).put(t);\n          });\n        }, i.prototype.getLastStreamToken = function (t) {\n          return this.getMutationQueueMetadata(t).next(function (t) {\n            return t.lastStreamToken;\n          });\n        }, i.prototype.setLastStreamToken = function (e, n) {\n          return this.getMutationQueueMetadata(e).next(function (t) {\n            return t.lastStreamToken = co(n), fo(e).put(t);\n          });\n        }, i.prototype.addMutationBatch = function (u, c, h, l) {\n          var f = this,\n              p = lo(u),\n              d = ho(u);\n          return d.add({}).next(function (t) {\n            Or(\"number\" == typeof t, \"Auto-generated key is not a number\");\n            var e = new ro(t, c, h, l),\n                n = f.serializer.toDbMutationBatch(f.userId, e);\n            f.documentKeysByBatchId[t] = e.keys();\n\n            for (var r = [], i = 0, o = l; i < o.length; i++) {\n              var a = o[i],\n                  s = $o.key(f.userId, a.key.path, t);\n              r.push(d.put(n)), r.push(p.put(s, $o.PLACEHOLDER)), r.push(f.indexManager.addToCollectionParentIndex(u, a.key.path.popLast()));\n            }\n\n            return oo.waitFor(r).next(function () {\n              return e;\n            });\n          });\n        }, i.prototype.lookupMutationBatch = function (t, e) {\n          var n = this;\n          return ho(t).get(e).next(function (t) {\n            return t ? (Or(t.userId === n.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + e), n.serializer.fromDbMutationBatch(t)) : null;\n          });\n        }, i.prototype.lookupMutationKeys = function (t, n) {\n          var r = this;\n          return this.documentKeysByBatchId[n] ? oo.resolve(this.documentKeysByBatchId[n]) : this.lookupMutationBatch(t, n).next(function (t) {\n            if (t) {\n              var e = t.keys();\n              return r.documentKeysByBatchId[n] = e;\n            }\n\n            return null;\n          });\n        }, i.prototype.getNextMutationBatchAfterBatchId = function (t, e) {\n          var r = this,\n              i = e + 1,\n              n = IDBKeyRange.lowerBound([this.userId, i]),\n              o = null;\n          return ho(t).iterate({\n            index: Jo.userMutationsIndex,\n            range: n\n          }, function (t, e, n) {\n            e.userId === r.userId && (Or(e.batchId >= i, \"Should have found mutation after \" + i), o = r.serializer.fromDbMutationBatch(e)), n.done();\n          }).next(function () {\n            return o;\n          });\n        }, i.prototype.getAllMutationBatches = function (t) {\n          var e = this,\n              n = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);\n          return ho(t).loadAll(Jo.userMutationsIndex, n).next(function (t) {\n            return t.map(function (t) {\n              return e.serializer.fromDbMutationBatch(t);\n            });\n          });\n        }, i.prototype.getAllMutationBatchesAffectingDocumentKey = function (s, u) {\n          var c = this,\n              t = $o.prefixForPath(this.userId, u.path),\n              e = IDBKeyRange.lowerBound(t),\n              h = [];\n          return lo(s).iterate({\n            range: e\n          }, function (e, t, n) {\n            var r = e[0],\n                i = e[1],\n                o = e[2],\n                a = qi(i);\n            if (r === c.userId && u.path.isEqual(a)) return ho(s).get(o).next(function (t) {\n              if (!t) throw Mr(\"Dangling document-mutation reference found: \" + e + \" which points to \" + o);\n              Or(t.userId === c.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + o), h.push(c.serializer.fromDbMutationBatch(t));\n            });\n            n.done();\n          }).next(function () {\n            return h;\n          });\n        }, i.prototype.getAllMutationBatchesAffectingDocumentKeys = function (r, t) {\n          var u = this,\n              c = new ji(ui),\n              i = [];\n          return t.forEach(function (s) {\n            var t = $o.prefixForPath(u.userId, s.path),\n                e = IDBKeyRange.lowerBound(t),\n                n = lo(r).iterate({\n              range: e\n            }, function (t, e, n) {\n              var r = t[0],\n                  i = t[1],\n                  o = t[2],\n                  a = qi(i);\n              r === u.userId && s.path.isEqual(a) ? c = c.add(o) : n.done();\n            });\n            i.push(n);\n          }), oo.waitFor(i).next(function () {\n            return u.lookupMutationBatches(r, c);\n          });\n        }, i.prototype.getAllMutationBatchesAffectingQuery = function (t, e) {\n          var s = this;\n          Or(!e.isDocumentQuery(), \"Document queries shouldn't go down this path\"), Or(!e.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n          var u = e.path,\n              c = u.length + 1,\n              n = $o.prefixForPath(this.userId, u),\n              r = IDBKeyRange.lowerBound(n),\n              h = new ji(ui);\n          return lo(t).iterate({\n            range: r\n          }, function (t, e, n) {\n            var r = t[0],\n                i = t[1],\n                o = t[2],\n                a = qi(i);\n            r === s.userId && u.isPrefixOf(a) ? a.length === c && (h = h.add(o)) : n.done();\n          }).next(function () {\n            return s.lookupMutationBatches(t, h);\n          });\n        }, i.prototype.lookupMutationBatches = function (t, e) {\n          var n = this,\n              r = [],\n              i = [];\n          return e.forEach(function (e) {\n            i.push(ho(t).get(e).next(function (t) {\n              if (null === t) throw Mr(\"Dangling document-mutation reference found, which points to \" + e);\n              Or(t.userId === n.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + e), r.push(n.serializer.fromDbMutationBatch(t));\n            }));\n          }), oo.waitFor(i).next(function () {\n            return r;\n          });\n        }, i.prototype.removeMutationBatch = function (e, n) {\n          var r = this;\n          return uo(e.simpleDbTransaction, this.userId, n).next(function (t) {\n            return r.removeCachedMutationKeys(n.batchId), oo.forEach(t, function (t) {\n              return r.referenceDelegate.removeMutationReference(e, t);\n            });\n          });\n        }, i.prototype.removeCachedMutationKeys = function (t) {\n          delete this.documentKeysByBatchId[t];\n        }, i.prototype.performConsistencyCheck = function (n) {\n          var o = this;\n          return this.checkEmpty(n).next(function (t) {\n            if (!t) return oo.resolve();\n            var e = IDBKeyRange.lowerBound($o.prefixForUser(o.userId)),\n                i = [];\n            return lo(n).iterate({\n              range: e\n            }, function (t, e, n) {\n              if (t[0] === o.userId) {\n                var r = qi(t[1]);\n                i.push(r);\n              } else n.done();\n            }).next(function () {\n              Or(0 === i.length, \"Document leak -- detected dangling mutation references when queue is empty. Dangling keys: \" + i.map(function (t) {\n                return t.canonicalString();\n              }));\n            });\n          });\n        }, i.prototype.containsKey = function (t, e) {\n          return so(t, this.userId, e);\n        }, i.prototype.getMutationQueueMetadata = function (t) {\n          var e = this;\n          return fo(t).get(this.userId).next(function (t) {\n            return t || new Xo(e.userId, -1, \"\");\n          });\n        }, i;\n      }();\n\n      function so(t, o, e) {\n        var n = $o.prefixForPath(o, e.path),\n            a = n[1],\n            r = IDBKeyRange.lowerBound(n),\n            s = !1;\n        return lo(t).iterate({\n          range: r,\n          keysOnly: !0\n        }, function (t, e, n) {\n          var r = t[0],\n              i = t[1];\n          t[2];\n          r === o && i === a && (s = !0), n.done();\n        }).next(function () {\n          return s;\n        });\n      }\n\n      function uo(t, e, n) {\n        var r = t.store(Jo.store),\n            i = t.store($o.store),\n            o = [],\n            a = IDBKeyRange.only(n.batchId),\n            s = 0,\n            u = r.iterate({\n          range: a\n        }, function (t, e, n) {\n          return s++, n.delete();\n        });\n        o.push(u.next(function () {\n          Or(1 === s, \"Dangling document-mutation reference found: Missing batch \" + n.batchId);\n        }));\n\n        for (var c = [], h = 0, l = n.mutations; h < l.length; h++) {\n          var f = l[h],\n              p = $o.key(e, f.key.path, n.batchId);\n          o.push(i.delete(p)), c.push(f.key);\n        }\n\n        return oo.waitFor(o).next(function () {\n          return c;\n        });\n      }\n\n      function co(t) {\n        return t instanceof Uint8Array ? (Or(\"YES\" === process.env.USE_MOCK_PERSISTENCE, \"Persisting non-string stream tokens is only supported with mock persistence.\"), t.toString()) : t;\n      }\n\n      function ho(t) {\n        return Na.getStore(t, Jo.store);\n      }\n\n      function lo(t) {\n        return Na.getStore(t, $o.store);\n      }\n\n      function fo(t) {\n        return Na.getStore(t, Xo.store);\n      }\n\n      var po, mo;\n      (mo = po || (po = {}))[mo.QueryCache = 0] = \"QueryCache\", mo[mo.SyncEngine = 1] = \"SyncEngine\";\n\n      var yo = function () {\n        function t(t, e) {\n          Or((1 & (this.generatorId = t)) === t, \"Generator ID \" + t + \" contains more than 1 reserved bits\"), this.seek(void 0 !== e ? e : this.generatorId);\n        }\n\n        return t.prototype.next = function () {\n          var t = this.nextId;\n          return this.nextId += 2, t;\n        }, t.prototype.after = function (t) {\n          return this.seek(t + 2), this.next();\n        }, t.prototype.seek = function (t) {\n          Or((1 & t) === this.generatorId, \"Cannot supply target ID from different generator ID\"), this.nextId = t;\n        }, t.forQueryCache = function () {\n          return new t(po.QueryCache, 2);\n        }, t.forSyncEngine = function () {\n          return new t(po.SyncEngine);\n        }, t;\n      }(),\n          go = \"SimpleDb\",\n          vo = function () {\n        function s(t) {\n          this.db = t, 12.2 === s.getIOSVersion(a()) && kr(\"Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.\");\n        }\n\n        return s.openOrCreate = function (o, t, a) {\n          return Or(s.isAvailable(), \"IndexedDB not supported in current environment.\"), Ar(go, \"Opening database:\", o), new oo(function (n, r) {\n            var i = window.indexedDB.open(o, t);\n            i.onsuccess = function (t) {\n              var e = t.target.result;\n              n(new s(e));\n            }, i.onblocked = function () {\n              r(new xr(Lr.FAILED_PRECONDITION, \"Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.\"));\n            }, i.onerror = function (t) {\n              var e = t.target.error;\n              \"VersionError\" === e.name ? r(new xr(Lr.FAILED_PRECONDITION, \"A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.\")) : r(e);\n            }, i.onupgradeneeded = function (t) {\n              Ar(go, 'Database \"' + o + '\" requires upgrade from version:', t.oldVersion);\n              var e = t.target.result,\n                  n = new wo(i.transaction);\n              a.createOrUpgrade(e, n, t.oldVersion, Wo).next(function () {\n                Ar(go, \"Database upgrade to version \" + Wo + \" complete\");\n              });\n            };\n          }).toPromise();\n        }, s.delete = function (t) {\n          return Ar(go, \"Removing database:\", t), So(window.indexedDB.deleteDatabase(t)).toPromise();\n        }, s.isAvailable = function () {\n          if (\"undefined\" == typeof window || null == window.indexedDB) return !1;\n          if (void 0 === window.navigator) return \"YES\" === process.env.USE_MOCK_PERSISTENCE;\n          var t = a(),\n              e = s.getIOSVersion(t),\n              n = 0 < e && e < 10,\n              r = s.getAndroidVersion(t),\n              i = 0 < r && r < 4.5;\n          return !(0 < t.indexOf(\"MSIE \") || 0 < t.indexOf(\"Trident/\") || 0 < t.indexOf(\"Edge/\") || n || i);\n        }, s.getStore = function (t, e) {\n          return t.store(e);\n        }, s.getIOSVersion = function (t) {\n          var e = t.match(/i(?:phone|pad|pod) os ([\\d_]+)/i),\n              n = e ? e[1].split(\"_\").slice(0, 2).join(\".\") : \"-1\";\n          return Number(n);\n        }, s.getAndroidVersion = function (t) {\n          var e = t.match(/Android ([\\d.]+)/i),\n              n = e ? e[1].split(\".\").slice(0, 2).join(\".\") : \"-1\";\n          return Number(n);\n        }, s.prototype.setVersionChangeListener = function (e) {\n          this.db.onversionchange = function (t) {\n            return e(t);\n          };\n        }, s.prototype.runTransaction = function (t, e, n) {\n          var r = wo.open(this.db, t, e),\n              i = n(r).catch(function (t) {\n            return r.abort(t), oo.reject(t);\n          }).toPromise();\n          return i.catch(function () {}), r.completionPromise.then(function () {\n            return i;\n          });\n        }, s.prototype.close = function () {\n          this.db.close();\n        }, s;\n      }(),\n          bo = function () {\n        function t(t) {\n          this.dbCursor = t, this.shouldStop = !1, this.nextKey = null;\n        }\n\n        return Object.defineProperty(t.prototype, \"isDone\", {\n          get: function () {\n            return this.shouldStop;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"skipToKey\", {\n          get: function () {\n            return this.nextKey;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"cursor\", {\n          set: function (t) {\n            this.dbCursor = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.done = function () {\n          this.shouldStop = !0;\n        }, t.prototype.skip = function (t) {\n          this.nextKey = t;\n        }, t.prototype.delete = function () {\n          return So(this.dbCursor.delete());\n        }, t;\n      }(),\n          wo = function () {\n        function r(t) {\n          var n = this;\n          this.transaction = t, this.aborted = !1, this.completionDeferred = new Ni(), this.transaction.oncomplete = function () {\n            n.completionDeferred.resolve();\n          }, this.transaction.onabort = function () {\n            t.error ? n.completionDeferred.reject(t.error) : n.completionDeferred.resolve();\n          }, this.transaction.onerror = function (t) {\n            var e = Io(t.target.error);\n            n.completionDeferred.reject(e);\n          };\n        }\n\n        return r.open = function (t, e, n) {\n          return new r(t.transaction(n, e));\n        }, Object.defineProperty(r.prototype, \"completionPromise\", {\n          get: function () {\n            return this.completionDeferred.promise;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), r.prototype.abort = function (t) {\n          t && this.completionDeferred.reject(t), this.aborted || (Ar(go, \"Aborting transaction:\", t ? t.message : \"Client-initiated abort\"), this.aborted = !0, this.transaction.abort());\n        }, r.prototype.store = function (t) {\n          var e = this.transaction.objectStore(t);\n          return Or(!!e, \"Object store not part of transaction: \" + t), new Eo(e);\n        }, r;\n      }(),\n          Eo = function () {\n        function t(t) {\n          this.store = t;\n        }\n\n        return t.prototype.put = function (t, e) {\n          return So(void 0 !== e ? (Ar(go, \"PUT\", this.store.name, t, e), this.store.put(e, t)) : (Ar(go, \"PUT\", this.store.name, \"<auto-key>\", t), this.store.put(t)));\n        }, t.prototype.add = function (t) {\n          return Ar(go, \"ADD\", this.store.name, t, t), So(this.store.add(t));\n        }, t.prototype.get = function (e) {\n          var n = this;\n          return So(this.store.get(e)).next(function (t) {\n            return void 0 === t && (t = null), Ar(go, \"GET\", n.store.name, e, t), t;\n          });\n        }, t.prototype.delete = function (t) {\n          return Ar(go, \"DELETE\", this.store.name, t), So(this.store.delete(t));\n        }, t.prototype.count = function () {\n          return Ar(go, \"COUNT\", this.store.name), So(this.store.count());\n        }, t.prototype.loadAll = function (t, e) {\n          var n = this.cursor(this.options(t, e)),\n              r = [];\n          return this.iterateCursor(n, function (t, e) {\n            r.push(e);\n          }).next(function () {\n            return r;\n          });\n        }, t.prototype.deleteAll = function (t, e) {\n          Ar(go, \"DELETE ALL\", this.store.name);\n          var n = this.options(t, e);\n          n.keysOnly = !1;\n          var r = this.cursor(n);\n          return this.iterateCursor(r, function (t, e, n) {\n            return n.delete();\n          });\n        }, t.prototype.iterate = function (t, e) {\n          var n;\n          e ? n = t : (n = {}, e = t);\n          var r = this.cursor(n);\n          return this.iterateCursor(r, e);\n        }, t.prototype.iterateSerial = function (i) {\n          var t = this.cursor({});\n          return new oo(function (n, r) {\n            t.onerror = function (t) {\n              var e = Io(t.target.error);\n              r(e);\n            }, t.onsuccess = function (t) {\n              var e = t.target.result;\n              e ? i(e.primaryKey, e.value).next(function (t) {\n                t ? e.continue() : n();\n              }) : n();\n            };\n          });\n        }, t.prototype.iterateCursor = function (t, a) {\n          var s = [];\n          return new oo(function (o, e) {\n            t.onerror = function (t) {\n              e(t.target.error);\n            }, t.onsuccess = function (t) {\n              var e = t.target.result;\n\n              if (e) {\n                var n = new bo(e),\n                    r = a(e.primaryKey, e.value, n);\n\n                if (r instanceof oo) {\n                  var i = r.catch(function (t) {\n                    return n.done(), oo.reject(t);\n                  });\n                  s.push(i);\n                }\n\n                n.isDone ? o() : null === n.skipToKey ? e.continue() : e.continue(n.skipToKey);\n              } else o();\n            };\n          }).next(function () {\n            return oo.waitFor(s);\n          });\n        }, t.prototype.options = function (t, e) {\n          var n = void 0;\n          return void 0 !== t && (\"string\" == typeof t ? n = t : (Or(void 0 === e, \"3rd argument must not be defined if 2nd is a range.\"), e = t)), {\n            index: n,\n            range: e\n          };\n        }, t.prototype.cursor = function (t) {\n          var e = \"next\";\n\n          if (t.reverse && (e = \"prev\"), t.index) {\n            var n = this.store.index(t.index);\n            return t.keysOnly ? n.openKeyCursor(t.range, e) : n.openCursor(t.range, e);\n          }\n\n          return this.store.openCursor(t.range, e);\n        }, t;\n      }();\n\n      function So(t) {\n        return new oo(function (n, r) {\n          t.onsuccess = function (t) {\n            var e = t.target.result;\n            n(e);\n          }, t.onerror = function (t) {\n            var e = Io(t.target.error);\n            r(e);\n          };\n        });\n      }\n\n      var To = !1;\n\n      function Io(t) {\n        var e = vo.getIOSVersion(a());\n\n        if (12.2 <= e && e < 13) {\n          var n = \"An internal error was encountered in the Indexed Database server\";\n\n          if (0 <= t.message.indexOf(n)) {\n            var r = new xr(\"internal\", \"IOS_INDEXEDDB_BUG1: IndexedDb has thrown '\" + n + \"'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.\");\n            return To || (To = !0, setTimeout(function () {\n              throw r;\n            }, 0)), r;\n          }\n        }\n\n        return t;\n      }\n\n      var Co = function () {\n        function t(t, e) {\n          this.referenceDelegate = t, this.serializer = e, this.targetIdGenerator = yo.forQueryCache();\n        }\n\n        return t.prototype.allocateTargetId = function (e) {\n          var n = this;\n          return this.retrieveMetadata(e).next(function (t) {\n            return t.highestTargetId = n.targetIdGenerator.after(t.highestTargetId), n.saveMetadata(e, t).next(function () {\n              return t.highestTargetId;\n            });\n          });\n        }, t.prototype.getLastRemoteSnapshotVersion = function (t) {\n          return this.retrieveMetadata(t).next(function (t) {\n            return Vi.fromTimestamp(new Fi(t.lastRemoteSnapshotVersion.seconds, t.lastRemoteSnapshotVersion.nanoseconds));\n          });\n        }, t.prototype.getHighestSequenceNumber = function (t) {\n          return Ao(t.simpleDbTransaction);\n        }, t.prototype.setTargetsMetadata = function (e, n, r) {\n          var i = this;\n          return this.retrieveMetadata(e).next(function (t) {\n            return t.highestListenSequenceNumber = n, r && (t.lastRemoteSnapshotVersion = r.toTimestamp()), n > t.highestListenSequenceNumber && (t.highestListenSequenceNumber = n), i.saveMetadata(e, t);\n          });\n        }, t.prototype.addQueryData = function (e, n) {\n          var r = this;\n          return this.saveQueryData(e, n).next(function () {\n            return r.retrieveMetadata(e).next(function (t) {\n              return t.targetCount += 1, r.updateMetadataFromQueryData(n, t), r.saveMetadata(e, t);\n            });\n          });\n        }, t.prototype.updateQueryData = function (t, e) {\n          return this.saveQueryData(t, e);\n        }, t.prototype.removeQueryData = function (e, t) {\n          var n = this;\n          return this.removeMatchingKeysForTargetId(e, t.targetId).next(function () {\n            return Do(e).delete(t.targetId);\n          }).next(function () {\n            return n.retrieveMetadata(e);\n          }).next(function (t) {\n            return Or(0 < t.targetCount, \"Removing from an empty query cache\"), t.targetCount -= 1, n.saveMetadata(e, t);\n          });\n        }, t.prototype.removeTargets = function (r, i, o) {\n          var a = this,\n              s = 0,\n              u = [];\n          return Do(r).iterate(function (t, e) {\n            var n = a.serializer.fromDbTarget(e);\n            n.sequenceNumber <= i && void 0 === o[n.targetId] && (s++, u.push(a.removeQueryData(r, n)));\n          }).next(function () {\n            return oo.waitFor(u);\n          }).next(function () {\n            return s;\n          });\n        }, t.prototype.forEachTarget = function (t, r) {\n          var i = this;\n          return Do(t).iterate(function (t, e) {\n            var n = i.serializer.fromDbTarget(e);\n            r(n);\n          });\n        }, t.prototype.retrieveMetadata = function (t) {\n          return No(t.simpleDbTransaction);\n        }, t.prototype.saveMetadata = function (t, e) {\n          return (n = t, Na.getStore(n, oa.store)).put(oa.key, e);\n          var n;\n        }, t.prototype.saveQueryData = function (t, e) {\n          return Do(t).put(this.serializer.toDbTarget(e));\n        }, t.prototype.updateMetadataFromQueryData = function (t, e) {\n          var n = !1;\n          return t.targetId > e.highestTargetId && (e.highestTargetId = t.targetId, n = !0), t.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t.sequenceNumber, n = !0), n;\n        }, t.prototype.getQueryCount = function (t) {\n          return this.retrieveMetadata(t).next(function (t) {\n            return t.targetCount;\n          });\n        }, t.prototype.getQueryData = function (t, i) {\n          var o = this,\n              e = i.canonicalId(),\n              n = IDBKeyRange.bound([e, Number.NEGATIVE_INFINITY], [e, Number.POSITIVE_INFINITY]),\n              a = null;\n          return Do(t).iterate({\n            range: n,\n            index: ra.queryTargetsIndexName\n          }, function (t, e, n) {\n            var r = o.serializer.fromDbTarget(e);\n            i.isEqual(r.query) && (a = r, n.done());\n          }).next(function () {\n            return a;\n          });\n        }, t.prototype.addMatchingKeys = function (n, t, r) {\n          var i = this,\n              o = [],\n              a = ko(n);\n          return t.forEach(function (t) {\n            var e = Pi(t.path);\n            o.push(a.put(new ia(r, e))), o.push(i.referenceDelegate.addReference(n, t));\n          }), oo.waitFor(o);\n        }, t.prototype.removeMatchingKeys = function (n, t, r) {\n          var i = this,\n              o = ko(n);\n          return oo.forEach(t, function (t) {\n            var e = Pi(t.path);\n            return oo.waitFor([o.delete([r, e]), i.referenceDelegate.removeReference(n, t)]);\n          });\n        }, t.prototype.removeMatchingKeysForTargetId = function (t, e) {\n          var n = ko(t),\n              r = IDBKeyRange.bound([e], [e + 1], !1, !0);\n          return n.delete(r);\n        }, t.prototype.getMatchingKeysForTargetId = function (t, e) {\n          var n = IDBKeyRange.bound([e], [e + 1], !1, !0),\n              r = ko(t),\n              o = to();\n          return r.iterate({\n            range: n,\n            keysOnly: !0\n          }, function (t, e, n) {\n            var r = qi(t[1]),\n                i = new Di(r);\n            o = o.add(i);\n          }).next(function () {\n            return o;\n          });\n        }, t.prototype.containsKey = function (t, e) {\n          var n = Pi(e.path),\n              r = IDBKeyRange.bound([n], [hi(n)], !1, !0),\n              i = 0;\n          return ko(t).iterate({\n            index: ia.documentTargetsIndex,\n            keysOnly: !0,\n            range: r\n          }, function (t, e, n) {\n            var r = t[0];\n            t[1];\n            0 !== r && (i++, n.done());\n          }).next(function () {\n            return 0 < i;\n          });\n        }, t.prototype.getQueryDataForTarget = function (t, e) {\n          var n = this;\n          return Do(t).get(e).next(function (t) {\n            return t ? n.serializer.fromDbTarget(t) : null;\n          });\n        }, t;\n      }();\n\n      function Do(t) {\n        return Na.getStore(t, ra.store);\n      }\n\n      function No(t) {\n        return vo.getStore(t, oa.store).get(oa.key).next(function (t) {\n          return Or(null !== t, \"Missing metadata row.\"), t;\n        });\n      }\n\n      function Ao(t) {\n        return No(t).next(function (t) {\n          return t.highestListenSequenceNumber;\n        });\n      }\n\n      function ko(t) {\n        return Na.getStore(t, ia.store);\n      }\n\n      var Ro = function () {\n        function t(t, e) {\n          this.key = t, this.version = e;\n        }\n\n        return t.compareByKey = function (t, e) {\n          return Di.comparator(t.key, e.key);\n        }, t;\n      }(),\n          Mo = function (a) {\n        function e(t, e, n, r, i) {\n          var o = a.call(this, t, e) || this;\n          return o.data = n, o.proto = i, o.hasLocalMutations = !!r.hasLocalMutations, o.hasCommittedMutations = !!r.hasCommittedMutations, o;\n        }\n\n        return s(e, a), e.prototype.field = function (t) {\n          return this.data.field(t);\n        }, e.prototype.fieldValue = function (t) {\n          var e = this.field(t);\n          return e ? e.value() : void 0;\n        }, e.prototype.value = function () {\n          return this.data.value();\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.data.isEqual(t.data) && this.hasLocalMutations === t.hasLocalMutations && this.hasCommittedMutations === t.hasCommittedMutations;\n        }, e.prototype.toString = function () {\n          return \"Document(\" + this.key + \", \" + this.version + \", \" + this.data.toString() + \", {hasLocalMutations: \" + this.hasLocalMutations + \"}), {hasCommittedMutations: \" + this.hasCommittedMutations + \"})\";\n        }, Object.defineProperty(e.prototype, \"hasPendingWrites\", {\n          get: function () {\n            return this.hasLocalMutations || this.hasCommittedMutations;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.compareByField = function (t, e, n) {\n          var r = e.field(t),\n              i = n.field(t);\n          return void 0 !== r && void 0 !== i ? r.compareTo(i) : Mr(\"Trying to compare documents on fields that don't exist\");\n        }, e;\n      }(Ro),\n          Oo = function (i) {\n        function e(t, e, n) {\n          var r = i.call(this, t, e) || this;\n          return r.hasCommittedMutations = !(!n || !n.hasCommittedMutations), r;\n        }\n\n        return s(e, i), e.prototype.toString = function () {\n          return \"NoDocument(\" + this.key + \", \" + this.version + \")\";\n        }, Object.defineProperty(e.prototype, \"hasPendingWrites\", {\n          get: function () {\n            return this.hasCommittedMutations;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && t.hasCommittedMutations === this.hasCommittedMutations && t.version.isEqual(this.version) && t.key.isEqual(this.key);\n        }, e;\n      }(Ro),\n          _o = function (n) {\n        function e(t, e) {\n          return n.call(this, t, e) || this;\n        }\n\n        return s(e, n), e.prototype.toString = function () {\n          return \"UnknownDocument(\" + this.key + \", \" + this.version + \")\";\n        }, Object.defineProperty(e.prototype, \"hasPendingWrites\", {\n          get: function () {\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && t.version.isEqual(this.version) && t.key.isEqual(this.key);\n        }, e;\n      }(Ro),\n          Po = function () {\n        function t(t) {\n          this.mapKeyFn = t, this.inner = {};\n        }\n\n        return t.prototype.get = function (t) {\n          var e = this.mapKeyFn(t),\n              n = this.inner[e];\n          if (void 0 !== n) for (var r = 0, i = n; r < i.length; r++) {\n            var o = i[r],\n                a = o[0],\n                s = o[1];\n            if (a.isEqual(t)) return s;\n          }\n        }, t.prototype.has = function (t) {\n          return void 0 !== this.get(t);\n        }, t.prototype.set = function (t, e) {\n          var n = this.mapKeyFn(t),\n              r = this.inner[n];\n\n          if (void 0 !== r) {\n            for (var i = 0; i < r.length; i++) if (r[i][0].isEqual(t)) return void (r[i] = [t, e]);\n\n            r.push([t, e]);\n          } else this.inner[n] = [[t, e]];\n        }, t.prototype.delete = function (t) {\n          var e = this.mapKeyFn(t),\n              n = this.inner[e];\n          if (void 0 === n) return !1;\n\n          for (var r = 0; r < n.length; r++) if (n[r][0].isEqual(t)) return 1 === n.length ? delete this.inner[e] : n.splice(r, 1), !0;\n\n          return !1;\n        }, t.prototype.forEach = function (s) {\n          Br(this.inner, function (t, e) {\n            for (var n = 0, r = e; n < r.length; n++) {\n              var i = r[n],\n                  o = i[0],\n                  a = i[1];\n              s(o, a);\n            }\n          });\n        }, t.prototype.isEmpty = function () {\n          return Qr(this.inner);\n        }, t;\n      }(),\n          Lo = function () {\n        function t() {\n          this.changes = zi(), this.documentSizes = new Po(function (t) {\n            return t.toString();\n          });\n        }\n\n        return t.prototype.addEntry = function (t) {\n          var e = this.assertChanges();\n          this.changes = e.insert(t.key, t);\n        }, t.prototype.getEntry = function (t, e) {\n          var n = this,\n              r = this.assertChanges().get(e);\n          return r ? oo.resolve(r) : this.getFromCache(t, e).next(function (t) {\n            return null === t ? (n.documentSizes.set(e, 0), null) : (n.documentSizes.set(e, t.size), t.maybeDocument);\n          });\n        }, t.prototype.getEntries = function (t, e) {\n          var n = this;\n          return this.getAllFromCache(t, e).next(function (t) {\n            var e = t.maybeDocuments;\n            return t.sizeMap.forEach(function (t, e) {\n              n.documentSizes.set(t, e);\n            }), e;\n          });\n        }, t.prototype.apply = function (t) {\n          var e = this.applyChanges(t);\n          return this.changes = null, e;\n        }, t.prototype.assertChanges = function () {\n          return Or(null !== this.changes, \"Changes have already been applied.\"), this.changes;\n        }, t;\n      }(),\n          xo = \"The remote document changelog no longer contains all changes for all local query views. It may be necessary to rebuild these views.\",\n          qo = function () {\n        function t(t, e, n) {\n          this.serializer = t, this.indexManager = e, this.keepDocumentChangeLog = n, this._lastProcessedDocumentChangeId = 0;\n        }\n\n        return Object.defineProperty(t.prototype, \"lastProcessedDocumentChangeId\", {\n          get: function () {\n            return this._lastProcessedDocumentChangeId;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.start = function (t) {\n          var e = vo.getStore(t, ua.store);\n          return this.synchronizeLastDocumentChangeId(e);\n        }, t.prototype.addEntries = function (t, e, n) {\n          var r = [];\n\n          if (0 < e.length) {\n            for (var i = Uo(t), o = to(), a = 0, s = e; a < s.length; a++) {\n              var u = s[a],\n                  c = u.key,\n                  h = u.doc;\n              r.push(i.put(Qo(c), h)), o = o.add(c), r.push(this.indexManager.addToCollectionParentIndex(t, c.path.popLast()));\n            }\n\n            this.keepDocumentChangeLog && r.push(Bo(t).put({\n              changes: this.serializer.toDbResourcePaths(o)\n            })), r.push(this.updateSize(t, n));\n          }\n\n          return oo.waitFor(r);\n        }, t.prototype.removeEntry = function (t, e) {\n          var n = Uo(t),\n              r = Qo(e);\n          return n.get(r).next(function (t) {\n            return t ? n.delete(r).next(function () {\n              return Ko(t);\n            }) : oo.resolve(0);\n          });\n        }, t.prototype.getEntry = function (t, e) {\n          var n = this;\n          return Uo(t).get(Qo(e)).next(function (t) {\n            return t ? n.serializer.fromDbRemoteDocument(t) : null;\n          });\n        }, t.prototype.getSizedEntry = function (t, e) {\n          var n = this;\n          return Uo(t).get(Qo(e)).next(function (t) {\n            return t ? {\n              maybeDocument: n.serializer.fromDbRemoteDocument(t),\n              size: Ko(t)\n            } : null;\n          });\n        }, t.prototype.getEntries = function (t, e) {\n          var n = this,\n              r = Hi();\n          return this.forEachDbEntry(t, e, function (t, e) {\n            r = e ? r.insert(t, n.serializer.fromDbRemoteDocument(e)) : r.insert(t, null);\n          }).next(function () {\n            return r;\n          });\n        }, t.prototype.getSizedEntries = function (t, e) {\n          var n = this,\n              r = Hi(),\n              i = new Ui(Di.comparator);\n          return this.forEachDbEntry(t, e, function (t, e) {\n            i = e ? (r = r.insert(t, n.serializer.fromDbRemoteDocument(e)), i.insert(t, Ko(e))) : (r = r.insert(t, null), i.insert(t, 0));\n          }).next(function () {\n            return {\n              maybeDocuments: r,\n              sizeMap: i\n            };\n          });\n        }, t.prototype.forEachDbEntry = function (t, e, i) {\n          if (e.isEmpty()) return oo.resolve();\n          var n = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()),\n              o = e.getIterator(),\n              a = o.getNext();\n          return Uo(t).iterate({\n            range: n\n          }, function (t, e, n) {\n            for (var r = Di.fromSegments(t); a && Di.comparator(a, r) < 0;) i(a, null), a = o.getNext();\n\n            a && a.isEqual(r) && (i(a, e), a = o.hasNext() ? o.getNext() : null), a ? n.skip(a.path.toArray()) : n.done();\n          }).next(function () {\n            for (; a;) i(a, null), a = o.hasNext() ? o.getNext() : null;\n          });\n        }, t.prototype.getDocumentsMatchingQuery = function (t, i) {\n          var o = this;\n          Or(!i.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n          var a = Xi(),\n              s = i.path.length + 1,\n              e = i.path.toArray(),\n              n = IDBKeyRange.lowerBound(e);\n          return Uo(t).iterate({\n            range: n\n          }, function (t, e, n) {\n            if (t.length === s) {\n              var r = o.serializer.fromDbRemoteDocument(e);\n              i.path.isPrefixOf(r.key.path) ? r instanceof Mo && i.matches(r) && (a = a.insert(r.key, r)) : n.done();\n            }\n          }).next(function () {\n            return a;\n          });\n        }, t.prototype.getNewDocumentChanges = function (e) {\n          var r = this;\n          Or(this.keepDocumentChangeLog, \"Can only call getNewDocumentChanges() when document change log is enabled\");\n          var n = to(),\n              i = zi(),\n              t = IDBKeyRange.lowerBound(this._lastProcessedDocumentChangeId + 1),\n              o = !0,\n              a = Bo(e);\n          return a.iterate({\n            range: t\n          }, function (t, e) {\n            if (o && (o = !1, r._lastProcessedDocumentChangeId + 1 !== e.id)) return r.synchronizeLastDocumentChangeId(a).next(function () {\n              return oo.reject(new xr(Lr.DATA_LOSS, xo));\n            });\n            n = n.unionWith(r.serializer.fromDbResourcePaths(e.changes)), r._lastProcessedDocumentChangeId = e.id;\n          }).next(function () {\n            var t = [];\n            return n.forEach(function (n) {\n              t.push(r.getEntry(e, n).next(function (t) {\n                var e = t || new Oo(n, Vi.forDeletedDoc());\n                i = i.insert(n, e);\n              }));\n            }), oo.waitFor(t);\n          }).next(function () {\n            return i;\n          });\n        }, t.prototype.removeDocumentChangesThroughChangeId = function (t, e) {\n          var n = IDBKeyRange.upperBound(e);\n          return Bo(t).delete(n);\n        }, t.prototype.synchronizeLastDocumentChangeId = function (t) {\n          var r = this;\n          return this._lastProcessedDocumentChangeId = 0, t.iterate({\n            keysOnly: !0,\n            reverse: !0\n          }, function (t, e, n) {\n            r._lastProcessedDocumentChangeId = t, n.done();\n          });\n        }, t.prototype.newChangeBuffer = function () {\n          return new Vo(this);\n        }, t.prototype.getSize = function (t) {\n          return this.getMetadata(t).next(function (t) {\n            return t.byteSize;\n          });\n        }, t.prototype.getMetadata = function (t) {\n          return Fo(t).get(na.key).next(function (t) {\n            return Or(!!t, \"Missing document cache metadata\"), t;\n          });\n        }, t.prototype.setMetadata = function (t, e) {\n          return Fo(t).put(na.key, e);\n        }, t.prototype.updateSize = function (e, n) {\n          var r = this;\n          return this.getMetadata(e).next(function (t) {\n            return t.byteSize += n, r.setMetadata(e, t);\n          });\n        }, t;\n      }();\n\n      function Fo(t) {\n        return Na.getStore(t, na.store);\n      }\n\n      var Vo = function (n) {\n        function t(t) {\n          var e = n.call(this) || this;\n          return e.documentCache = t, e;\n        }\n\n        return s(t, n), t.prototype.applyChanges = function (t) {\n          var o = this,\n              e = this.assertChanges(),\n              a = 0,\n              s = [];\n          return e.forEach(function (t, e) {\n            var n = o.documentCache.serializer.toDbRemoteDocument(e),\n                r = o.documentSizes.get(t);\n            Or(void 0 !== r, \"Attempting to change document \" + t.toString() + \" without having read it first\");\n            var i = Ko(n);\n            a += i - r, s.push({\n              key: t,\n              doc: n\n            });\n          }), this.documentCache.addEntries(t, s, a);\n        }, t.prototype.getFromCache = function (t, e) {\n          return this.documentCache.getSizedEntry(t, e);\n        }, t.prototype.getAllFromCache = function (t, e) {\n          return this.documentCache.getSizedEntries(t, e);\n        }, t;\n      }(Lo);\n\n      function Uo(t) {\n        return Na.getStore(t, ea.store);\n      }\n\n      function Bo(t) {\n        return Na.getStore(t, ua.store);\n      }\n\n      function Qo(t) {\n        return t.path.toArray();\n      }\n\n      function Ko(t) {\n        var e;\n        if (t.document) e = t.document;else if (t.unknownDocument) e = t.unknownDocument;else {\n          if (!t.noDocument) throw Mr(\"Unknown remote document type\");\n          e = t.noDocument;\n        }\n        return JSON.stringify(e).length;\n      }\n\n      var jo = function () {\n        function t() {\n          this.collectionParentIndex = new Go();\n        }\n\n        return t.prototype.addToCollectionParentIndex = function (t, e) {\n          return this.collectionParentIndex.add(e), oo.resolve();\n        }, t.prototype.getCollectionParents = function (t, e) {\n          return oo.resolve(this.collectionParentIndex.getEntries(e));\n        }, t;\n      }(),\n          Go = function () {\n        function t() {\n          this.index = {};\n        }\n\n        return t.prototype.add = function (t) {\n          Or(t.length % 2 == 1, \"Expected a collection path.\");\n          var e = t.lastSegment(),\n              n = t.popLast(),\n              r = this.index[e] || new ji(Ti.comparator),\n              i = !r.has(n);\n          return this.index[e] = r.add(n), i;\n        }, t.prototype.getEntries = function (t) {\n          return (this.index[t] || new ji(Ti.comparator)).toArray();\n        }, t;\n      }(),\n          Wo = 8,\n          zo = function () {\n        function t(t) {\n          this.serializer = t;\n        }\n\n        return t.prototype.createOrUpgrade = function (t, n, e, r) {\n          var i,\n              o = this;\n          Or(e < r && 0 <= e && r <= Wo, \"Unexpected schema upgrade from v\" + e + \" to v{toVersion}.\"), e < 1 && 1 <= r && (t.createObjectStore(Yo.store), (i = t).createObjectStore(Xo.store, {\n            keyPath: Xo.keyPath\n          }), i.createObjectStore(Jo.store, {\n            keyPath: Jo.keyPath,\n            autoIncrement: !0\n          }).createIndex(Jo.userMutationsIndex, Jo.userMutationsKeyPath, {\n            unique: !0\n          }), i.createObjectStore($o.store), sa(t), t.createObjectStore(ea.store));\n          var a,\n              s = oo.resolve();\n          return e < 3 && 3 <= r && (0 !== e && ((a = t).deleteObjectStore(ia.store), a.deleteObjectStore(ra.store), a.deleteObjectStore(oa.store), sa(t)), s = s.next(function () {\n            return t = n.store(oa.store), e = new oa(0, 0, Vi.MIN.toTimestamp(), 0), t.put(oa.key, e);\n            var t, e;\n          })), e < 4 && 4 <= r && (0 !== e && (s = s.next(function () {\n            return i = t, (o = n).store(Jo.store).loadAll().next(function (t) {\n              i.deleteObjectStore(Jo.store);\n              var e = i.createObjectStore(Jo.store, {\n                keyPath: Jo.keyPath,\n                autoIncrement: !0\n              });\n              e.createIndex(Jo.userMutationsIndex, Jo.userMutationsKeyPath, {\n                unique: !0\n              });\n              var n = o.store(Jo.store),\n                  r = t.map(function (t) {\n                return n.put(t);\n              });\n              return oo.waitFor(r);\n            });\n            var i, o;\n          })), s = s.next(function () {\n            t.createObjectStore(ca.store, {\n              keyPath: ca.keyPath\n            }), t.createObjectStore(ua.store, {\n              keyPath: \"id\",\n              autoIncrement: !0\n            });\n          })), e < 5 && 5 <= r && (s = s.next(function () {\n            return o.removeAcknowledgedMutations(n);\n          })), e < 6 && 6 <= r && (s = s.next(function () {\n            return t.createObjectStore(na.store), o.addDocumentGlobal(n);\n          })), e < 7 && 7 <= r && (s = s.next(function () {\n            return o.ensureSequenceNumbers(n);\n          })), e < 8 && 8 <= r && (s = s.next(function () {\n            return o.createCollectionParentIndex(t, n);\n          })), s;\n        }, t.prototype.addDocumentGlobal = function (e) {\n          var n = 0;\n          return e.store(ea.store).iterate(function (t, e) {\n            n += Ko(e);\n          }).next(function () {\n            var t = new na(n);\n            return e.store(na.store).put(na.key, t);\n          });\n        }, t.prototype.removeAcknowledgedMutations = function (r) {\n          var i = this,\n              t = r.store(Xo.store),\n              e = r.store(Jo.store);\n          return t.loadAll().next(function (t) {\n            return oo.forEach(t, function (n) {\n              var t = IDBKeyRange.bound([n.userId, -1], [n.userId, n.lastAcknowledgedBatchId]);\n              return e.loadAll(Jo.userMutationsIndex, t).next(function (t) {\n                return oo.forEach(t, function (t) {\n                  Or(t.userId === n.userId, \"Cannot process batch \" + t.batchId + \" from unexpected user\");\n                  var e = i.serializer.fromDbMutationBatch(t);\n                  return uo(r, n.userId, e).next(function () {});\n                });\n              });\n            });\n          });\n        }, t.prototype.ensureSequenceNumbers = function (t) {\n          var a = t.store(ia.store),\n              e = t.store(ea.store);\n          return Ao(t).next(function (i) {\n            var o = [];\n            return e.iterate(function (t, e) {\n              var n = new Ti(t),\n                  r = [0, Pi(n)];\n              o.push(a.get(r).next(function (t) {\n                return t ? oo.resolve() : (e = n, a.put(new ia(0, Pi(e), i)));\n                var e;\n              }));\n            }).next(function () {\n              return oo.waitFor(o);\n            });\n          });\n        }, t.prototype.createCollectionParentIndex = function (t, e) {\n          t.createObjectStore(aa.store, {\n            keyPath: aa.keyPath\n          });\n\n          var r = e.store(aa.store),\n              i = new Go(),\n              o = function (t) {\n            if (i.add(t)) {\n              var e = t.lastSegment(),\n                  n = t.popLast();\n              return r.put({\n                collectionId: e,\n                parent: Pi(n)\n              });\n            }\n          };\n\n          return e.store(ea.store).iterate({\n            keysOnly: !0\n          }, function (t, e) {\n            var n = new Ti(t);\n            return o(n.popLast());\n          }).next(function () {\n            return e.store($o.store).iterate({\n              keysOnly: !0\n            }, function (t, e) {\n              t[0];\n              var n = t[1],\n                  r = (t[2], qi(n));\n              return o(r.popLast());\n            });\n          });\n        }, t;\n      }();\n\n      var Ho = function (t, e) {\n        this.seconds = t, this.nanoseconds = e;\n      },\n          Yo = function () {\n        function t(t, e, n) {\n          this.ownerId = t, this.allowTabSynchronization = e, this.leaseTimestampMs = n;\n        }\n\n        return t.store = \"owner\", t.key = \"owner\", t;\n      }();\n\n      var Xo = function () {\n        function t(t, e, n) {\n          this.userId = t, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;\n        }\n\n        return t.store = \"mutationQueues\", t.keyPath = \"userId\", t;\n      }(),\n          Jo = function () {\n        function t(t, e, n, r, i) {\n          this.userId = t, this.batchId = e, this.localWriteTimeMs = n, this.baseMutations = r, this.mutations = i;\n        }\n\n        return t.store = \"mutations\", t.keyPath = \"batchId\", t.userMutationsIndex = \"userMutationsIndex\", t.userMutationsKeyPath = [\"userId\", \"batchId\"], t;\n      }();\n\n      var $o = function () {\n        function t() {}\n\n        return t.prefixForUser = function (t) {\n          return [t];\n        }, t.prefixForPath = function (t, e) {\n          return [t, Pi(e)];\n        }, t.key = function (t, e, n) {\n          return [t, Pi(e), n];\n        }, t.store = \"documentMutations\", t.PLACEHOLDER = new t(), t;\n      }();\n\n      var Zo = function (t, e) {\n        this.path = t, this.readTime = e;\n      },\n          ta = function (t, e) {\n        this.path = t, this.version = e;\n      },\n          ea = function () {\n        function t(t, e, n, r) {\n          this.unknownDocument = t, this.noDocument = e, this.document = n, this.hasCommittedMutations = r;\n        }\n\n        return t.store = \"remoteDocuments\", t;\n      }(),\n          na = function () {\n        function t(t) {\n          this.byteSize = t;\n        }\n\n        return t.store = \"remoteDocumentGlobal\", t.key = \"remoteDocumentGlobalKey\", t;\n      }();\n\n      var ra = function () {\n        function t(t, e, n, r, i, o) {\n          this.targetId = t, this.canonicalId = e, this.readTime = n, this.resumeToken = r, this.lastListenSequenceNumber = i, this.query = o;\n        }\n\n        return t.store = \"targets\", t.keyPath = \"targetId\", t.queryTargetsIndexName = \"queryTargetsIndex\", t.queryTargetsKeyPath = [\"canonicalId\", \"targetId\"], t;\n      }(),\n          ia = function () {\n        function t(t, e, n) {\n          this.targetId = t, this.path = e, Or(0 === t == (void 0 !== (this.sequenceNumber = n)), \"A target-document row must either have targetId == 0 and a defined sequence number, or a non-zero targetId and no sequence number\");\n        }\n\n        return t.store = \"targetDocuments\", t.keyPath = [\"targetId\", \"path\"], t.documentTargetsIndex = \"documentTargetsIndex\", t.documentTargetsKeyPath = [\"path\", \"targetId\"], t;\n      }(),\n          oa = function () {\n        function t(t, e, n, r) {\n          this.highestTargetId = t, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = r;\n        }\n\n        return t.key = \"targetGlobalKey\", t.store = \"targetGlobal\", t;\n      }(),\n          aa = function () {\n        function t(t, e) {\n          this.collectionId = t, this.parent = e;\n        }\n\n        return t.store = \"collectionParents\", t.keyPath = [\"collectionId\", \"parent\"], t;\n      }();\n\n      function sa(t) {\n        t.createObjectStore(ia.store, {\n          keyPath: ia.keyPath\n        }).createIndex(ia.documentTargetsIndex, ia.documentTargetsKeyPath, {\n          unique: !0\n        }), t.createObjectStore(ra.store, {\n          keyPath: ra.keyPath\n        }).createIndex(ra.queryTargetsIndexName, ra.queryTargetsKeyPath, {\n          unique: !0\n        }), t.createObjectStore(oa.store);\n      }\n\n      var ua = function () {\n        function t(t) {\n          this.changes = t;\n        }\n\n        return t.store = \"remoteDocumentChanges\", t.keyPath = \"id\", t;\n      }();\n\n      var ca = function () {\n        function t(t, e, n, r, i) {\n          this.clientId = t, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = r, this.lastProcessedDocumentChangeId = i;\n        }\n\n        return t.store = \"clientMetadata\", t.keyPath = \"clientId\", t;\n      }();\n\n      var ha,\n          la,\n          fa = [Xo.store, Jo.store, $o.store, ea.store, ra.store, Yo.store, oa.store, ia.store].concat([ca.store, ua.store]).concat([na.store]).concat([aa.store]),\n          pa = function () {\n        function t() {\n          this.collectionParentsCache = new Go();\n        }\n\n        return t.prototype.addToCollectionParentIndex = function (t, e) {\n          if (Or(e.length % 2 == 1, \"Expected a collection path.\"), this.collectionParentsCache.add(e)) {\n            Or(1 <= e.length, \"Invalid collection path.\");\n            var n = e.lastSegment(),\n                r = e.popLast();\n            return da(t).put({\n              collectionId: n,\n              parent: Pi(r)\n            });\n          }\n\n          return oo.resolve();\n        }, t.prototype.getCollectionParents = function (t, i) {\n          var o = [],\n              e = IDBKeyRange.bound([i, \"\"], [hi(i), \"\"], !1, !0);\n          return da(t).loadAll(e).next(function (t) {\n            for (var e = 0, n = t; e < n.length; e++) {\n              var r = n[e];\n              if (r.collectionId !== i) break;\n              o.push(qi(r.parent));\n            }\n\n            return o;\n          });\n        }, t;\n      }();\n\n      function da(t) {\n        return Na.getStore(t, aa.store);\n      }\n\n      (la = ha || (ha = {}))[la.Listen = 0] = \"Listen\", la[la.ExistenceFilterMismatch = 1] = \"ExistenceFilterMismatch\", la[la.LimboResolution = 2] = \"LimboResolution\";\n\n      var ma = function () {\n        function e(t, e, n, r, i, o) {\n          void 0 === i && (i = Vi.MIN), void 0 === o && (o = Pr()), this.query = t, this.targetId = e, this.purpose = n, this.sequenceNumber = r, this.snapshotVersion = i, this.resumeToken = o;\n        }\n\n        return e.prototype.copy = function (t) {\n          return new e(this.query, this.targetId, this.purpose, void 0 === t.sequenceNumber ? this.sequenceNumber : t.sequenceNumber, void 0 === t.snapshotVersion ? this.snapshotVersion : t.snapshotVersion, void 0 === t.resumeToken ? this.resumeToken : t.resumeToken);\n        }, e.prototype.isEqual = function (t) {\n          return this.targetId === t.targetId && this.purpose === t.purpose && this.sequenceNumber === t.sequenceNumber && this.snapshotVersion.isEqual(t.snapshotVersion) && this.resumeToken === t.resumeToken && this.query.isEqual(t.query);\n        }, e;\n      }(),\n          ya = function () {\n        function t(t) {\n          this.remoteSerializer = t;\n        }\n\n        return t.prototype.fromDbRemoteDocument = function (t) {\n          if (t.document) return this.remoteSerializer.fromDocument(t.document, !!t.hasCommittedMutations);\n\n          if (t.noDocument) {\n            var e = Di.fromSegments(t.noDocument.path),\n                n = this.fromDbTimestamp(t.noDocument.readTime);\n            return new Oo(e, n, {\n              hasCommittedMutations: !!t.hasCommittedMutations\n            });\n          }\n\n          if (t.unknownDocument) {\n            e = Di.fromSegments(t.unknownDocument.path), n = this.fromDbTimestamp(t.unknownDocument.version);\n            return new _o(e, n);\n          }\n\n          return Mr(\"Unexpected DbRemoteDocument\");\n        }, t.prototype.toDbRemoteDocument = function (t) {\n          if (t instanceof Mo) {\n            var e = t.proto ? t.proto : this.remoteSerializer.toDocument(t),\n                n = t.hasCommittedMutations;\n            return new ea(null, null, e, n);\n          }\n\n          if (t instanceof Oo) {\n            var r = t.key.path.toArray(),\n                i = this.toDbTimestamp(t.version);\n            n = t.hasCommittedMutations;\n            return new ea(null, new Zo(r, i), null, n);\n          }\n\n          if (t instanceof _o) {\n            r = t.key.path.toArray(), i = this.toDbTimestamp(t.version);\n            return new ea(new ta(r, i), null, null, !0);\n          }\n\n          return Mr(\"Unexpected MaybeDocumment\");\n        }, t.prototype.toDbTimestamp = function (t) {\n          var e = t.toTimestamp();\n          return new Ho(e.seconds, e.nanoseconds);\n        }, t.prototype.fromDbTimestamp = function (t) {\n          var e = new Fi(t.seconds, t.nanoseconds);\n          return Vi.fromTimestamp(e);\n        }, t.prototype.toDbMutationBatch = function (t, e) {\n          var n = this,\n              r = e.baseMutations.map(function (t) {\n            return n.remoteSerializer.toMutation(t);\n          }),\n              i = e.mutations.map(function (t) {\n            return n.remoteSerializer.toMutation(t);\n          });\n          return new Jo(t, e.batchId, e.localWriteTime.toMillis(), r, i);\n        }, t.prototype.fromDbMutationBatch = function (t) {\n          var e = this,\n              n = (t.baseMutations || []).map(function (t) {\n            return e.remoteSerializer.fromMutation(t);\n          }),\n              r = t.mutations.map(function (t) {\n            return e.remoteSerializer.fromMutation(t);\n          }),\n              i = Fi.fromMillis(t.localWriteTimeMs);\n          return new ro(t.batchId, i, n, r);\n        }, t.prototype.toDbResourcePaths = function (t) {\n          var e = [];\n          return t.forEach(function (t) {\n            e.push(Pi(t.path));\n          }), e;\n        }, t.prototype.fromDbResourcePaths = function (t) {\n          for (var e = to(), n = 0, r = t; n < r.length; n++) {\n            var i = r[n];\n            e = e.add(new Di(qi(i)));\n          }\n\n          return e;\n        }, t.prototype.fromDbTarget = function (t) {\n          var e,\n              n = this.fromDbTimestamp(t.readTime);\n          return e = void 0 !== t.query.documents ? this.remoteSerializer.fromDocumentsTarget(t.query) : this.remoteSerializer.fromQueryTarget(t.query), new ma(e, t.targetId, ha.Listen, t.lastListenSequenceNumber, n, t.resumeToken);\n        }, t.prototype.toDbTarget = function (t) {\n          Or(ha.Listen === t.purpose, \"Only queries with purpose \" + ha.Listen + \" may be stored, got \" + t.purpose);\n          var e,\n              n,\n              r = this.toDbTimestamp(t.snapshotVersion);\n          return e = t.query.isDocumentQuery() ? this.remoteSerializer.toDocumentsTarget(t.query) : this.remoteSerializer.toQueryTarget(t.query), n = t.resumeToken instanceof Uint8Array ? (Or(\"YES\" === process.env.USE_MOCK_PERSISTENCE, \"Persisting non-string stream tokens is only supported with mock persistence .\"), t.resumeToken.toString()) : t.resumeToken, new ra(t.targetId, t.query.canonicalId(), r, n, t.sequenceNumber, e);\n        }, t;\n      }();\n\n      function ga(t, e) {\n        var n = t[0],\n            r = t[1],\n            i = e[0],\n            o = e[1],\n            a = ui(n, i);\n        return 0 === a ? ui(r, o) : a;\n      }\n\n      var va = function () {\n        function t(t) {\n          this.maxElements = t, this.buffer = new ji(ga), this.previousIndex = 0;\n        }\n\n        return t.prototype.nextIndex = function () {\n          return ++this.previousIndex;\n        }, t.prototype.addElement = function (t) {\n          var e = [t, this.nextIndex()];\n          if (this.buffer.size < this.maxElements) this.buffer = this.buffer.add(e);else {\n            var n = this.buffer.last();\n            ga(e, n) < 0 && (this.buffer = this.buffer.delete(n).add(e));\n          }\n        }, Object.defineProperty(t.prototype, \"maxValue\", {\n          get: function () {\n            return this.buffer.last()[0];\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t;\n      }(),\n          ba = {\n        didRun: !1,\n        sequenceNumbersCollected: 0,\n        targetsRemoved: 0,\n        documentsRemoved: 0\n      },\n          wa = function () {\n        function e(t, e, n) {\n          this.cacheSizeCollectionThreshold = t, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;\n        }\n\n        return e.withCacheSize = function (t) {\n          return new e(t, e.DEFAULT_COLLECTION_PERCENTILE, e.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\n        }, e.COLLECTION_DISABLED = -1, e.MINIMUM_CACHE_SIZE_BYTES = 1048576, e.DEFAULT = new e(e.DEFAULT_CACHE_SIZE_BYTES = 41943040, e.DEFAULT_COLLECTION_PERCENTILE = 10, e.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3), e.DISABLED = new e(e.COLLECTION_DISABLED, 0, 0), e;\n      }(),\n          Ea = function () {\n        function t(t, e, n) {\n          this.garbageCollector = t, this.asyncQueue = e, this.localStore = n, this.gcTask = null;\n        }\n\n        return t.prototype.start = function () {\n          Or(null === this.gcTask, \"Cannot start an already started LruScheduler\"), this.garbageCollector.params.cacheSizeCollectionThreshold !== wa.COLLECTION_DISABLED && this.scheduleGC();\n        }, t.prototype.stop = function () {\n          this.gcTask && (this.gcTask.cancel(), this.gcTask = null);\n        }, Object.defineProperty(t.prototype, \"started\", {\n          get: function () {\n            return null !== this.gcTask;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.scheduleGC = function () {\n          var t = this;\n          Or(null === this.gcTask, \"Cannot schedule GC while a task is pending\");\n          var e = this.hasRun ? 3e5 : 6e4;\n          Ar(\"LruGarbageCollector\", \"Garbage collection scheduled in \" + e + \"ms\"), this.gcTask = this.asyncQueue.enqueueAfterDelay(pi.LruGarbageCollection, e, function () {\n            return t.gcTask = null, t.hasRun = !0, t.localStore.collectGarbage(t.garbageCollector).then(function () {\n              return t.scheduleGC();\n            }).catch(Aa);\n          });\n        }, t;\n      }(),\n          Sa = function () {\n        function t(t, e) {\n          this.delegate = t, this.params = e;\n        }\n\n        return t.prototype.calculateTargetCount = function (t, e) {\n          return this.delegate.getSequenceNumberCount(t).next(function (t) {\n            return Math.floor(e / 100 * t);\n          });\n        }, t.prototype.nthSequenceNumber = function (t, e) {\n          var n = this;\n          if (0 === e) return oo.resolve(wi.INVALID);\n          var r = new va(e);\n          return this.delegate.forEachTarget(t, function (t) {\n            return r.addElement(t.sequenceNumber);\n          }).next(function () {\n            return n.delegate.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n              return r.addElement(t);\n            });\n          }).next(function () {\n            return r.maxValue;\n          });\n        }, t.prototype.removeTargets = function (t, e, n) {\n          return this.delegate.removeTargets(t, e, n);\n        }, t.prototype.removeOrphanedDocuments = function (t, e) {\n          return this.delegate.removeOrphanedDocuments(t, e);\n        }, t.prototype.collect = function (e, n) {\n          var r = this;\n          return this.params.cacheSizeCollectionThreshold === wa.COLLECTION_DISABLED ? (Ar(\"LruGarbageCollector\", \"Garbage collection skipped; disabled\"), oo.resolve(ba)) : this.getCacheSize(e).next(function (t) {\n            return t < r.params.cacheSizeCollectionThreshold ? (Ar(\"LruGarbageCollector\", \"Garbage collection skipped; Cache size \" + t + \" is lower than threshold \" + r.params.cacheSizeCollectionThreshold), ba) : r.runGarbageCollection(e, n);\n          });\n        }, t.prototype.getCacheSize = function (t) {\n          return this.delegate.getCacheSize(t);\n        }, t.prototype.runGarbageCollection = function (e, n) {\n          var r,\n              i,\n              o,\n              a,\n              s,\n              u,\n              c,\n              h,\n              l = this;\n          return a = Date.now(), this.calculateTargetCount(e, this.params.percentileToCollect).next(function (t) {\n            return i = t > l.params.maximumSequenceNumbersToCollect ? (Ar(\"LruGarbageCollector\", \"Capping sequence numbers to collect down to the maximum of \" + l.params.maximumSequenceNumbersToCollect + \" from \" + t), l.params.maximumSequenceNumbersToCollect) : t, s = Date.now(), l.nthSequenceNumber(e, i);\n          }).next(function (t) {\n            return r = t, u = Date.now(), l.removeTargets(e, r, n);\n          }).next(function (t) {\n            return o = t, c = Date.now(), l.removeOrphanedDocuments(e, r);\n          }).next(function (t) {\n            (h = Date.now(), Dr() <= yr.DEBUG) && Ar(\"LruGarbageCollector\", \"LRU Garbage Collection\\n\\tCounted targets in \" + (s - a) + \"ms\\n\\tDetermined least recently used \" + i + \" in \" + (u - s) + \"ms\\n\\tRemoved \" + o + \" targets in \" + (c - u) + \"ms\\n\\tRemoved \" + t + \" documents in \" + (h - c) + \"ms\\nTotal Duration: \" + (h - a) + \"ms\");\n            return oo.resolve({\n              didRun: !0,\n              sequenceNumbersCollected: i,\n              targetsRemoved: o,\n              documentsRemoved: t\n            });\n          });\n        }, t;\n      }(),\n          Ta = \"IndexedDbPersistence\",\n          Ia = \"The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.\",\n          Ca = \"Another tab has exclusive access to the persistence layer. To allow shared access, make sure to invoke `enablePersistence()` with `synchronizeTabs:true` in all tabs.\",\n          Da = function (r) {\n        function t(t, e) {\n          var n = r.call(this) || this;\n          return n.simpleDbTransaction = t, n.currentSequenceNumber = e, n;\n        }\n\n        return s(t, r), t;\n      }(function () {}),\n          Na = function () {\n        function c(t, e, n, r, i, o, a) {\n          if (this.persistenceKey = t, this.clientId = e, this.queue = r, this.multiClientParams = a, this._started = !1, this.isPrimary = !1, this.networkEnabled = !0, this.inForeground = !1, this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY, this.primaryStateListener = function (t) {\n            return Promise.resolve();\n          }, !c.isAvailable()) throw new xr(Lr.UNIMPLEMENTED, \"This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.\");\n          if (this.referenceDelegate = new La(this, o), this.dbName = t + c.MAIN_DATABASE, this.serializer = new ya(i), this.document = n.document, this.allowTabSynchronization = void 0 !== a, this.queryCache = new Co(this.referenceDelegate, this.serializer), this.indexManager = new pa(), this.remoteDocumentCache = new qo(this.serializer, this.indexManager, this.allowTabSynchronization), !n.window || !n.window.localStorage) throw new xr(Lr.UNIMPLEMENTED, \"IndexedDB persistence is only available on platforms that support LocalStorage.\");\n          this.window = n.window, this.webStorage = this.window.localStorage;\n        }\n\n        return c.getStore = function (t, e) {\n          if (t instanceof Da) return vo.getStore(t.simpleDbTransaction, e);\n          throw Mr(\"IndexedDbPersistence must use instances of IndexedDbTransaction\");\n        }, c.createIndexedDbPersistence = function (n, r, i, o, a, s) {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, (e = new c(n, r, i, o, a, s)).start()];\n\n                case 1:\n                  return t.sent(), [2, e];\n              }\n            });\n          });\n        }, c.createMultiClientIndexedDbPersistence = function (n, r, i, o, a, s, u) {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, (e = new c(n, r, i, o, a, s, u)).start()];\n\n                case 1:\n                  return t.sent(), [2, e];\n              }\n            });\n          });\n        }, c.prototype.start = function () {\n          var n = this;\n          return Or(!this.started, \"IndexedDbPersistence double-started!\"), Or(null !== this.window, \"Expected 'window' to be defined\"), vo.openOrCreate(this.dbName, Wo, new zo(this.serializer)).then(function (t) {\n            return n.simpleDb = t, n.updateClientMetadataAndTryBecomePrimary();\n          }).then(function () {\n            return n.attachVisibilityHandler(), n.attachWindowUnloadHook(), n.scheduleClientMetadataAndPrimaryLeaseRefreshes(), n.startRemoteDocumentCache();\n          }).then(function () {\n            return n.simpleDb.runTransaction(\"readonly\", [oa.store], function (t) {\n              return Ao(t).next(function (t) {\n                var e = n.multiClientParams ? n.multiClientParams.sequenceNumberSyncer : void 0;\n                n.listenSequence = new wi(t, e);\n              });\n            });\n          }).then(function () {\n            n._started = !0;\n          }).catch(function (t) {\n            return n.simpleDb && n.simpleDb.close(), Promise.reject(t);\n          });\n        }, c.prototype.startRemoteDocumentCache = function () {\n          var e = this;\n          return this.simpleDb.runTransaction(\"readonly\", fa, function (t) {\n            return e.remoteDocumentCache.start(t);\n          });\n        }, c.prototype.setPrimaryStateListener = function (n) {\n          var t = this;\n          return this.primaryStateListener = function (e) {\n            return h(t, void 0, void 0, function () {\n              return p(this, function (t) {\n                return this.started ? [2, n(e)] : [2];\n              });\n            });\n          }, n(this.isPrimary);\n        }, c.prototype.setDatabaseDeletedListener = function (n) {\n          var t = this;\n          this.simpleDb.setVersionChangeListener(function (e) {\n            return h(t, void 0, void 0, function () {\n              return p(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    return null !== e.newVersion ? [3, 2] : [4, n()];\n\n                  case 1:\n                    t.sent(), t.label = 2;\n\n                  case 2:\n                    return [2];\n                }\n              });\n            });\n          });\n        }, c.prototype.setNetworkEnabled = function (t) {\n          var e = this;\n          this.networkEnabled !== t && (this.networkEnabled = t, this.queue.enqueueAndForget(function () {\n            return h(e, void 0, void 0, function () {\n              return p(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    return this.started ? [4, this.updateClientMetadataAndTryBecomePrimary()] : [3, 2];\n\n                  case 1:\n                    t.sent(), t.label = 2;\n\n                  case 2:\n                    return [2];\n                }\n              });\n            });\n          }));\n        }, c.prototype.updateClientMetadataAndTryBecomePrimary = function () {\n          var r = this;\n          return this.simpleDb.runTransaction(\"readwrite\", fa, function (n) {\n            return Ra(n).put(new ca(r.clientId, Date.now(), r.networkEnabled, r.inForeground, r.remoteDocumentCache.lastProcessedDocumentChangeId)).next(function () {\n              if (r.isPrimary) return r.verifyPrimaryLease(n).next(function (t) {\n                t || (r.isPrimary = !1, r.queue.enqueueAndForget(function () {\n                  return r.primaryStateListener(!1);\n                }));\n              });\n            }).next(function () {\n              return r.canActAsPrimary(n);\n            }).next(function (t) {\n              var e = r.isPrimary;\n              return r.isPrimary = t, e !== r.isPrimary && r.queue.enqueueAndForget(function () {\n                return r.primaryStateListener(r.isPrimary);\n              }), e && !r.isPrimary ? r.releasePrimaryLeaseIfHeld(n) : r.isPrimary ? r.acquireOrExtendPrimaryLease(n) : void 0;\n            });\n          });\n        }, c.prototype.verifyPrimaryLease = function (t) {\n          var e = this;\n          return ka(t).get(Yo.key).next(function (t) {\n            return oo.resolve(e.isLocalClient(t));\n          });\n        }, c.prototype.removeClientMetadata = function (t) {\n          return Ra(t).delete(this.clientId);\n        }, c.prototype.maybeGarbageCollectMultiClientState = function () {\n          return h(this, void 0, void 0, function () {\n            var r,\n                i,\n                o = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return !this.isPrimary || this.isWithinAge(this.lastGarbageCollectionTime, 18e5) ? [3, 2] : (this.lastGarbageCollectionTime = Date.now(), i = [], [4, this.runTransaction(\"maybeGarbageCollectMultiClientState\", \"readwrite-primary\", function (n) {\n                    var e = c.getStore(n, ca.store);\n                    return e.loadAll().next(function (t) {\n                      r = o.filterActiveClients(t, 18e5), i = t.filter(function (t) {\n                        return -1 === r.indexOf(t);\n                      });\n                    }).next(function () {\n                      return oo.forEach(i, function (t) {\n                        return e.delete(t.clientId);\n                      });\n                    }).next(function () {\n                      if (0 < (r = r.filter(function (t) {\n                        return t.clientId !== o.clientId;\n                      })).length) {\n                        var t = r.map(function (t) {\n                          return t.lastProcessedDocumentChangeId || 0;\n                        }),\n                            e = Math.min.apply(Math, t);\n                        return o.remoteDocumentCache.removeDocumentChangesThroughChangeId(n, e);\n                      }\n                    });\n                  })]);\n\n                case 1:\n                  t.sent(), i.forEach(function (t) {\n                    o.window.localStorage.removeItem(o.zombiedClientLocalStorageKey(t.clientId));\n                  }), t.label = 2;\n\n                case 2:\n                  return [2];\n              }\n            });\n          });\n        }, c.prototype.scheduleClientMetadataAndPrimaryLeaseRefreshes = function () {\n          var t = this;\n          this.clientMetadataRefresher = this.queue.enqueueAfterDelay(pi.ClientMetadataRefresh, 4e3, function () {\n            return t.updateClientMetadataAndTryBecomePrimary().then(function () {\n              return t.maybeGarbageCollectMultiClientState();\n            }).then(function () {\n              return t.scheduleClientMetadataAndPrimaryLeaseRefreshes();\n            });\n          });\n        }, c.prototype.isLocalClient = function (t) {\n          return !!t && t.ownerId === this.clientId;\n        }, c.prototype.canActAsPrimary = function (e) {\n          var i = this;\n          return ka(e).get(Yo.key).next(function (t) {\n            if (null !== t && i.isWithinAge(t.leaseTimestampMs, 5e3) && !i.isClientZombied(t.ownerId)) {\n              if (i.isLocalClient(t) && i.networkEnabled) return !0;\n\n              if (!i.isLocalClient(t)) {\n                if (!t.allowTabSynchronization) throw new xr(Lr.FAILED_PRECONDITION, Ca);\n                return !1;\n              }\n            }\n\n            return !(!i.networkEnabled || !i.inForeground) || Ra(e).loadAll().next(function (t) {\n              return void 0 === i.filterActiveClients(t, 5e3).find(function (t) {\n                if (i.clientId !== t.clientId) {\n                  var e = !i.networkEnabled && t.networkEnabled,\n                      n = !i.inForeground && t.inForeground,\n                      r = i.networkEnabled === t.networkEnabled;\n                  if (e || n && r) return !0;\n                }\n\n                return !1;\n              });\n            });\n          }).next(function (t) {\n            return i.isPrimary !== t && Ar(Ta, \"Client \" + (t ? \"is\" : \"is not\") + \" eligible for a primary lease.\"), t;\n          });\n        }, c.prototype.shutdown = function () {\n          return h(this, void 0, void 0, function () {\n            var e = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this._started = !1, this.markClientZombied(), this.clientMetadataRefresher && this.clientMetadataRefresher.cancel(), this.detachVisibilityHandler(), this.detachWindowUnloadHook(), [4, this.simpleDb.runTransaction(\"readwrite\", [Yo.store, ca.store], function (t) {\n                    return e.releasePrimaryLeaseIfHeld(t).next(function () {\n                      return e.removeClientMetadata(t);\n                    });\n                  })];\n\n                case 1:\n                  return t.sent(), this.simpleDb.close(), this.removeClientZombiedEntry(), [2];\n              }\n            });\n          });\n        }, c.prototype.filterActiveClients = function (t, e) {\n          var n = this;\n          return t.filter(function (t) {\n            return n.isWithinAge(t.updateTimeMs, e) && !n.isClientZombied(t.clientId);\n          });\n        }, c.prototype.getActiveClients = function () {\n          var e = this;\n          return this.simpleDb.runTransaction(\"readonly\", [ca.store], function (t) {\n            return Ra(t).loadAll().next(function (t) {\n              return e.filterActiveClients(t, 18e5).map(function (t) {\n                return t.clientId;\n              });\n            });\n          });\n        }, c.clearPersistence = function (n) {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return c.isAvailable() ? (e = n + c.MAIN_DATABASE, [4, vo.delete(e)]) : [2, Promise.resolve()];\n\n                case 1:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }, Object.defineProperty(c.prototype, \"started\", {\n          get: function () {\n            return this._started;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), c.prototype.getMutationQueue = function (t) {\n          return Or(this.started, \"Cannot initialize MutationQueue before persistence is started.\"), ao.forUser(t, this.serializer, this.indexManager, this.referenceDelegate);\n        }, c.prototype.getQueryCache = function () {\n          return Or(this.started, \"Cannot initialize QueryCache before persistence is started.\"), this.queryCache;\n        }, c.prototype.getRemoteDocumentCache = function () {\n          return Or(this.started, \"Cannot initialize RemoteDocumentCache before persistence is started.\"), this.remoteDocumentCache;\n        }, c.prototype.getIndexManager = function () {\n          return Or(this.started, \"Cannot initialize IndexManager before persistence is started.\"), this.indexManager;\n        }, c.prototype.runTransaction = function (n, t, r) {\n          var i = this;\n          return Ar(Ta, \"Starting transaction:\", n), this.simpleDb.runTransaction(\"readonly\" === t ? \"readonly\" : \"readwrite\", fa, function (e) {\n            return \"readwrite-primary\" === t ? i.verifyPrimaryLease(e).next(function (t) {\n              if (!t) throw kr(\"Failed to obtain primary lease for action '\" + n + \"'.\"), i.isPrimary = !1, i.queue.enqueueAndForget(function () {\n                return i.primaryStateListener(!1);\n              }), new xr(Lr.FAILED_PRECONDITION, Ia);\n              return r(new Da(e, i.listenSequence.next()));\n            }).next(function (t) {\n              return i.acquireOrExtendPrimaryLease(e).next(function () {\n                return t;\n              });\n            }) : i.verifyAllowTabSynchronization(e).next(function () {\n              return r(new Da(e, i.listenSequence.next()));\n            });\n          });\n        }, c.prototype.verifyAllowTabSynchronization = function (t) {\n          var e = this;\n          return ka(t).get(Yo.key).next(function (t) {\n            if (null !== t && e.isWithinAge(t.leaseTimestampMs, 5e3) && !e.isClientZombied(t.ownerId) && !e.isLocalClient(t) && !t.allowTabSynchronization) throw new xr(Lr.FAILED_PRECONDITION, Ca);\n          });\n        }, c.prototype.acquireOrExtendPrimaryLease = function (t) {\n          var e = new Yo(this.clientId, this.allowTabSynchronization, Date.now());\n          return ka(t).put(Yo.key, e);\n        }, c.isAvailable = function () {\n          return vo.isAvailable();\n        }, c.buildStoragePrefix = function (t) {\n          var e = t.databaseId.projectId;\n          return t.databaseId.isDefaultDatabase || (e += \".\" + t.databaseId.database), \"firestore/\" + t.persistenceKey + \"/\" + e + \"/\";\n        }, c.prototype.releasePrimaryLeaseIfHeld = function (t) {\n          var e = this,\n              n = ka(t);\n          return n.get(Yo.key).next(function (t) {\n            return e.isLocalClient(t) ? (Ar(Ta, \"Releasing primary lease.\"), n.delete(Yo.key)) : oo.resolve();\n          });\n        }, c.prototype.isWithinAge = function (t, e) {\n          var n = Date.now();\n          return !(t < n - e) && (!(n < t) || (kr(\"Detected an update time that is in the future: \" + t + \" > \" + n), !1));\n        }, c.prototype.attachVisibilityHandler = function () {\n          var t = this;\n          null !== this.document && \"function\" == typeof this.document.addEventListener && (this.documentVisibilityHandler = function () {\n            t.queue.enqueueAndForget(function () {\n              return t.inForeground = \"visible\" === t.document.visibilityState, t.updateClientMetadataAndTryBecomePrimary();\n            });\n          }, this.document.addEventListener(\"visibilitychange\", this.documentVisibilityHandler), this.inForeground = \"visible\" === this.document.visibilityState);\n        }, c.prototype.detachVisibilityHandler = function () {\n          this.documentVisibilityHandler && (Or(null !== this.document && \"function\" == typeof this.document.addEventListener, \"Expected 'document.addEventListener' to be a function\"), this.document.removeEventListener(\"visibilitychange\", this.documentVisibilityHandler), this.documentVisibilityHandler = null);\n        }, c.prototype.attachWindowUnloadHook = function () {\n          var t = this;\n          \"function\" == typeof this.window.addEventListener && (this.windowUnloadHandler = function () {\n            t.markClientZombied(), t.queue.enqueueAndForget(function () {\n              return t.shutdown();\n            });\n          }, this.window.addEventListener(\"unload\", this.windowUnloadHandler));\n        }, c.prototype.detachWindowUnloadHook = function () {\n          this.windowUnloadHandler && (Or(\"function\" == typeof this.window.removeEventListener, \"Expected 'window.removeEventListener' to be a function\"), this.window.removeEventListener(\"unload\", this.windowUnloadHandler), this.windowUnloadHandler = null);\n        }, c.prototype.isClientZombied = function (t) {\n          try {\n            var e = null !== this.webStorage.getItem(this.zombiedClientLocalStorageKey(t));\n            return Ar(Ta, \"Client '\" + t + \"' \" + (e ? \"is\" : \"is not\") + \" zombied in LocalStorage\"), e;\n          } catch (t) {\n            return kr(Ta, \"Failed to get zombied client id.\", t), !1;\n          }\n        }, c.prototype.markClientZombied = function () {\n          try {\n            this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\n          } catch (t) {\n            kr(\"Failed to set zombie client id.\", t);\n          }\n        }, c.prototype.removeClientZombiedEntry = function () {\n          try {\n            this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\n          } catch (t) {}\n        }, c.prototype.zombiedClientLocalStorageKey = function (t) {\n          return \"firestore_zombie_\" + this.persistenceKey + \"_\" + t;\n        }, c.MAIN_DATABASE = \"main\", c;\n      }();\n\n      function Aa(n) {\n        return h(this, void 0, void 0, function () {\n          return p(this, function (t) {\n            if ((e = n).code !== Lr.FAILED_PRECONDITION || e.message !== Ia) throw n;\n            var e;\n            return Ar(Ta, \"Unexpectedly lost primary lease\"), [2];\n          });\n        });\n      }\n\n      function ka(t) {\n        return t.store(Yo.store);\n      }\n\n      function Ra(t) {\n        return t.store(ca.store);\n      }\n\n      var Ma,\n          Oa,\n          _a,\n          Pa,\n          La = function () {\n        function t(t, e) {\n          this.db = t, this.garbageCollector = new Sa(this, e);\n        }\n\n        return t.prototype.getSequenceNumberCount = function (t) {\n          var n = this.orphanedDocmentCount(t);\n          return this.db.getQueryCache().getQueryCount(t).next(function (e) {\n            return n.next(function (t) {\n              return e + t;\n            });\n          });\n        }, t.prototype.orphanedDocmentCount = function (t) {\n          var e = 0;\n          return this.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n            e++;\n          }).next(function () {\n            return e;\n          });\n        }, t.prototype.forEachTarget = function (t, e) {\n          return this.db.getQueryCache().forEachTarget(t, e);\n        }, t.prototype.forEachOrphanedDocumentSequenceNumber = function (t, n) {\n          return this.forEachOrphanedDocument(t, function (t, e) {\n            return n(e);\n          });\n        }, t.prototype.setInMemoryPins = function (t) {\n          this.inMemoryPins = t;\n        }, t.prototype.addReference = function (t, e) {\n          return xa(t, e);\n        }, t.prototype.removeReference = function (t, e) {\n          return xa(t, e);\n        }, t.prototype.removeTargets = function (t, e, n) {\n          return this.db.getQueryCache().removeTargets(t, e, n);\n        }, t.prototype.removeMutationReference = function (t, e) {\n          return xa(t, e);\n        }, t.prototype.isPinned = function (t, e) {\n          return this.inMemoryPins.containsKey(e) ? oo.resolve(!0) : (r = e, i = !1, fo(n = t).iterateSerial(function (t) {\n            return so(n, t, r).next(function (t) {\n              return t && (i = !0), oo.resolve(!t);\n            });\n          }).next(function () {\n            return i;\n          }));\n          var n, r, i;\n        }, t.prototype.removeOrphanedDocuments = function (r, i) {\n          var o = this,\n              a = 0,\n              s = 0,\n              u = [];\n          return this.forEachOrphanedDocument(r, function (e, t) {\n            if (t <= i) {\n              var n = o.isPinned(r, e).next(function (t) {\n                if (!t) return a++, o.removeOrphanedDocument(r, e).next(function (t) {\n                  s += t;\n                });\n              });\n              u.push(n);\n            }\n          }).next(function () {\n            return oo.waitFor(u);\n          }).next(function () {\n            return o.db.getRemoteDocumentCache().updateSize(r, -s);\n          }).next(function () {\n            return a;\n          });\n        }, t.prototype.removeOrphanedDocument = function (t, e) {\n          var n,\n              r = 0,\n              i = this.db.getRemoteDocumentCache();\n          return oo.waitFor([ko(t).delete((n = e, [0, Pi(n.path)])), i.removeEntry(t, e).next(function (t) {\n            r += t;\n          })]).next(function () {\n            return r;\n          });\n        }, t.prototype.removeTarget = function (t, e) {\n          var n = e.copy({\n            sequenceNumber: t.currentSequenceNumber\n          });\n          return this.db.getQueryCache().updateQueryData(t, n);\n        }, t.prototype.updateLimboDocument = function (t, e) {\n          return xa(t, e);\n        }, t.prototype.forEachOrphanedDocument = function (t, o) {\n          var a,\n              e = ko(t),\n              s = wi.INVALID;\n          return e.iterate({\n            index: ia.documentTargetsIndex\n          }, function (t, e) {\n            var n = t[0],\n                r = (t[1], e.path),\n                i = e.sequenceNumber;\n            0 === n ? (s !== wi.INVALID && o(new Di(qi(a)), s), s = i, a = r) : s = wi.INVALID;\n          }).next(function () {\n            s !== wi.INVALID && o(new Di(qi(a)), s);\n          });\n        }, t.prototype.getCacheSize = function (t) {\n          return this.db.getRemoteDocumentCache().getSize(t);\n        }, t;\n      }();\n\n      function xa(t, e) {\n        return ko(t).put((n = e, r = t.currentSequenceNumber, new ia(0, Pi(n.path), r)));\n        var n, r;\n      }\n\n      (Oa = Ma || (Ma = {}))[Oa.NullValue = 0] = \"NullValue\", Oa[Oa.BooleanValue = 1] = \"BooleanValue\", Oa[Oa.NumberValue = 2] = \"NumberValue\", Oa[Oa.TimestampValue = 3] = \"TimestampValue\", Oa[Oa.StringValue = 4] = \"StringValue\", Oa[Oa.BlobValue = 5] = \"BlobValue\", Oa[Oa.RefValue = 6] = \"RefValue\", Oa[Oa.GeoPointValue = 7] = \"GeoPointValue\", Oa[Oa.ArrayValue = 8] = \"ArrayValue\", Oa[Oa.ObjectValue = 9] = \"ObjectValue\", (Pa = _a || (_a = {}))[Pa.Default = 0] = \"Default\", Pa[Pa.Estimate = 1] = \"Estimate\", Pa[Pa.Previous = 2] = \"Previous\";\n\n      var qa = function () {\n        function n(t, e) {\n          this.serverTimestampBehavior = t, this.timestampsInSnapshots = e;\n        }\n\n        return n.fromSnapshotOptions = function (t, e) {\n          switch (t.serverTimestamps) {\n            case \"estimate\":\n              return new n(_a.Estimate, e);\n\n            case \"previous\":\n              return new n(_a.Previous, e);\n\n            case \"none\":\n            case void 0:\n              return new n(_a.Default, e);\n\n            default:\n              return Mr(\"fromSnapshotOptions() called with invalid options.\");\n          }\n        }, n;\n      }(),\n          Fa = function () {\n        function t() {}\n\n        return t.prototype.toString = function () {\n          var t = this.value();\n          return null === t ? \"null\" : t.toString();\n        }, t.prototype.defaultCompareTo = function (t) {\n          return Or(this.typeOrder !== t.typeOrder, \"Default compareTo should not be used for values of same type.\"), ui(this.typeOrder, t.typeOrder);\n        }, t;\n      }(),\n          Va = function (e) {\n        function n() {\n          var t = e.call(this) || this;\n          return t.typeOrder = Ma.NullValue, t.internalValue = null, t;\n        }\n\n        return s(n, e), n.prototype.value = function (t) {\n          return null;\n        }, n.prototype.isEqual = function (t) {\n          return t instanceof n;\n        }, n.prototype.compareTo = function (t) {\n          return t instanceof n ? 0 : this.defaultCompareTo(t);\n        }, n.INSTANCE = new n(), n;\n      }(Fa),\n          Ua = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Ma.BooleanValue, e;\n        }\n\n        return s(e, n), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue === t.internalValue;\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? ui(this, t) : this.defaultCompareTo(t);\n        }, e.of = function (t) {\n          return t ? e.TRUE : e.FALSE;\n        }, e.TRUE = new e(!0), e.FALSE = new e(!1), e;\n      }(Fa),\n          Ba = function (n) {\n        function r(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Ma.NumberValue, e;\n        }\n\n        return s(r, n), r.prototype.value = function (t) {\n          return this.internalValue;\n        }, r.prototype.compareTo = function (t) {\n          return t instanceof r ? (e = this.internalValue, n = t.internalValue, e < n ? -1 : n < e ? 1 : e === n ? 0 : isNaN(e) ? isNaN(n) ? 0 : -1 : 1) : this.defaultCompareTo(t);\n          var e, n;\n        }, r;\n      }(Fa);\n\n      function Qa(t, e) {\n        return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e;\n      }\n\n      var Ka,\n          ja,\n          Ga = function (e) {\n        function n(t) {\n          return e.call(this, t) || this;\n        }\n\n        return s(n, e), n.prototype.isEqual = function (t) {\n          return t instanceof n && Qa(this.internalValue, t.internalValue);\n        }, n;\n      }(Ba),\n          Wa = function (n) {\n        function e(t) {\n          var e = n.call(this, t) || this;\n          return e.internalValue = t, e;\n        }\n\n        return s(e, n), e.prototype.isEqual = function (t) {\n          return t instanceof e && Qa(this.internalValue, t.internalValue);\n        }, e.NAN = new e(NaN), e.POSITIVE_INFINITY = new e(1 / 0), e.NEGATIVE_INFINITY = new e(-1 / 0), e;\n      }(Ba),\n          za = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Ma.StringValue, e;\n        }\n\n        return s(e, n), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue === t.internalValue;\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? ui(this.internalValue, t.internalValue) : this.defaultCompareTo(t);\n        }, e;\n      }(Fa),\n          Ha = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Ma.TimestampValue, e;\n        }\n\n        return s(e, n), e.prototype.value = function (t) {\n          return !t || t.timestampsInSnapshots ? this.internalValue : this.internalValue.toDate();\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue.isEqual(t.internalValue);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.internalValue._compareTo(t.internalValue) : t instanceof Ya ? -1 : this.defaultCompareTo(t);\n        }, e;\n      }(Fa),\n          Ya = function (r) {\n        function e(t, e) {\n          var n = r.call(this) || this;\n          return n.localWriteTime = t, n.previousValue = e, n.typeOrder = Ma.TimestampValue, n;\n        }\n\n        return s(e, r), e.prototype.value = function (t) {\n          return t && t.serverTimestampBehavior === _a.Estimate ? new Ha(this.localWriteTime).value(t) : t && t.serverTimestampBehavior === _a.Previous && this.previousValue ? this.previousValue.value(t) : null;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.localWriteTime.isEqual(t.localWriteTime);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.localWriteTime._compareTo(t.localWriteTime) : t instanceof Ha ? 1 : this.defaultCompareTo(t);\n        }, e.prototype.toString = function () {\n          return \"<ServerTimestamp localTime=\" + this.localWriteTime.toString() + \">\";\n        }, e;\n      }(Fa),\n          Xa = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Ma.BlobValue, e;\n        }\n\n        return s(e, n), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue.isEqual(t.internalValue);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.internalValue._compareTo(t.internalValue) : this.defaultCompareTo(t);\n        }, e;\n      }(Fa),\n          Ja = function (r) {\n        function n(t, e) {\n          var n = r.call(this) || this;\n          return n.databaseId = t, n.key = e, n.typeOrder = Ma.RefValue, n;\n        }\n\n        return s(n, r), n.prototype.value = function (t) {\n          return this.key;\n        }, n.prototype.isEqual = function (t) {\n          return t instanceof n && this.key.isEqual(t.key) && this.databaseId.isEqual(t.databaseId);\n        }, n.prototype.compareTo = function (t) {\n          if (t instanceof n) {\n            var e = this.databaseId.compareTo(t.databaseId);\n            return 0 !== e ? e : Di.comparator(this.key, t.key);\n          }\n\n          return this.defaultCompareTo(t);\n        }, n;\n      }(Fa),\n          $a = function (n) {\n        function e(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Ma.GeoPointValue, e;\n        }\n\n        return s(e, n), e.prototype.value = function (t) {\n          return this.internalValue;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.internalValue.isEqual(t.internalValue);\n        }, e.prototype.compareTo = function (t) {\n          return t instanceof e ? this.internalValue._compareTo(t.internalValue) : this.defaultCompareTo(t);\n        }, e;\n      }(Fa),\n          Za = function (n) {\n        function a(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Ma.ObjectValue, e;\n        }\n\n        return s(a, n), a.prototype.value = function (n) {\n          var r = {};\n          return this.internalValue.inorderTraversal(function (t, e) {\n            r[t] = e.value(n);\n          }), r;\n        }, a.prototype.forEach = function (t) {\n          this.internalValue.inorderTraversal(t);\n        }, a.prototype.isEqual = function (t) {\n          if (t instanceof a) {\n            for (var e = this.internalValue.getIterator(), n = t.internalValue.getIterator(); e.hasNext() && n.hasNext();) {\n              var r = e.getNext(),\n                  i = n.getNext();\n              if (r.key !== i.key || !r.value.isEqual(i.value)) return !1;\n            }\n\n            return !e.hasNext() && !n.hasNext();\n          }\n\n          return !1;\n        }, a.prototype.compareTo = function (t) {\n          if (t instanceof a) {\n            for (var e = this.internalValue.getIterator(), n = t.internalValue.getIterator(); e.hasNext() && n.hasNext();) {\n              var r = e.getNext(),\n                  i = n.getNext(),\n                  o = ui(r.key, i.key) || r.value.compareTo(i.value);\n              if (o) return o;\n            }\n\n            return ui(e.hasNext(), n.hasNext());\n          }\n\n          return this.defaultCompareTo(t);\n        }, a.prototype.set = function (t, e) {\n          if (Or(!t.isEmpty(), \"Cannot set field for empty path on ObjectValue\"), 1 === t.length) return this.setChild(t.firstSegment(), e);\n          var n = this.child(t.firstSegment());\n          n instanceof a || (n = a.EMPTY);\n          var r = n.set(t.popFirst(), e);\n          return this.setChild(t.firstSegment(), r);\n        }, a.prototype.delete = function (t) {\n          if (Or(!t.isEmpty(), \"Cannot delete field for empty path on ObjectValue\"), 1 === t.length) return new a(this.internalValue.remove(t.firstSegment()));\n          var e = this.child(t.firstSegment());\n\n          if (e instanceof a) {\n            var n = e.delete(t.popFirst());\n            return new a(this.internalValue.insert(t.firstSegment(), n));\n          }\n\n          return this;\n        }, a.prototype.contains = function (t) {\n          return void 0 !== this.field(t);\n        }, a.prototype.field = function (t) {\n          Or(!t.isEmpty(), \"Can't get field of empty path\");\n          var e = this;\n          return t.forEach(function (t) {\n            e = e instanceof a && e.internalValue.get(t) || void 0;\n          }), e;\n        }, a.prototype.toString = function () {\n          return this.internalValue.toString();\n        }, a.prototype.child = function (t) {\n          return this.internalValue.get(t) || void 0;\n        }, a.prototype.setChild = function (t, e) {\n          return new a(this.internalValue.insert(t, e));\n        }, a.EMPTY = new a(new Ui(ui)), a;\n      }(Fa),\n          ts = function (n) {\n        function i(t) {\n          var e = n.call(this) || this;\n          return e.internalValue = t, e.typeOrder = Ma.ArrayValue, e;\n        }\n\n        return s(i, n), i.prototype.value = function (e) {\n          return this.internalValue.map(function (t) {\n            return t.value(e);\n          });\n        }, i.prototype.contains = function (t) {\n          for (var e = 0, n = this.internalValue; e < n.length; e++) {\n            if (n[e].isEqual(t)) return !0;\n          }\n\n          return !1;\n        }, i.prototype.forEach = function (t) {\n          this.internalValue.forEach(t);\n        }, i.prototype.isEqual = function (t) {\n          if (t instanceof i) {\n            if (this.internalValue.length !== t.internalValue.length) return !1;\n\n            for (var e = 0; e < this.internalValue.length; e++) if (!this.internalValue[e].isEqual(t.internalValue[e])) return !1;\n\n            return !0;\n          }\n\n          return !1;\n        }, i.prototype.compareTo = function (t) {\n          if (t instanceof i) {\n            for (var e = Math.min(this.internalValue.length, t.internalValue.length), n = 0; n < e; n++) {\n              var r = this.internalValue[n].compareTo(t.internalValue[n]);\n              if (r) return r;\n            }\n\n            return ui(this.internalValue.length, t.internalValue.length);\n          }\n\n          return this.defaultCompareTo(t);\n        }, i.prototype.toString = function () {\n          return \"[\" + this.internalValue.map(function (t) {\n            return t.toString();\n          }).join(\",\") + \"]\";\n        }, i;\n      }(Fa),\n          es = function () {\n        function n(t) {\n          this.fields = t;\n        }\n\n        return n.fromSet = function (t) {\n          return new n(t);\n        }, n.fromArray = function (t) {\n          var e = new ji(Ci.comparator);\n          return t.forEach(function (t) {\n            return e = e.add(t);\n          }), new n(e);\n        }, n.prototype.covers = function (e) {\n          var n = !1;\n          return this.fields.forEach(function (t) {\n            t.isPrefixOf(e) && (n = !0);\n          }), n;\n        }, n.prototype.applyTo = function (n) {\n          var r = Za.EMPTY;\n          return this.fields.forEach(function (t) {\n            if (t.isEmpty()) return n;\n            var e = n.field(t);\n            void 0 !== e && (r = r.set(t, e));\n          }), r;\n        }, n.prototype.isEqual = function (t) {\n          return this.fields.isEqual(t.fields);\n        }, n;\n      }(),\n          ns = function () {\n        function t(t, e) {\n          this.field = t, this.transform = e;\n        }\n\n        return Object.defineProperty(t.prototype, \"isIdempotent\", {\n          get: function () {\n            return this.transform.isIdempotent;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.isEqual = function (t) {\n          return this.field.isEqual(t.field) && this.transform.isEqual(t.transform);\n        }, t;\n      }(),\n          rs = function (t, e) {\n        this.version = t, this.transformResults = e;\n      };\n\n      (ja = Ka || (Ka = {}))[ja.Set = 0] = \"Set\", ja[ja.Patch = 1] = \"Patch\", ja[ja.Transform = 2] = \"Transform\", ja[ja.Delete = 3] = \"Delete\";\n\n      var is = function () {\n        function e(t, e) {\n          this.updateTime = t, this.exists = e, Or(void 0 === t || void 0 === e, 'Precondition can specify \"exists\" or \"updateTime\" but not both');\n        }\n\n        return e.exists = function (t) {\n          return new e(void 0, t);\n        }, e.updateTime = function (t) {\n          return new e(t);\n        }, Object.defineProperty(e.prototype, \"isNone\", {\n          get: function () {\n            return void 0 === this.updateTime && void 0 === this.exists;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isValidFor = function (t) {\n          return void 0 !== this.updateTime ? t instanceof Mo && t.version.isEqual(this.updateTime) : void 0 !== this.exists ? this.exists === t instanceof Mo : (Or(this.isNone, \"Precondition should be empty\"), !0);\n        }, e.prototype.isEqual = function (t) {\n          return e = this.updateTime, n = t.updateTime, (null != e ? !(!n || !e.isEqual(n)) : e === n) && this.exists === t.exists;\n          var e, n;\n        }, e.NONE = new e(), e;\n      }(),\n          os = function () {\n        function t() {}\n\n        return t.prototype.verifyKeyMatches = function (t) {\n          null != t && Or(t.key.isEqual(this.key), \"Can only apply a mutation to a document with the same key\");\n        }, t.getPostMutationVersion = function (t) {\n          return t instanceof Mo ? t.version : Vi.MIN;\n        }, t;\n      }(),\n          as = function (i) {\n        function e(t, e, n) {\n          var r = i.call(this) || this;\n          return r.key = t, r.value = e, r.precondition = n, r.type = Ka.Set, r;\n        }\n\n        return s(e, i), e.prototype.applyToRemoteDocument = function (t, e) {\n          this.verifyKeyMatches(t), Or(null == e.transformResults, \"Transform results received by SetMutation.\");\n          var n = e.version;\n          return new Mo(this.key, n, this.value, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n          var r = os.getPostMutationVersion(t);\n          return new Mo(this.key, r, this.value, {\n            hasLocalMutations: !0\n          });\n        }, Object.defineProperty(e.prototype, \"isIdempotent\", {\n          get: function () {\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"fieldMask\", {\n          get: function () {\n            return null;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.value.isEqual(t.value) && this.precondition.isEqual(t.precondition);\n        }, e;\n      }(os),\n          ss = function (o) {\n        function e(t, e, n, r) {\n          var i = o.call(this) || this;\n          return i.key = t, i.data = e, i.fieldMask = n, i.precondition = r, i.type = Ka.Patch, i;\n        }\n\n        return s(e, o), e.prototype.applyToRemoteDocument = function (t, e) {\n          if (this.verifyKeyMatches(t), Or(null == e.transformResults, \"Transform results received by PatchMutation.\"), !this.precondition.isValidFor(t)) return new _o(this.key, e.version);\n          var n = this.patchDocument(t);\n          return new Mo(this.key, e.version, n, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n          var r = os.getPostMutationVersion(t),\n              i = this.patchDocument(t);\n          return new Mo(this.key, r, i, {\n            hasLocalMutations: !0\n          });\n        }, Object.defineProperty(e.prototype, \"isIdempotent\", {\n          get: function () {\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.fieldMask.isEqual(t.fieldMask) && this.precondition.isEqual(t.precondition);\n        }, e.prototype.patchDocument = function (t) {\n          var e;\n          return e = t instanceof Mo ? t.data : Za.EMPTY, this.patchObject(e);\n        }, e.prototype.patchObject = function (n) {\n          var r = this;\n          return this.fieldMask.fields.forEach(function (t) {\n            if (!t.isEmpty()) {\n              var e = r.data.field(t);\n              n = void 0 !== e ? n.set(t, e) : n.delete(t);\n            }\n          }), n;\n        }, e;\n      }(os),\n          us = function (r) {\n        function e(t, e) {\n          var n = r.call(this) || this;\n          return n.key = t, n.fieldTransforms = e, n.type = Ka.Transform, n.precondition = is.exists(!0), n;\n        }\n\n        return s(e, r), e.prototype.applyToRemoteDocument = function (t, e) {\n          if (this.verifyKeyMatches(t), Or(null != e.transformResults, \"Transform results missing for TransformMutation.\"), !this.precondition.isValidFor(t)) return new _o(this.key, e.version);\n          var n = this.requireDocument(t),\n              r = this.serverTransformResults(t, e.transformResults),\n              i = e.version,\n              o = this.transformObject(n.data, r);\n          return new Mo(this.key, i, o, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n          var r = this.requireDocument(t),\n              i = this.localTransformResults(n, e),\n              o = this.transformObject(r.data, i);\n          return new Mo(this.key, r.version, o, {\n            hasLocalMutations: !0\n          });\n        }, Object.defineProperty(e.prototype, \"isIdempotent\", {\n          get: function () {\n            for (var t = 0, e = this.fieldTransforms; t < e.length; t++) {\n              if (!e[t].isIdempotent) return !1;\n            }\n\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"fieldMask\", {\n          get: function () {\n            var e = new ji(Ci.comparator);\n            return this.fieldTransforms.forEach(function (t) {\n              return e = e.add(t.field);\n            }), new es(e);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && ci(this.fieldTransforms, t.fieldTransforms) && this.precondition.isEqual(t.precondition);\n        }, e.prototype.requireDocument = function (t) {\n          Or(t instanceof Mo, \"Unknown MaybeDocument type \" + t);\n          var e = t;\n          return Or(e.key.isEqual(this.key), \"Can only transform a document with the same key\"), e;\n        }, e.prototype.serverTransformResults = function (t, e) {\n          var n = [];\n          Or(this.fieldTransforms.length === e.length, \"server transform result count (\" + e.length + \") should match field transform count (\" + this.fieldTransforms.length + \")\");\n\n          for (var r = 0; r < e.length; r++) {\n            var i = this.fieldTransforms[r],\n                o = i.transform,\n                a = null;\n            t instanceof Mo && (a = t.field(i.field) || null), n.push(o.applyToRemoteDocument(a, e[r]));\n          }\n\n          return n;\n        }, e.prototype.localTransformResults = function (t, e) {\n          for (var n = [], r = 0, i = this.fieldTransforms; r < i.length; r++) {\n            var o = i[r],\n                a = o.transform,\n                s = null;\n            e instanceof Mo && (s = e.field(o.field) || null), n.push(a.applyToLocalView(s, t));\n          }\n\n          return n;\n        }, e.prototype.transformObject = function (t, e) {\n          Or(e.length === this.fieldTransforms.length, \"TransformResults length mismatch.\");\n\n          for (var n = 0; n < this.fieldTransforms.length; n++) {\n            var r = this.fieldTransforms[n].field;\n            t = t.set(r, e[n]);\n          }\n\n          return t;\n        }, e;\n      }(os),\n          cs = function (r) {\n        function e(t, e) {\n          var n = r.call(this) || this;\n          return n.key = t, n.precondition = e, n.type = Ka.Delete, n;\n        }\n\n        return s(e, r), e.prototype.applyToRemoteDocument = function (t, e) {\n          return this.verifyKeyMatches(t), Or(null == e.transformResults, \"Transform results received by DeleteMutation.\"), new Oo(this.key, e.version, {\n            hasCommittedMutations: !0\n          });\n        }, e.prototype.applyToLocalView = function (t, e, n) {\n          return this.verifyKeyMatches(t), this.precondition.isValidFor(t) ? (t && Or(t.key.isEqual(this.key), \"Can only apply mutation to document with same key\"), new Oo(this.key, Vi.forDeletedDoc())) : t;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.key.isEqual(t.key) && this.precondition.isEqual(t.precondition);\n        }, Object.defineProperty(e.prototype, \"isIdempotent\", {\n          get: function () {\n            return !0;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"fieldMask\", {\n          get: function () {\n            return null;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e;\n      }(os),\n          hs = function () {\n        function t(t, e, n) {\n          this.remoteDocumentCache = t, this.mutationQueue = e, this.indexManager = n;\n        }\n\n        return t.prototype.getDocument = function (e, n) {\n          var r = this;\n          return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(e, n).next(function (t) {\n            return r.getDocumentInternal(e, n, t);\n          });\n        }, t.prototype.getDocumentInternal = function (t, r, i) {\n          return this.remoteDocumentCache.getEntry(t, r).next(function (t) {\n            for (var e = 0, n = i; e < n.length; e++) {\n              t = n[e].applyToLocalView(r, t);\n            }\n\n            return t;\n          });\n        }, t.prototype.applyLocalMutationsToDocuments = function (t, e, i) {\n          var o = Hi();\n          return e.forEach(function (t, e) {\n            for (var n = 0, r = i; n < r.length; n++) {\n              e = r[n].applyToLocalView(t, e);\n            }\n\n            o = o.insert(t, e);\n          }), o;\n        }, t.prototype.getDocuments = function (e, t) {\n          var n = this;\n          return this.remoteDocumentCache.getEntries(e, t).next(function (t) {\n            return n.getLocalViewOfDocuments(e, t);\n          });\n        }, t.prototype.getLocalViewOfDocuments = function (r, i) {\n          var o = this;\n          return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(r, i).next(function (t) {\n            var e = o.applyLocalMutationsToDocuments(r, i, t),\n                n = zi();\n            return e.forEach(function (t, e) {\n              e || (e = new Oo(t, Vi.forDeletedDoc())), n = n.insert(t, e);\n            }), n;\n          });\n        }, t.prototype.getDocumentsMatchingQuery = function (t, e) {\n          return e.isDocumentQuery() ? this.getDocumentsMatchingDocumentQuery(t, e.path) : e.isCollectionGroupQuery() ? this.getDocumentsMatchingCollectionGroupQuery(t, e) : this.getDocumentsMatchingCollectionQuery(t, e);\n        }, t.prototype.getDocumentsMatchingDocumentQuery = function (t, e) {\n          return this.getDocument(t, new Di(e)).next(function (t) {\n            var e = Xi();\n            return t instanceof Mo && (e = e.insert(t.key, t)), e;\n          });\n        }, t.prototype.getDocumentsMatchingCollectionGroupQuery = function (n, r) {\n          var i = this;\n          Or(r.path.isEmpty(), \"Currently we only support collection group queries at the root.\");\n          var o = r.collectionGroup,\n              a = Xi();\n          return this.indexManager.getCollectionParents(n, o).next(function (t) {\n            return oo.forEach(t, function (t) {\n              var e = r.asCollectionQueryAtPath(t.child(o));\n              return i.getDocumentsMatchingCollectionQuery(n, e).next(function (t) {\n                t.forEach(function (t, e) {\n                  a = a.insert(t, e);\n                });\n              });\n            }).next(function () {\n              return a;\n            });\n          });\n        }, t.prototype.getDocumentsMatchingCollectionQuery = function (e, h) {\n          var l,\n              n = this;\n          return this.remoteDocumentCache.getDocumentsMatchingQuery(e, h).next(function (t) {\n            return l = t, n.mutationQueue.getAllMutationBatchesAffectingQuery(e, h);\n          }).next(function (t) {\n            for (var e = 0, n = t; e < n.length; e++) for (var r = n[e], i = 0, o = r.mutations; i < o.length; i++) {\n              var a = o[i],\n                  s = a.key;\n\n              if (h.path.isImmediateParentOf(s.path)) {\n                var u = l.get(s),\n                    c = a.applyToLocalView(u, u, r.localWriteTime);\n                l = c instanceof Mo ? l.insert(s, c) : l.remove(s);\n              }\n            }\n          }).next(function () {\n            return l.forEach(function (t, e) {\n              h.matches(e) || (l = l.remove(t));\n            }), l;\n          });\n        }, t;\n      }(),\n          ls = function () {\n        function t() {\n          this.refsByKey = new ji(fs.compareByKey), this.refsByTarget = new ji(fs.compareByTargetId);\n        }\n\n        return t.prototype.isEmpty = function () {\n          return this.refsByKey.isEmpty();\n        }, t.prototype.addReference = function (t, e) {\n          var n = new fs(t, e);\n          this.refsByKey = this.refsByKey.add(n), this.refsByTarget = this.refsByTarget.add(n);\n        }, t.prototype.addReferences = function (t, e) {\n          var n = this;\n          t.forEach(function (t) {\n            return n.addReference(t, e);\n          });\n        }, t.prototype.removeReference = function (t, e) {\n          this.removeRef(new fs(t, e));\n        }, t.prototype.removeReferences = function (t, e) {\n          var n = this;\n          t.forEach(function (t) {\n            return n.removeReference(t, e);\n          });\n        }, t.prototype.removeReferencesForId = function (t) {\n          var e = this,\n              n = Di.EMPTY,\n              r = new fs(n, t),\n              i = new fs(n, t + 1),\n              o = [];\n          return this.refsByTarget.forEachInRange([r, i], function (t) {\n            e.removeRef(t), o.push(t.key);\n          }), o;\n        }, t.prototype.removeAllReferences = function () {\n          var e = this;\n          this.refsByKey.forEach(function (t) {\n            return e.removeRef(t);\n          });\n        }, t.prototype.removeRef = function (t) {\n          this.refsByKey = this.refsByKey.delete(t), this.refsByTarget = this.refsByTarget.delete(t);\n        }, t.prototype.referencesForId = function (t) {\n          var e = Di.EMPTY,\n              n = new fs(e, t),\n              r = new fs(e, t + 1),\n              i = to();\n          return this.refsByTarget.forEachInRange([n, r], function (t) {\n            i = i.add(t.key);\n          }), i;\n        }, t.prototype.containsKey = function (t) {\n          var e = new fs(t, 0),\n              n = this.refsByKey.firstAfterOrEqual(e);\n          return null !== n && t.isEqual(n.key);\n        }, t;\n      }(),\n          fs = function () {\n        function t(t, e) {\n          this.key = t, this.targetOrBatchId = e;\n        }\n\n        return t.compareByKey = function (t, e) {\n          return Di.comparator(t.key, e.key) || ui(t.targetOrBatchId, e.targetOrBatchId);\n        }, t.compareByTargetId = function (t, e) {\n          return ui(t.targetOrBatchId, e.targetOrBatchId) || Di.comparator(t.key, e.key);\n        }, t;\n      }(),\n          ps = function () {\n        function l(t, e) {\n          this.persistence = t, this.localViewReferences = new ls(), this.queryDataByTarget = {}, Or(t.started, \"LocalStore was passed an unstarted persistence implementation\"), this.persistence.referenceDelegate.setInMemoryPins(this.localViewReferences), this.mutationQueue = t.getMutationQueue(e), this.remoteDocuments = t.getRemoteDocumentCache(), this.queryCache = t.getQueryCache(), this.localDocuments = new hs(this.remoteDocuments, this.mutationQueue, this.persistence.getIndexManager());\n        }\n\n        return l.prototype.handleUserChange = function (e) {\n          var y = this;\n          return this.persistence.runTransaction(\"Handle user change\", \"readonly\", function (d) {\n            var m;\n            return y.mutationQueue.getAllMutationBatches(d).next(function (t) {\n              return m = t, y.mutationQueue = y.persistence.getMutationQueue(e), y.localDocuments = new hs(y.remoteDocuments, y.mutationQueue, y.persistence.getIndexManager()), y.mutationQueue.getAllMutationBatches(d);\n            }).next(function (t) {\n              for (var e = [], n = [], r = to(), i = 0, o = m; i < o.length; i++) {\n                var a = o[i];\n                e.push(a.batchId);\n\n                for (var s = 0, u = a.mutations; s < u.length; s++) {\n                  var c = u[s];\n                  r = r.add(c.key);\n                }\n              }\n\n              for (var h = 0, l = t; h < l.length; h++) {\n                a = l[h];\n                n.push(a.batchId);\n\n                for (var f = 0, p = a.mutations; f < p.length; f++) {\n                  c = p[f];\n                  r = r.add(c.key);\n                }\n              }\n\n              return y.localDocuments.getDocuments(d, r).next(function (t) {\n                return {\n                  affectedDocuments: t,\n                  removedBatchIds: e,\n                  addedBatchIds: n\n                };\n              });\n            });\n          });\n        }, l.prototype.localWrite = function (c) {\n          var h = this,\n              l = Fi.now(),\n              t = c.reduce(function (t, e) {\n            return t.add(e.key);\n          }, to());\n          return this.persistence.runTransaction(\"Locally write mutations\", \"readwrite\", function (u) {\n            return h.localDocuments.getDocuments(u, t).next(function (n) {\n              for (var t = [], e = 0, r = c; e < r.length; e++) {\n                var i = r[e],\n                    o = n.get(i.key);\n\n                if (!i.isIdempotent) {\n                  var a = i.fieldMask;\n\n                  if (a) {\n                    var s = o instanceof Mo ? a.applyTo(o.data) : Za.EMPTY;\n                    t.push(new ss(i.key, s, a, is.exists(!0)));\n                  }\n                }\n              }\n\n              return h.mutationQueue.addMutationBatch(u, l, t, c).next(function (t) {\n                var e = t.applyToLocalDocumentSet(n);\n                return {\n                  batchId: t.batchId,\n                  changes: e\n                };\n              });\n            });\n          });\n        }, l.prototype.lookupMutationDocuments = function (t) {\n          var n = this;\n          return this.persistence.runTransaction(\"Lookup mutation documents\", \"readonly\", function (e) {\n            return n.mutationQueue.lookupMutationKeys(e, t).next(function (t) {\n              return t ? n.localDocuments.getDocuments(e, t) : oo.resolve(null);\n            });\n          });\n        }, l.prototype.acknowledgeBatch = function (r) {\n          var i = this;\n          return this.persistence.runTransaction(\"Acknowledge batch\", \"readwrite-primary\", function (t) {\n            var e = r.batch.keys(),\n                n = i.remoteDocuments.newChangeBuffer();\n            return i.mutationQueue.acknowledgeBatch(t, r.batch, r.streamToken).next(function () {\n              return i.applyWriteToRemoteDocuments(t, r, n);\n            }).next(function () {\n              return n.apply(t);\n            }).next(function () {\n              return i.mutationQueue.performConsistencyCheck(t);\n            }).next(function () {\n              return i.localDocuments.getDocuments(t, e);\n            });\n          });\n        }, l.prototype.rejectBatch = function (t) {\n          var r = this;\n          return this.persistence.runTransaction(\"Reject batch\", \"readwrite-primary\", function (e) {\n            var n;\n            return r.mutationQueue.lookupMutationBatch(e, t).next(function (t) {\n              return Or(null !== t, \"Attempt to reject nonexistent batch!\"), n = t.keys(), r.mutationQueue.removeMutationBatch(e, t);\n            }).next(function () {\n              return r.mutationQueue.performConsistencyCheck(e);\n            }).next(function () {\n              return r.localDocuments.getDocuments(e, n);\n            });\n          });\n        }, l.prototype.getLastStreamToken = function () {\n          var e = this;\n          return this.persistence.runTransaction(\"Get last stream token\", \"readonly\", function (t) {\n            return e.mutationQueue.getLastStreamToken(t);\n          });\n        }, l.prototype.setLastStreamToken = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"Set last stream token\", \"readwrite-primary\", function (t) {\n            return n.mutationQueue.setLastStreamToken(t, e);\n          });\n        }, l.prototype.getLastRemoteSnapshotVersion = function () {\n          var e = this;\n          return this.persistence.runTransaction(\"Get last remote snapshot version\", \"readonly\", function (t) {\n            return e.queryCache.getLastRemoteSnapshotVersion(t);\n          });\n        }, l.prototype.applyRemoteEvent = function (u) {\n          var c = this,\n              h = this.remoteDocuments.newChangeBuffer();\n          return this.persistence.runTransaction(\"Apply remote event\", \"readwrite-primary\", function (o) {\n            var a = [],\n                s = to();\n            Ur(u.targetChanges, function (t, e) {\n              var n = c.queryDataByTarget[t];\n\n              if (n) {\n                e.addedDocuments.forEach(function (t) {\n                  s = s.add(t);\n                }), e.modifiedDocuments.forEach(function (t) {\n                  s = s.add(t);\n                }), a.push(c.queryCache.removeMatchingKeys(o, e.removedDocuments, t).next(function () {\n                  return c.queryCache.addMatchingKeys(o, e.addedDocuments, t);\n                }));\n                var r = e.resumeToken;\n\n                if (0 < r.length) {\n                  var i = n;\n                  n = n.copy({\n                    resumeToken: r,\n                    snapshotVersion: u.snapshotVersion\n                  }), c.queryDataByTarget[t] = n, l.shouldPersistQueryData(i, n, e) && a.push(c.queryCache.updateQueryData(o, n));\n                }\n              }\n            });\n            var i = zi(),\n                n = to();\n            u.documentUpdates.forEach(function (t, e) {\n              n = n.add(t);\n            }), a.push(h.getEntries(o, n).next(function (r) {\n              u.documentUpdates.forEach(function (t, e) {\n                var n = r.get(t);\n                null == n || e.version.isEqual(Vi.MIN) || s.has(e.key) && !n.hasPendingWrites || 0 <= e.version.compareTo(n.version) ? (h.addEntry(e), i = i.insert(t, e)) : Ar(\"LocalStore\", \"Ignoring outdated watch update for \", t, \". Current version:\", n.version, \" Watch version:\", e.version), u.resolvedLimboDocuments.has(t) && a.push(c.persistence.referenceDelegate.updateLimboDocument(o, t));\n              });\n            }));\n            var e = u.snapshotVersion;\n\n            if (!e.isEqual(Vi.MIN)) {\n              var t = c.queryCache.getLastRemoteSnapshotVersion(o).next(function (t) {\n                return Or(0 <= e.compareTo(t), \"Watch stream reverted to previous snapshot?? \" + e + \" < \" + t), c.queryCache.setTargetsMetadata(o, o.currentSequenceNumber, e);\n              });\n              a.push(t);\n            }\n\n            return oo.waitFor(a).next(function () {\n              return h.apply(o);\n            }).next(function () {\n              return c.localDocuments.getLocalViewOfDocuments(o, i);\n            });\n          });\n        }, l.shouldPersistQueryData = function (t, e, n) {\n          return 0 !== e.resumeToken.length && (0 === t.resumeToken.length || e.snapshotVersion.toMicroseconds() - t.snapshotVersion.toMicroseconds() >= this.RESUME_TOKEN_MAX_AGE_MICROS || 0 < n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size);\n        }, l.prototype.notifyLocalViewChanges = function (t) {\n          var n = this;\n          return this.persistence.runTransaction(\"notifyLocalViewChanges\", \"readwrite\", function (e) {\n            return oo.forEach(t, function (t) {\n              return n.localViewReferences.addReferences(t.addedKeys, t.targetId), n.localViewReferences.removeReferences(t.removedKeys, t.targetId), oo.forEach(t.removedKeys, function (t) {\n                return n.persistence.referenceDelegate.removeReference(e, t);\n              });\n            });\n          });\n        }, l.prototype.nextMutationBatch = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"Get next mutation batch\", \"readonly\", function (t) {\n            return void 0 === e && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(t, e);\n          });\n        }, l.prototype.readDocument = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"read document\", \"readonly\", function (t) {\n            return n.localDocuments.getDocument(t, e);\n          });\n        }, l.prototype.allocateQuery = function (r) {\n          var i = this;\n          return this.persistence.runTransaction(\"Allocate query\", \"readwrite\", function (e) {\n            var n;\n            return i.queryCache.getQueryData(e, r).next(function (t) {\n              return t ? (n = t, oo.resolve()) : i.queryCache.allocateTargetId(e).next(function (t) {\n                return n = new ma(r, t, ha.Listen, e.currentSequenceNumber), i.queryCache.addQueryData(e, n);\n              });\n            }).next(function () {\n              return Or(!i.queryDataByTarget[n.targetId], \"Tried to allocate an already allocated query: \" + r), i.queryDataByTarget[n.targetId] = n;\n            });\n          });\n        }, l.prototype.releaseQuery = function (o, a) {\n          var s = this,\n              t = a ? \"readwrite\" : \"readwrite-primary\";\n          return this.persistence.runTransaction(\"Release query\", t, function (i) {\n            return s.queryCache.getQueryData(i, o).next(function (t) {\n              Or(null != t, \"Tried to release nonexistent query: \" + o);\n              var e = t.targetId,\n                  n = s.queryDataByTarget[e],\n                  r = s.localViewReferences.removeReferencesForId(e);\n              return delete s.queryDataByTarget[e], a ? oo.resolve() : oo.forEach(r, function (t) {\n                return s.persistence.referenceDelegate.removeReference(i, t);\n              }).next(function () {\n                return s.persistence.referenceDelegate.removeTarget(i, n);\n              });\n            });\n          });\n        }, l.prototype.executeQuery = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"Execute query\", \"readonly\", function (t) {\n            return n.localDocuments.getDocumentsMatchingQuery(t, e);\n          });\n        }, l.prototype.remoteDocumentKeys = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"Remote document keys\", \"readonly\", function (t) {\n            return n.queryCache.getMatchingKeysForTargetId(t, e);\n          });\n        }, l.prototype.getActiveClients = function () {\n          return this.persistence.getActiveClients();\n        }, l.prototype.removeCachedMutationBatchMetadata = function (t) {\n          this.mutationQueue.removeCachedMutationKeys(t);\n        }, l.prototype.setNetworkEnabled = function (t) {\n          this.persistence.setNetworkEnabled(t);\n        }, l.prototype.applyWriteToRemoteDocuments = function (t, i, o) {\n          var e = this,\n              a = i.batch,\n              n = a.keys(),\n              s = oo.resolve();\n          return n.forEach(function (r) {\n            s = s.next(function () {\n              return o.getEntry(t, r);\n            }).next(function (t) {\n              var e = t,\n                  n = i.docVersions.get(r);\n              Or(null !== n, \"ackVersions should contain every doc in the write.\"), (!e || e.version.compareTo(n) < 0) && ((e = a.applyToRemoteDocument(r, e, i)) ? o.addEntry(e) : Or(!t, \"Mutation batch \" + a + \" applied to document \" + t + \" resulted in null\"));\n            });\n          }), s.next(function () {\n            return e.mutationQueue.removeMutationBatch(t, a);\n          });\n        }, l.prototype.collectGarbage = function (e) {\n          var n = this;\n          return this.persistence.runTransaction(\"Collect garbage\", \"readwrite-primary\", function (t) {\n            return e.collect(t, n.queryDataByTarget);\n          });\n        }, l.prototype.getQueryForTarget = function (e) {\n          var n = this;\n          return this.queryDataByTarget[e] ? Promise.resolve(this.queryDataByTarget[e].query) : this.persistence.runTransaction(\"Get query data\", \"readonly\", function (t) {\n            return n.queryCache.getQueryDataForTarget(t, e).next(function (t) {\n              return t ? t.query : null;\n            });\n          });\n        }, l.prototype.getNewDocumentChanges = function () {\n          var e = this;\n          return this.persistence.runTransaction(\"Get new document changes\", \"readonly\", function (t) {\n            return e.remoteDocuments.getNewDocumentChanges(t);\n          });\n        }, l.RESUME_TOKEN_MAX_AGE_MICROS = 3e8, l;\n      }(),\n          ds = function () {\n        function t(t, e) {\n          this.indexManager = t, this.referenceDelegate = e, this.mutationQueue = [], this.nextBatchId = 1, this.lastStreamToken = Pr(), this.batchesByDocumentKey = new ji(fs.compareByKey);\n        }\n\n        return t.prototype.checkEmpty = function (t) {\n          return oo.resolve(0 === this.mutationQueue.length);\n        }, t.prototype.acknowledgeBatch = function (t, e, n) {\n          var r = e.batchId,\n              i = this.indexOfExistingBatchId(r, \"acknowledged\");\n          Or(0 === i, \"Can only acknowledge the first batch in the mutation queue\");\n          var o = this.mutationQueue[i];\n          return Or(r === o.batchId, \"Queue ordering failure: expected batch \" + r + \", got batch \" + o.batchId), this.lastStreamToken = n, oo.resolve();\n        }, t.prototype.getLastStreamToken = function (t) {\n          return oo.resolve(this.lastStreamToken);\n        }, t.prototype.setLastStreamToken = function (t, e) {\n          return this.lastStreamToken = e, oo.resolve();\n        }, t.prototype.addMutationBatch = function (t, e, n, r) {\n          Or(0 !== r.length, \"Mutation batches should not be empty\");\n          var i = this.nextBatchId;\n          (this.nextBatchId++, 0 < this.mutationQueue.length) && Or(this.mutationQueue[this.mutationQueue.length - 1].batchId < i, \"Mutation batchIDs must be monotonically increasing order\");\n          var o = new ro(i, e, n, r);\n          this.mutationQueue.push(o);\n\n          for (var a = 0, s = r; a < s.length; a++) {\n            var u = s[a];\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new fs(u.key, i)), this.indexManager.addToCollectionParentIndex(t, u.key.path.popLast());\n          }\n\n          return oo.resolve(o);\n        }, t.prototype.lookupMutationBatch = function (t, e) {\n          return oo.resolve(this.findMutationBatch(e));\n        }, t.prototype.lookupMutationKeys = function (t, e) {\n          var n = this.findMutationBatch(e);\n          return Or(null != n, \"Failed to find local mutation batch.\"), oo.resolve(n.keys());\n        }, t.prototype.getNextMutationBatchAfterBatchId = function (t, e) {\n          var n = e + 1,\n              r = this.indexOfBatchId(n),\n              i = r < 0 ? 0 : r;\n          return oo.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);\n        }, t.prototype.getAllMutationBatches = function (t) {\n          return oo.resolve(this.mutationQueue.slice());\n        }, t.prototype.getAllMutationBatchesAffectingDocumentKey = function (t, n) {\n          var r = this,\n              e = new fs(n, 0),\n              i = new fs(n, Number.POSITIVE_INFINITY),\n              o = [];\n          return this.batchesByDocumentKey.forEachInRange([e, i], function (t) {\n            Or(n.isEqual(t.key), \"Should only iterate over a single key's batches\");\n            var e = r.findMutationBatch(t.targetOrBatchId);\n            Or(null !== e, \"Batches in the index must exist in the main table\"), o.push(e);\n          }), oo.resolve(o);\n        }, t.prototype.getAllMutationBatchesAffectingDocumentKeys = function (t, e) {\n          var r = this,\n              i = new ji(ui);\n          return e.forEach(function (e) {\n            var t = new fs(e, 0),\n                n = new fs(e, Number.POSITIVE_INFINITY);\n            r.batchesByDocumentKey.forEachInRange([t, n], function (t) {\n              Or(e.isEqual(t.key), \"For each key, should only iterate over a single key's batches\"), i = i.add(t.targetOrBatchId);\n            });\n          }), oo.resolve(this.findMutationBatches(i));\n        }, t.prototype.getAllMutationBatchesAffectingQuery = function (t, e) {\n          Or(!e.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n          var n = e.path,\n              r = n.length + 1,\n              i = n;\n          Di.isDocumentKey(i) || (i = i.child(\"\"));\n          var o = new fs(new Di(i), 0),\n              a = new ji(ui);\n          return this.batchesByDocumentKey.forEachWhile(function (t) {\n            var e = t.key.path;\n            return !!n.isPrefixOf(e) && (e.length === r && (a = a.add(t.targetOrBatchId)), !0);\n          }, o), oo.resolve(this.findMutationBatches(a));\n        }, t.prototype.findMutationBatches = function (t) {\n          var n = this,\n              r = [];\n          return t.forEach(function (t) {\n            var e = n.findMutationBatch(t);\n            null !== e && r.push(e);\n          }), r;\n        }, t.prototype.removeMutationBatch = function (n, r) {\n          var i = this;\n          Or(0 === this.indexOfExistingBatchId(r.batchId, \"removed\"), \"Can only remove the first entry of the mutation queue\"), this.mutationQueue.shift();\n          var o = this.batchesByDocumentKey;\n          return oo.forEach(r.mutations, function (t) {\n            var e = new fs(t.key, r.batchId);\n            return o = o.delete(e), i.referenceDelegate.removeMutationReference(n, t.key);\n          }).next(function () {\n            i.batchesByDocumentKey = o;\n          });\n        }, t.prototype.removeCachedMutationKeys = function (t) {}, t.prototype.containsKey = function (t, e) {\n          var n = new fs(e, 0),\n              r = this.batchesByDocumentKey.firstAfterOrEqual(n);\n          return oo.resolve(e.isEqual(r && r.key));\n        }, t.prototype.performConsistencyCheck = function (t) {\n          return 0 === this.mutationQueue.length && Or(this.batchesByDocumentKey.isEmpty(), \"Document leak -- detected dangling mutation references when queue is empty.\"), oo.resolve();\n        }, t.prototype.indexOfExistingBatchId = function (t, e) {\n          var n = this.indexOfBatchId(t);\n          return Or(0 <= n && n < this.mutationQueue.length, \"Batches must exist to be \" + e), n;\n        }, t.prototype.indexOfBatchId = function (t) {\n          return 0 === this.mutationQueue.length ? 0 : t - this.mutationQueue[0].batchId;\n        }, t.prototype.findMutationBatch = function (t) {\n          var e = this.indexOfBatchId(t);\n          if (e < 0 || e >= this.mutationQueue.length) return null;\n          var n = this.mutationQueue[e];\n          return Or(n.batchId === t, \"If found batch must match\"), n;\n        }, t;\n      }(),\n          ms = function () {\n        function t(t) {\n          this.persistence = t, this.queries = new Po(function (t) {\n            return t.canonicalId();\n          }), this.lastRemoteSnapshotVersion = Vi.MIN, this.highestTargetId = 0, this.highestSequenceNumber = 0, this.references = new ls(), this.targetCount = 0, this.targetIdGenerator = yo.forQueryCache();\n        }\n\n        return t.prototype.getTargetCount = function (t) {\n          return oo.resolve(this.targetCount);\n        }, t.prototype.forEachTarget = function (t, n) {\n          return this.queries.forEach(function (t, e) {\n            return n(e);\n          }), oo.resolve();\n        }, t.prototype.getLastRemoteSnapshotVersion = function (t) {\n          return oo.resolve(this.lastRemoteSnapshotVersion);\n        }, t.prototype.getHighestSequenceNumber = function (t) {\n          return oo.resolve(this.highestSequenceNumber);\n        }, t.prototype.allocateTargetId = function (t) {\n          var e = this.targetIdGenerator.after(this.highestTargetId);\n          return this.highestTargetId = e, oo.resolve(e);\n        }, t.prototype.setTargetsMetadata = function (t, e, n) {\n          return n && (this.lastRemoteSnapshotVersion = n), e > this.highestSequenceNumber && (this.highestSequenceNumber = e), oo.resolve();\n        }, t.prototype.saveQueryData = function (t) {\n          this.queries.set(t.query, t);\n          var e = t.targetId;\n          e > this.highestTargetId && (this.highestTargetId = e), t.sequenceNumber > this.highestSequenceNumber && (this.highestSequenceNumber = t.sequenceNumber);\n        }, t.prototype.addQueryData = function (t, e) {\n          return Or(!this.queries.has(e.query), \"Adding a query that already exists\"), this.saveQueryData(e), this.targetCount += 1, oo.resolve();\n        }, t.prototype.updateQueryData = function (t, e) {\n          return Or(this.queries.has(e.query), \"Updating a non-existent query\"), this.saveQueryData(e), oo.resolve();\n        }, t.prototype.removeQueryData = function (t, e) {\n          return Or(0 < this.targetCount, \"Removing a target from an empty cache\"), Or(this.queries.has(e.query), \"Removing a non-existent target from the cache\"), this.queries.delete(e.query), this.references.removeReferencesForId(e.targetId), this.targetCount -= 1, oo.resolve();\n        }, t.prototype.removeTargets = function (n, r, i) {\n          var o = this,\n              a = 0,\n              s = [];\n          return this.queries.forEach(function (t, e) {\n            e.sequenceNumber <= r && !i[e.targetId] && (o.queries.delete(t), s.push(o.removeMatchingKeysForTargetId(n, e.targetId)), a++);\n          }), oo.waitFor(s).next(function () {\n            return a;\n          });\n        }, t.prototype.getQueryCount = function (t) {\n          return oo.resolve(this.targetCount);\n        }, t.prototype.getQueryData = function (t, e) {\n          var n = this.queries.get(e) || null;\n          return oo.resolve(n);\n        }, t.prototype.getQueryDataForTarget = function (t, e) {\n          return Mr(\"Not yet implemented.\");\n        }, t.prototype.addMatchingKeys = function (e, t, n) {\n          this.references.addReferences(t, n);\n          var r = this.persistence.referenceDelegate,\n              i = [];\n          return r && t.forEach(function (t) {\n            i.push(r.addReference(e, t));\n          }), oo.waitFor(i);\n        }, t.prototype.removeMatchingKeys = function (e, t, n) {\n          this.references.removeReferences(t, n);\n          var r = this.persistence.referenceDelegate,\n              i = [];\n          return r && t.forEach(function (t) {\n            i.push(r.removeReference(e, t));\n          }), oo.waitFor(i);\n        }, t.prototype.removeMatchingKeysForTargetId = function (t, e) {\n          return this.references.removeReferencesForId(e), oo.resolve();\n        }, t.prototype.getMatchingKeysForTargetId = function (t, e) {\n          var n = this.references.referencesForId(e);\n          return oo.resolve(n);\n        }, t.prototype.containsKey = function (t, e) {\n          return oo.resolve(this.references.containsKey(e));\n        }, t;\n      }();\n\n      var ys = function () {\n        function t(t, e) {\n          this.indexManager = t, this.sizer = e, this.docs = new Ui(Di.comparator), this.newDocumentChanges = to(), this.size = 0;\n        }\n\n        return t.prototype.addEntries = function (t, e, n) {\n          for (var r = [], i = 0, o = e; i < o.length; i++) {\n            var a = o[i],\n                s = a.maybeDocument.key;\n            this.docs = this.docs.insert(s, a), this.newDocumentChanges = this.newDocumentChanges.add(s), r.push(this.indexManager.addToCollectionParentIndex(t, s.path.popLast()));\n          }\n\n          return this.size += n, oo.waitFor(r);\n        }, t.prototype.removeEntry = function (t, e) {\n          var n = this.docs.get(e);\n          return n ? (this.docs = this.docs.remove(e), this.size -= n.size, oo.resolve(n.size)) : oo.resolve(0);\n        }, t.prototype.getEntry = function (t, e) {\n          var n = this.docs.get(e);\n          return oo.resolve(n ? n.maybeDocument : null);\n        }, t.prototype.getSizedEntry = function (t, e) {\n          return oo.resolve(this.docs.get(e));\n        }, t.prototype.getEntries = function (t, e) {\n          var n = this,\n              r = Hi();\n          return e.forEach(function (t) {\n            var e = n.docs.get(t);\n            r = r.insert(t, e ? e.maybeDocument : null);\n          }), oo.resolve(r);\n        }, t.prototype.getSizedEntries = function (t, e) {\n          var n = this,\n              r = Hi(),\n              i = new Ui(Di.comparator);\n          return e.forEach(function (t) {\n            var e = n.docs.get(t);\n            r = r.insert(t, e ? e.maybeDocument : null), i = i.insert(t, e ? e.size : 0);\n          }), oo.resolve({\n            maybeDocuments: r,\n            sizeMap: i\n          });\n        }, t.prototype.getDocumentsMatchingQuery = function (t, e) {\n          Or(!e.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n\n          for (var n = Xi(), r = new Di(e.path.child(\"\")), i = this.docs.getIteratorFrom(r); i.hasNext();) {\n            var o = i.getNext(),\n                a = o.key,\n                s = o.value.maybeDocument;\n            if (!e.path.isPrefixOf(a.path)) break;\n            s instanceof Mo && e.matches(s) && (n = n.insert(s.key, s));\n          }\n\n          return oo.resolve(n);\n        }, t.prototype.forEachDocumentKey = function (t, e) {\n          return oo.forEach(this.docs, function (t) {\n            return e(t);\n          });\n        }, t.prototype.getNewDocumentChanges = function (t) {\n          var r = this,\n              i = zi();\n          return this.newDocumentChanges.forEach(function (t) {\n            var e = r.docs.get(t),\n                n = e ? e.maybeDocument : new Oo(t, Vi.forDeletedDoc());\n            i = i.insert(t, n);\n          }), this.newDocumentChanges = to(), oo.resolve(i);\n        }, t.prototype.newChangeBuffer = function () {\n          return new gs(this.sizer, this);\n        }, t.prototype.getSize = function (t) {\n          return oo.resolve(this.size);\n        }, t;\n      }(),\n          gs = function (r) {\n        function t(t, e) {\n          var n = r.call(this) || this;\n          return n.sizer = t, n.documentCache = e, n;\n        }\n\n        return s(t, r), t.prototype.applyChanges = function (t) {\n          var i = this,\n              e = this.assertChanges(),\n              o = 0,\n              a = [];\n          return e.forEach(function (t, e) {\n            var n = i.documentSizes.get(t);\n            Or(void 0 !== n, \"Attempting to change document \" + t.toString() + \" without having read it first\");\n            var r = i.sizer(e);\n            o += r - n, a.push({\n              maybeDocument: e,\n              size: r\n            });\n          }), this.documentCache.addEntries(t, a, o);\n        }, t.prototype.getFromCache = function (t, e) {\n          return this.documentCache.getSizedEntry(t, e);\n        }, t.prototype.getAllFromCache = function (t, e) {\n          return this.documentCache.getSizedEntries(t, e);\n        }, t;\n      }(Lo),\n          vs = function () {\n        function r(t, e) {\n          var n = this;\n          this.clientId = t, this.mutationQueues = {}, this.listenSequence = new wi(0), this._started = !1, this._started = !0, this.referenceDelegate = e(this), this.queryCache = new ms(this);\n          this.indexManager = new jo(), this.remoteDocumentCache = new ys(this.indexManager, function (t) {\n            return n.referenceDelegate.documentSize(t);\n          });\n        }\n\n        return r.createLruPersistence = function (t, e, n) {\n          return new r(t, function (t) {\n            return new Es(t, new ya(e), n);\n          });\n        }, r.createEagerPersistence = function (t) {\n          return new r(t, function (t) {\n            return new ws(t);\n          });\n        }, r.prototype.shutdown = function () {\n          return this._started = !1, Promise.resolve();\n        }, Object.defineProperty(r.prototype, \"started\", {\n          get: function () {\n            return this._started;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), r.prototype.getActiveClients = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return [2, [this.clientId]];\n            });\n          });\n        }, r.prototype.setPrimaryStateListener = function (t) {\n          return t(!0);\n        }, r.prototype.setDatabaseDeletedListener = function () {}, r.prototype.setNetworkEnabled = function (t) {}, r.prototype.getIndexManager = function () {\n          return this.indexManager;\n        }, r.prototype.getMutationQueue = function (t) {\n          var e = this.mutationQueues[t.toKey()];\n          return e || (e = new ds(this.indexManager, this.referenceDelegate), this.mutationQueues[t.toKey()] = e), e;\n        }, r.prototype.getQueryCache = function () {\n          return this.queryCache;\n        }, r.prototype.getRemoteDocumentCache = function () {\n          return this.remoteDocumentCache;\n        }, r.prototype.runTransaction = function (t, e, n) {\n          var r = this;\n          Ar(\"MemoryPersistence\", \"Starting transaction:\", t);\n          var i = new bs(this.listenSequence.next());\n          return this.referenceDelegate.onTransactionStarted(), n(i).next(function (t) {\n            return r.referenceDelegate.onTransactionCommitted(i).next(function () {\n              return t;\n            });\n          }).toPromise();\n        }, r.prototype.mutationQueuesContainKey = function (e, n) {\n          return oo.or((t = this.mutationQueues, r = [], Br(t, function (t, e) {\n            return r.push(e);\n          }), r).map(function (t) {\n            return function () {\n              return t.containsKey(e, n);\n            };\n          }));\n          var t, r;\n        }, r;\n      }(),\n          bs = function (t) {\n        this.currentSequenceNumber = t;\n      },\n          ws = function () {\n        function t(t) {\n          this.persistence = t;\n        }\n\n        return t.prototype.setInMemoryPins = function (t) {\n          this.inMemoryPins = t;\n        }, t.prototype.addReference = function (t, e) {\n          return this.orphanedDocuments.delete(e), oo.resolve();\n        }, t.prototype.removeReference = function (t, e) {\n          return this.orphanedDocuments.add(e), oo.resolve();\n        }, t.prototype.removeMutationReference = function (t, e) {\n          return this.orphanedDocuments.add(e), oo.resolve();\n        }, t.prototype.removeTarget = function (t, e) {\n          var n = this,\n              r = this.persistence.getQueryCache();\n          return r.getMatchingKeysForTargetId(t, e.targetId).next(function (t) {\n            t.forEach(function (t) {\n              return n.orphanedDocuments.add(t);\n            });\n          }).next(function () {\n            return r.removeQueryData(t, e);\n          });\n        }, t.prototype.onTransactionStarted = function () {\n          this.orphanedDocuments = new Set();\n        }, t.prototype.onTransactionCommitted = function (n) {\n          var t = this,\n              r = this.persistence.getRemoteDocumentCache();\n          return oo.forEach(this.orphanedDocuments, function (e) {\n            return t.isReferenced(n, e).next(function (t) {\n              return t ? oo.resolve() : r.removeEntry(n, e).next(function () {});\n            });\n          });\n        }, t.prototype.updateLimboDocument = function (t, e) {\n          var n = this;\n          return this.isReferenced(t, e).next(function (t) {\n            t ? n.orphanedDocuments.delete(e) : n.orphanedDocuments.add(e);\n          });\n        }, t.prototype.documentSize = function (t) {\n          return 0;\n        }, t.prototype.isReferenced = function (t, e) {\n          var n = this;\n          return oo.or([function () {\n            return n.persistence.getQueryCache().containsKey(t, e);\n          }, function () {\n            return n.persistence.mutationQueuesContainKey(t, e);\n          }, function () {\n            return oo.resolve(n.inMemoryPins.containsKey(e));\n          }]);\n        }, t;\n      }(),\n          Es = function () {\n        function t(t, e, n) {\n          this.persistence = t, this.serializer = e, this.orphanedSequenceNumbers = new Po(function (t) {\n            return Pi(t.path);\n          }), this.garbageCollector = new Sa(this, n);\n        }\n\n        return t.prototype.onTransactionStarted = function () {}, t.prototype.onTransactionCommitted = function (t) {\n          return oo.resolve();\n        }, t.prototype.forEachTarget = function (t, e) {\n          return this.persistence.getQueryCache().forEachTarget(t, e);\n        }, t.prototype.getSequenceNumberCount = function (t) {\n          var n = this.orphanedDocumentCount(t);\n          return this.persistence.getQueryCache().getTargetCount(t).next(function (e) {\n            return n.next(function (t) {\n              return e + t;\n            });\n          });\n        }, t.prototype.orphanedDocumentCount = function (t) {\n          var e = 0;\n          return this.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n            e++;\n          }).next(function () {\n            return e;\n          });\n        }, t.prototype.forEachOrphanedDocumentSequenceNumber = function (n, r) {\n          var i = this;\n          return oo.forEach(this.orphanedSequenceNumbers, function (t, e) {\n            return i.isPinned(n, t, e).next(function (t) {\n              return t ? oo.resolve() : r(e);\n            });\n          });\n        }, t.prototype.setInMemoryPins = function (t) {\n          this.inMemoryPins = t;\n        }, t.prototype.removeTargets = function (t, e, n) {\n          return this.persistence.getQueryCache().removeTargets(t, e, n);\n        }, t.prototype.removeOrphanedDocuments = function (n, t) {\n          var r = this,\n              i = 0,\n              o = this.persistence.getRemoteDocumentCache();\n          return o.forEachDocumentKey(n, function (e) {\n            return r.isPinned(n, e, t).next(function (t) {\n              return t ? oo.resolve() : (i++, o.removeEntry(n, e).next());\n            });\n          }).next(function () {\n            return i;\n          });\n        }, t.prototype.removeMutationReference = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), oo.resolve();\n        }, t.prototype.removeTarget = function (t, e) {\n          var n = e.copy({\n            sequenceNumber: t.currentSequenceNumber\n          });\n          return this.persistence.getQueryCache().updateQueryData(t, n);\n        }, t.prototype.addReference = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), oo.resolve();\n        }, t.prototype.removeReference = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), oo.resolve();\n        }, t.prototype.updateLimboDocument = function (t, e) {\n          return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), oo.resolve();\n        }, t.prototype.documentSize = function (t) {\n          var e,\n              n = this.serializer.toDbRemoteDocument(t);\n          if (n.document) e = n.document;else if (n.unknownDocument) e = n.unknownDocument;else {\n            if (!n.noDocument) throw Mr(\"Unknown remote document type\");\n            e = n.noDocument;\n          }\n          return JSON.stringify(e).length;\n        }, t.prototype.isPinned = function (t, e, n) {\n          var r = this;\n          return oo.or([function () {\n            return r.persistence.mutationQueuesContainKey(t, e);\n          }, function () {\n            return oo.resolve(r.inMemoryPins.containsKey(e));\n          }, function () {\n            return r.persistence.getQueryCache().containsKey(t, e);\n          }, function () {\n            var t = r.orphanedSequenceNumbers.get(e);\n            return oo.resolve(void 0 !== t && n < t);\n          }]);\n        }, t.prototype.getCacheSize = function (t) {\n          return this.persistence.getRemoteDocumentCache().getSize(t);\n        }, t;\n      }(),\n          Ss = Number,\n          Ts = Ss.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1),\n          Is = Ss.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1,\n          Cs = Ss.isInteger || function (t) {\n        return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n      };\n\n      function Ds(t) {\n        return null == t;\n      }\n\n      function Ns(t) {\n        return Cs(t) && t <= Is && Ts <= t;\n      }\n\n      var As,\n          ks,\n          Rs = function () {\n        function t(t, e, n, r, i) {\n          this.queue = t, this.timerId = e, this.initialDelayMs = n, this.backoffFactor = r, this.maxDelayMs = i, this.timerPromise = null, this.lastAttemptTime = Date.now(), this.reset();\n        }\n\n        return t.prototype.reset = function () {\n          this.currentBaseMs = 0;\n        }, t.prototype.resetToMax = function () {\n          this.currentBaseMs = this.maxDelayMs;\n        }, t.prototype.backoffAndRun = function (t) {\n          var e = this;\n          this.cancel();\n          var n = Math.floor(this.currentBaseMs + this.jitterDelayMs()),\n              r = Math.max(0, Date.now() - this.lastAttemptTime),\n              i = Math.max(0, n - r);\n          0 < this.currentBaseMs && Ar(\"ExponentialBackoff\", \"Backing off for \" + i + \" ms (base delay: \" + this.currentBaseMs + \" ms, delay with jitter: \" + n + \" ms, last attempt: \" + r + \" ms ago)\"), this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, i, function () {\n            return e.lastAttemptTime = Date.now(), t();\n          }), this.currentBaseMs *= this.backoffFactor, this.currentBaseMs < this.initialDelayMs && (this.currentBaseMs = this.initialDelayMs), this.currentBaseMs > this.maxDelayMs && (this.currentBaseMs = this.maxDelayMs);\n        }, t.prototype.cancel = function () {\n          null !== this.timerPromise && (this.timerPromise.cancel(), this.timerPromise = null);\n        }, t.prototype.jitterDelayMs = function () {\n          return (Math.random() - .5) * this.currentBaseMs;\n        }, t;\n      }(),\n          Ms = \"PersistentStream\";\n\n      (ks = As || (As = {}))[ks.Initial = 0] = \"Initial\", ks[ks.Starting = 1] = \"Starting\", ks[ks.Open = 2] = \"Open\", ks[ks.Error = 3] = \"Error\", ks[ks.Backoff = 4] = \"Backoff\";\n\n      var Os,\n          _s,\n          Ps,\n          Ls,\n          xs = function () {\n        function t(t, e, n, r, i, o) {\n          this.queue = t, this.idleTimerId = n, this.connection = r, this.credentialsProvider = i, this.listener = o, this.state = As.Initial, this.closeCount = 0, this.idleTimer = null, this.stream = null, this.backoff = new Rs(t, e, 1e3, 1.5, 6e4);\n        }\n\n        return t.prototype.isStarted = function () {\n          return this.state === As.Starting || this.state === As.Open || this.state === As.Backoff;\n        }, t.prototype.isOpen = function () {\n          return this.state === As.Open;\n        }, t.prototype.start = function () {\n          this.state !== As.Error ? (Or(this.state === As.Initial, \"Already started\"), this.auth()) : this.performBackoff();\n        }, t.prototype.stop = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.isStarted() ? [4, this.close(As.Initial)] : [3, 2];\n\n                case 1:\n                  t.sent(), t.label = 2;\n\n                case 2:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.inhibitBackoff = function () {\n          Or(!this.isStarted(), \"Can only inhibit backoff in a stopped state\"), this.state = As.Initial, this.backoff.reset();\n        }, t.prototype.markIdle = function () {\n          var t = this;\n          this.isOpen() && null === this.idleTimer && (this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, 6e4, function () {\n            return t.handleIdleCloseTimer();\n          }));\n        }, t.prototype.sendRequest = function (t) {\n          this.cancelIdleCheck(), this.stream.send(t);\n        }, t.prototype.handleIdleCloseTimer = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return this.isOpen() ? [2, this.close(As.Initial)] : [2];\n            });\n          });\n        }, t.prototype.cancelIdleCheck = function () {\n          this.idleTimer && (this.idleTimer.cancel(), this.idleTimer = null);\n        }, t.prototype.close = function (e, n) {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return Or(this.isStarted(), \"Only started streams should be closed.\"), Or(e === As.Error || Ds(n), \"Can't provide an error when not in an error state.\"), this.cancelIdleCheck(), this.backoff.cancel(), this.closeCount++, e !== As.Error ? this.backoff.reset() : n && n.code === Lr.RESOURCE_EXHAUSTED ? (kr(n.toString()), kr(\"Using maximum backoff delay to prevent overloading the backend.\"), this.backoff.resetToMax()) : n && n.code === Lr.UNAUTHENTICATED && this.credentialsProvider.invalidateToken(), null !== this.stream && (this.tearDown(), this.stream.close(), this.stream = null), this.state = e, [4, this.listener.onClose(n)];\n\n                case 1:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.tearDown = function () {}, t.prototype.auth = function () {\n          var n = this;\n          Or(this.state === As.Initial, \"Must be in initial state to auth\"), this.state = As.Starting;\n          var t = this.getCloseGuardedDispatcher(this.closeCount),\n              e = this.closeCount;\n          this.credentialsProvider.getToken().then(function (t) {\n            n.closeCount === e && n.startStream(t);\n          }, function (e) {\n            t(function () {\n              var t = new xr(Lr.UNKNOWN, \"Fetching auth token failed: \" + e.message);\n              return n.handleStreamClose(t);\n            });\n          });\n        }, t.prototype.startStream = function (t) {\n          var e = this;\n          Or(this.state === As.Starting, \"Trying to start stream in a non-starting state\");\n          var n = this.getCloseGuardedDispatcher(this.closeCount);\n          this.stream = this.startRpc(t), this.stream.onOpen(function () {\n            n(function () {\n              return Or(e.state === As.Starting, \"Expected stream to be in state Starting, but was \" + e.state), e.state = As.Open, e.listener.onOpen();\n            });\n          }), this.stream.onClose(function (t) {\n            n(function () {\n              return e.handleStreamClose(t);\n            });\n          }), this.stream.onMessage(function (t) {\n            n(function () {\n              return e.onMessage(t);\n            });\n          });\n        }, t.prototype.performBackoff = function () {\n          var t = this;\n          Or(this.state === As.Error, \"Should only perform backoff when in Error state\"), this.state = As.Backoff, this.backoff.backoffAndRun(function () {\n            return h(t, void 0, void 0, function () {\n              return p(this, function (t) {\n                return Or(this.state === As.Backoff, \"Backoff elapsed but state is now: \" + this.state), this.state = As.Initial, this.start(), Or(this.isStarted(), \"PersistentStream should have started\"), [2];\n              });\n            });\n          });\n        }, t.prototype.handleStreamClose = function (t) {\n          return Or(this.isStarted(), \"Can't handle server close on non-started stream\"), Ar(Ms, \"close with error: \" + t), this.stream = null, this.close(As.Error, t);\n        }, t.prototype.getCloseGuardedDispatcher = function (e) {\n          var n = this;\n          return function (t) {\n            n.queue.enqueueAndForget(function () {\n              return n.closeCount === e ? t() : (Ar(Ms, \"stream callback skipped by getCloseGuardedDispatcher.\"), Promise.resolve());\n            });\n          };\n        }, t;\n      }(),\n          qs = function (a) {\n        function t(t, e, n, r, i) {\n          var o = a.call(this, t, pi.ListenStreamConnectionBackoff, pi.ListenStreamIdle, e, n, i) || this;\n          return o.serializer = r, o;\n        }\n\n        return s(t, a), t.prototype.startRpc = function (t) {\n          return this.connection.openStream(\"Listen\", t);\n        }, t.prototype.onMessage = function (t) {\n          this.backoff.reset();\n          var e = this.serializer.fromWatchChange(t),\n              n = this.serializer.versionFromListenResponse(t);\n          return this.listener.onWatchChange(e, n);\n        }, t.prototype.watch = function (t) {\n          var e = {};\n          e.database = this.serializer.encodedDatabaseId, e.addTarget = this.serializer.toTarget(t);\n          var n = this.serializer.toListenRequestLabels(t);\n          n && (e.labels = n), this.sendRequest(e);\n        }, t.prototype.unwatch = function (t) {\n          var e = {};\n          e.database = this.serializer.encodedDatabaseId, e.removeTarget = t, this.sendRequest(e);\n        }, t;\n      }(xs),\n          Fs = function (a) {\n        function t(t, e, n, r, i) {\n          var o = a.call(this, t, pi.WriteStreamConnectionBackoff, pi.WriteStreamIdle, e, n, i) || this;\n          return o.serializer = r, o.handshakeComplete_ = !1, o;\n        }\n\n        return s(t, a), Object.defineProperty(t.prototype, \"handshakeComplete\", {\n          get: function () {\n            return this.handshakeComplete_;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.start = function () {\n          this.handshakeComplete_ = !1, a.prototype.start.call(this);\n        }, t.prototype.tearDown = function () {\n          this.handshakeComplete_ && this.writeMutations([]);\n        }, t.prototype.startRpc = function (t) {\n          return this.connection.openStream(\"Write\", t);\n        }, t.prototype.onMessage = function (t) {\n          if (Or(!!t.streamToken, \"Got a write response without a stream token\"), this.lastStreamToken = t.streamToken, this.handshakeComplete_) {\n            this.backoff.reset();\n            var e = this.serializer.fromWriteResults(t.writeResults, t.commitTime),\n                n = this.serializer.fromVersion(t.commitTime);\n            return this.listener.onMutationResult(n, e);\n          }\n\n          return Or(!t.writeResults || 0 === t.writeResults.length, \"Got mutation results for handshake\"), this.handshakeComplete_ = !0, this.listener.onHandshakeComplete();\n        }, t.prototype.writeHandshake = function () {\n          Or(this.isOpen(), \"Writing handshake requires an opened stream\"), Or(!this.handshakeComplete_, \"Handshake already completed\");\n          var t = {};\n          t.database = this.serializer.encodedDatabaseId, this.sendRequest(t);\n        }, t.prototype.writeMutations = function (t) {\n          var e = this;\n          Or(this.isOpen(), \"Writing mutations requires an opened stream\"), Or(this.handshakeComplete_, \"Handshake must be complete before writing mutations\"), Or(0 < this.lastStreamToken.length, \"Trying to write mutation without a token\");\n          var n = {\n            streamToken: this.lastStreamToken,\n            writes: t.map(function (t) {\n              return e.serializer.toMutation(t);\n            })\n          };\n          this.sendRequest(n);\n        }, t;\n      }(xs),\n          Vs = function () {\n        function t(t, e, n, r) {\n          this.queue = t, this.connection = e, this.credentials = n, this.serializer = r;\n        }\n\n        return t.prototype.newPersistentWriteStream = function (t) {\n          return new Fs(this.queue, this.connection, this.credentials, this.serializer, t);\n        }, t.prototype.newPersistentWatchStream = function (t) {\n          return new qs(this.queue, this.connection, this.credentials, this.serializer, t);\n        }, t.prototype.commit = function (t) {\n          var e = this,\n              n = {\n            database: this.serializer.encodedDatabaseId,\n            writes: t.map(function (t) {\n              return e.serializer.toMutation(t);\n            })\n          };\n          return this.invokeRPC(\"Commit\", n).then(function (t) {\n            return e.serializer.fromWriteResults(t.writeResults, t.commitTime);\n          });\n        }, t.prototype.lookup = function (e) {\n          var i = this,\n              t = {\n            database: this.serializer.encodedDatabaseId,\n            documents: e.map(function (t) {\n              return i.serializer.toName(t);\n            })\n          };\n          return this.invokeStreamingRPC(\"BatchGetDocuments\", t).then(function (t) {\n            var n = zi();\n            t.forEach(function (t) {\n              var e = i.serializer.fromMaybeDocument(t);\n              n = n.insert(e.key, e);\n            });\n            var r = [];\n            return e.forEach(function (t) {\n              var e = n.get(t);\n              Or(!!e, \"Missing entity in write response for \" + t), r.push(e);\n            }), r;\n          });\n        }, t.prototype.invokeRPC = function (e, n) {\n          var r = this;\n          return this.credentials.getToken().then(function (t) {\n            return r.connection.invokeRPC(e, n, t);\n          }).catch(function (t) {\n            throw t.code === Lr.UNAUTHENTICATED && r.credentials.invalidateToken(), t;\n          });\n        }, t.prototype.invokeStreamingRPC = function (e, n) {\n          var r = this;\n          return this.credentials.getToken().then(function (t) {\n            return r.connection.invokeStreamingRPC(e, n, t);\n          }).catch(function (t) {\n            throw t.code === Lr.UNAUTHENTICATED && r.credentials.invalidateToken(), t;\n          });\n        }, t;\n      }(),\n          Us = function () {\n        function t(t) {\n          this.datastore = t, this.readVersions = $i(), this.mutations = [], this.committed = !1;\n        }\n\n        return t.prototype.recordVersion = function (t) {\n          var e;\n          if (t instanceof Mo) e = t.version;else {\n            if (!(t instanceof Oo)) throw Mr(\"Document in a transaction was a \" + t.constructor.name);\n            e = Vi.forDeletedDoc();\n          }\n          var n = this.readVersions.get(t.key);\n\n          if (null !== n) {\n            if (!e.isEqual(n)) throw new xr(Lr.ABORTED, \"Document version changed between two reads.\");\n          } else this.readVersions = this.readVersions.insert(t.key, e);\n        }, t.prototype.lookup = function (t) {\n          var e = this;\n          return this.committed ? Promise.reject(\"Transaction has already completed.\") : 0 < this.mutations.length ? Promise.reject(\"Transactions lookups are invalid after writes.\") : this.datastore.lookup(t).then(function (t) {\n            return t.forEach(function (t) {\n              t instanceof Oo || t instanceof Mo ? e.recordVersion(t) : Mr(\"Document in a transaction was a \" + t.constructor.name);\n            }), t;\n          });\n        }, t.prototype.write = function (t) {\n          if (this.committed) throw new xr(Lr.FAILED_PRECONDITION, \"Transaction has already completed.\");\n          this.mutations = this.mutations.concat(t);\n        }, t.prototype.precondition = function (t) {\n          var e = this.readVersions.get(t);\n          return e ? is.updateTime(e) : is.NONE;\n        }, t.prototype.preconditionForUpdate = function (t) {\n          var e = this.readVersions.get(t);\n          if (e && e.isEqual(Vi.forDeletedDoc())) throw new xr(Lr.FAILED_PRECONDITION, \"Can't update a document that doesn't exist.\");\n          return e ? is.updateTime(e) : is.exists(!0);\n        }, t.prototype.set = function (t, e) {\n          this.write(e.toMutations(t, this.precondition(t)));\n        }, t.prototype.update = function (t, e) {\n          this.write(e.toMutations(t, this.preconditionForUpdate(t)));\n        }, t.prototype.delete = function (t) {\n          this.write([new cs(t, this.precondition(t))]), this.readVersions = this.readVersions.insert(t, Vi.forDeletedDoc());\n        }, t.prototype.commit = function () {\n          var t = this,\n              e = this.readVersions;\n          return this.mutations.forEach(function (t) {\n            e = e.remove(t.key);\n          }), e.isEmpty() ? this.datastore.commit(this.mutations).then(function () {\n            t.committed = !0;\n          }) : Promise.reject(Error(\"Every document read in a transaction must also be written.\"));\n        }, t;\n      }();\n\n      (_s = Os || (Os = {}))[_s.Unknown = 0] = \"Unknown\", _s[_s.Online = 1] = \"Online\", _s[_s.Offline = 2] = \"Offline\", (Ls = Ps || (Ps = {}))[Ls.RemoteStore = 0] = \"RemoteStore\", Ls[Ls.SharedClientState = 1] = \"SharedClientState\";\n\n      var Bs,\n          Qs,\n          Ks = function () {\n        function t(t, e) {\n          this.asyncQueue = t, this.onlineStateHandler = e, this.state = Os.Unknown, this.watchStreamFailures = 0, this.onlineStateTimer = null, this.shouldWarnClientIsOffline = !0;\n        }\n\n        return t.prototype.handleWatchStreamStart = function () {\n          var t = this;\n          0 === this.watchStreamFailures && (this.setAndBroadcast(Os.Unknown), Or(null === this.onlineStateTimer, \"onlineStateTimer shouldn't be started yet\"), this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(pi.OnlineStateTimeout, 1e4, function () {\n            return t.onlineStateTimer = null, Or(t.state === Os.Unknown, \"Timer should be canceled if we transitioned to a different state.\"), t.logClientOfflineWarningIfNecessary(\"Backend didn't respond within 10 seconds.\"), t.setAndBroadcast(Os.Offline), Promise.resolve();\n          }));\n        }, t.prototype.handleWatchStreamFailure = function (t) {\n          this.state === Os.Online ? (this.setAndBroadcast(Os.Unknown), Or(0 === this.watchStreamFailures, \"watchStreamFailures must be 0\"), Or(null === this.onlineStateTimer, \"onlineStateTimer must be null\")) : (this.watchStreamFailures++, 1 <= this.watchStreamFailures && (this.clearOnlineStateTimer(), this.logClientOfflineWarningIfNecessary(\"Connection failed 1 times. Most recent error: \" + t.toString()), this.setAndBroadcast(Os.Offline)));\n        }, t.prototype.set = function (t) {\n          this.clearOnlineStateTimer(), this.watchStreamFailures = 0, t === Os.Online && (this.shouldWarnClientIsOffline = !1), this.setAndBroadcast(t);\n        }, t.prototype.setAndBroadcast = function (t) {\n          t !== this.state && (this.state = t, this.onlineStateHandler(t));\n        }, t.prototype.logClientOfflineWarningIfNecessary = function (t) {\n          var e = \"Could not reach Cloud Firestore backend. \" + t + \"\\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.\";\n          this.shouldWarnClientIsOffline ? (kr(e), this.shouldWarnClientIsOffline = !1) : Ar(\"OnlineStateTracker\", e);\n        }, t.prototype.clearOnlineStateTimer = function () {\n          null !== this.onlineStateTimer && (this.onlineStateTimer.cancel(), this.onlineStateTimer = null);\n        }, t;\n      }();\n\n      function js(t) {\n        switch (t) {\n          case Lr.OK:\n            return Mr(\"Treated status OK as error\");\n\n          case Lr.CANCELLED:\n          case Lr.UNKNOWN:\n          case Lr.DEADLINE_EXCEEDED:\n          case Lr.RESOURCE_EXHAUSTED:\n          case Lr.INTERNAL:\n          case Lr.UNAVAILABLE:\n          case Lr.UNAUTHENTICATED:\n            return !1;\n\n          case Lr.INVALID_ARGUMENT:\n          case Lr.NOT_FOUND:\n          case Lr.ALREADY_EXISTS:\n          case Lr.PERMISSION_DENIED:\n          case Lr.FAILED_PRECONDITION:\n          case Lr.ABORTED:\n          case Lr.OUT_OF_RANGE:\n          case Lr.UNIMPLEMENTED:\n          case Lr.DATA_LOSS:\n            return !0;\n\n          default:\n            return Mr(\"Unknown status code: \" + t);\n        }\n      }\n\n      function Gs(t) {\n        if (void 0 === t) return kr(\"GRPC error has no .code\"), Lr.UNKNOWN;\n\n        switch (t) {\n          case Bs.OK:\n            return Lr.OK;\n\n          case Bs.CANCELLED:\n            return Lr.CANCELLED;\n\n          case Bs.UNKNOWN:\n            return Lr.UNKNOWN;\n\n          case Bs.DEADLINE_EXCEEDED:\n            return Lr.DEADLINE_EXCEEDED;\n\n          case Bs.RESOURCE_EXHAUSTED:\n            return Lr.RESOURCE_EXHAUSTED;\n\n          case Bs.INTERNAL:\n            return Lr.INTERNAL;\n\n          case Bs.UNAVAILABLE:\n            return Lr.UNAVAILABLE;\n\n          case Bs.UNAUTHENTICATED:\n            return Lr.UNAUTHENTICATED;\n\n          case Bs.INVALID_ARGUMENT:\n            return Lr.INVALID_ARGUMENT;\n\n          case Bs.NOT_FOUND:\n            return Lr.NOT_FOUND;\n\n          case Bs.ALREADY_EXISTS:\n            return Lr.ALREADY_EXISTS;\n\n          case Bs.PERMISSION_DENIED:\n            return Lr.PERMISSION_DENIED;\n\n          case Bs.FAILED_PRECONDITION:\n            return Lr.FAILED_PRECONDITION;\n\n          case Bs.ABORTED:\n            return Lr.ABORTED;\n\n          case Bs.OUT_OF_RANGE:\n            return Lr.OUT_OF_RANGE;\n\n          case Bs.UNIMPLEMENTED:\n            return Lr.UNIMPLEMENTED;\n\n          case Bs.DATA_LOSS:\n            return Lr.DATA_LOSS;\n\n          default:\n            return Mr(\"Unknown status code: \" + t);\n        }\n      }\n\n      (Qs = Bs || (Bs = {}))[Qs.OK = 0] = \"OK\", Qs[Qs.CANCELLED = 1] = \"CANCELLED\", Qs[Qs.UNKNOWN = 2] = \"UNKNOWN\", Qs[Qs.INVALID_ARGUMENT = 3] = \"INVALID_ARGUMENT\", Qs[Qs.DEADLINE_EXCEEDED = 4] = \"DEADLINE_EXCEEDED\", Qs[Qs.NOT_FOUND = 5] = \"NOT_FOUND\", Qs[Qs.ALREADY_EXISTS = 6] = \"ALREADY_EXISTS\", Qs[Qs.PERMISSION_DENIED = 7] = \"PERMISSION_DENIED\", Qs[Qs.UNAUTHENTICATED = 16] = \"UNAUTHENTICATED\", Qs[Qs.RESOURCE_EXHAUSTED = 8] = \"RESOURCE_EXHAUSTED\", Qs[Qs.FAILED_PRECONDITION = 9] = \"FAILED_PRECONDITION\", Qs[Qs.ABORTED = 10] = \"ABORTED\", Qs[Qs.OUT_OF_RANGE = 11] = \"OUT_OF_RANGE\", Qs[Qs.UNIMPLEMENTED = 12] = \"UNIMPLEMENTED\", Qs[Qs.INTERNAL = 13] = \"INTERNAL\", Qs[Qs.UNAVAILABLE = 14] = \"UNAVAILABLE\", Qs[Qs.DATA_LOSS = 15] = \"DATA_LOSS\";\n\n      var Ws,\n          zs,\n          Hs,\n          Ys,\n          Xs = function () {\n        function o(n) {\n          this.comparator = n ? function (t, e) {\n            return n(t, e) || Di.comparator(t.key, e.key);\n          } : function (t, e) {\n            return Di.comparator(t.key, e.key);\n          }, this.keyedMap = Xi(), this.sortedSet = new Ui(this.comparator);\n        }\n\n        return o.emptySet = function (t) {\n          return new o(t.comparator);\n        }, o.prototype.has = function (t) {\n          return null != this.keyedMap.get(t);\n        }, o.prototype.get = function (t) {\n          return this.keyedMap.get(t);\n        }, o.prototype.first = function () {\n          return this.sortedSet.minKey();\n        }, o.prototype.last = function () {\n          return this.sortedSet.maxKey();\n        }, o.prototype.isEmpty = function () {\n          return this.sortedSet.isEmpty();\n        }, o.prototype.indexOf = function (t) {\n          var e = this.keyedMap.get(t);\n          return e ? this.sortedSet.indexOf(e) : -1;\n        }, Object.defineProperty(o.prototype, \"size\", {\n          get: function () {\n            return this.sortedSet.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), o.prototype.forEach = function (n) {\n          this.sortedSet.inorderTraversal(function (t, e) {\n            return n(t), !1;\n          });\n        }, o.prototype.add = function (t) {\n          var e = this.delete(t.key);\n          return e.copy(e.keyedMap.insert(t.key, t), e.sortedSet.insert(t, null));\n        }, o.prototype.delete = function (t) {\n          var e = this.get(t);\n          return e ? this.copy(this.keyedMap.remove(t), this.sortedSet.remove(e)) : this;\n        }, o.prototype.isEqual = function (t) {\n          if (!(t instanceof o)) return !1;\n          if (this.size !== t.size) return !1;\n\n          for (var e = this.sortedSet.getIterator(), n = t.sortedSet.getIterator(); e.hasNext();) {\n            var r = e.getNext().key,\n                i = n.getNext().key;\n            if (!r.isEqual(i)) return !1;\n          }\n\n          return !0;\n        }, o.prototype.toString = function () {\n          var e = [];\n          return this.forEach(function (t) {\n            e.push(t.toString());\n          }), 0 === e.length ? \"DocumentSet ()\" : \"DocumentSet (\\n  \" + e.join(\"  \\n\") + \"\\n)\";\n        }, o.prototype.copy = function (t, e) {\n          var n = new o();\n          return n.comparator = this.comparator, n.keyedMap = t, n.sortedSet = e, n;\n        }, o;\n      }();\n\n      (zs = Ws || (Ws = {}))[zs.Added = 0] = \"Added\", zs[zs.Removed = 1] = \"Removed\", zs[zs.Modified = 2] = \"Modified\", zs[zs.Metadata = 3] = \"Metadata\", (Ys = Hs || (Hs = {}))[Ys.Local = 0] = \"Local\", Ys[Ys.Synced = 1] = \"Synced\";\n\n      var Js,\n          $s,\n          Zs = function () {\n        function t() {\n          this.changeMap = new Ui(Di.comparator);\n        }\n\n        return t.prototype.track = function (t) {\n          var e = t.doc.key,\n              n = this.changeMap.get(e);\n          n ? t.type !== Ws.Added && n.type === Ws.Metadata ? this.changeMap = this.changeMap.insert(e, t) : t.type === Ws.Metadata && n.type !== Ws.Removed ? this.changeMap = this.changeMap.insert(e, {\n            type: n.type,\n            doc: t.doc\n          }) : t.type === Ws.Modified && n.type === Ws.Modified ? this.changeMap = this.changeMap.insert(e, {\n            type: Ws.Modified,\n            doc: t.doc\n          }) : t.type === Ws.Modified && n.type === Ws.Added ? this.changeMap = this.changeMap.insert(e, {\n            type: Ws.Added,\n            doc: t.doc\n          }) : t.type === Ws.Removed && n.type === Ws.Added ? this.changeMap = this.changeMap.remove(e) : t.type === Ws.Removed && n.type === Ws.Modified ? this.changeMap = this.changeMap.insert(e, {\n            type: Ws.Removed,\n            doc: n.doc\n          }) : t.type === Ws.Added && n.type === Ws.Removed ? this.changeMap = this.changeMap.insert(e, {\n            type: Ws.Modified,\n            doc: t.doc\n          }) : Mr(\"unsupported combination of changes: \" + JSON.stringify(t) + \" after \" + JSON.stringify(n)) : this.changeMap = this.changeMap.insert(e, t);\n        }, t.prototype.getChanges = function () {\n          var n = [];\n          return this.changeMap.inorderTraversal(function (t, e) {\n            n.push(e);\n          }), n;\n        }, t;\n      }(),\n          tu = function () {\n        function o(t, e, n, r, i, o, a, s) {\n          this.query = t, this.docs = e, this.oldDocs = n, this.docChanges = r, this.mutatedKeys = i, this.fromCache = o, this.syncStateChanged = a, this.excludesMetadataChanges = s;\n        }\n\n        return o.fromInitialDocuments = function (t, e, n, r) {\n          var i = [];\n          return e.forEach(function (t) {\n            i.push({\n              type: Ws.Added,\n              doc: t\n            });\n          }), new o(t, e, Xs.emptySet(e), i, n, r, !0, !1);\n        }, Object.defineProperty(o.prototype, \"hasPendingWrites\", {\n          get: function () {\n            return !this.mutatedKeys.isEmpty();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), o.prototype.isEqual = function (t) {\n          if (!(this.fromCache === t.fromCache && this.syncStateChanged === t.syncStateChanged && this.mutatedKeys.isEqual(t.mutatedKeys) && this.query.isEqual(t.query) && this.docs.isEqual(t.docs) && this.oldDocs.isEqual(t.oldDocs))) return !1;\n          var e = this.docChanges,\n              n = t.docChanges;\n          if (e.length !== n.length) return !1;\n\n          for (var r = 0; r < e.length; r++) if (e[r].type !== n[r].type || !e[r].doc.isEqual(n[r].doc)) return !1;\n\n          return !0;\n        }, o;\n      }(),\n          eu = function () {\n        function i(t, e, n, r, i) {\n          this.snapshotVersion = t, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = r, this.resolvedLimboDocuments = i;\n        }\n\n        return i.createSynthesizedRemoteEventForCurrentChange = function (t, e) {\n          var n,\n              r = ((n = {})[t] = nu.createSynthesizedTargetChangeForCurrentChange(t, e), n);\n          return new i(Vi.MIN, r, no(), zi(), to());\n        }, i;\n      }(),\n          nu = function () {\n        function n(t, e, n, r, i) {\n          this.resumeToken = t, this.current = e, this.addedDocuments = n, this.modifiedDocuments = r, this.removedDocuments = i;\n        }\n\n        return n.createSynthesizedTargetChangeForCurrentChange = function (t, e) {\n          return new n(Pr(), e, to(), to(), to());\n        }, n;\n      }(),\n          ru = function (t, e, n, r) {\n        this.updatedTargetIds = t, this.removedTargetIds = e, this.key = n, this.newDoc = r;\n      },\n          iu = function (t, e) {\n        this.targetId = t, this.existenceFilter = e;\n      };\n\n      ($s = Js || (Js = {}))[$s.NoChange = 0] = \"NoChange\", $s[$s.Added = 1] = \"Added\", $s[$s.Removed = 2] = \"Removed\", $s[$s.Current = 3] = \"Current\", $s[$s.Reset = 4] = \"Reset\";\n\n      var ou = function (t, e, n, r) {\n        void 0 === n && (n = Pr()), void 0 === r && (r = null), this.state = t, this.targetIds = e, this.resumeToken = n, this.cause = r;\n      },\n          au = function () {\n        function t() {\n          this.pendingResponses = 0, this.documentChanges = cu(), this._resumeToken = Pr(), this._current = !1, this._hasPendingChanges = !0;\n        }\n\n        return Object.defineProperty(t.prototype, \"current\", {\n          get: function () {\n            return this._current;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"resumeToken\", {\n          get: function () {\n            return this._resumeToken;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"isPending\", {\n          get: function () {\n            return 0 !== this.pendingResponses;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"hasPendingChanges\", {\n          get: function () {\n            return this._hasPendingChanges;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.updateResumeToken = function (t) {\n          0 < t.length && (this._hasPendingChanges = !0, this._resumeToken = t);\n        }, t.prototype.toTargetChange = function () {\n          var n = to(),\n              r = to(),\n              i = to();\n          return this.documentChanges.forEach(function (t, e) {\n            switch (e) {\n              case Ws.Added:\n                n = n.add(t);\n                break;\n\n              case Ws.Modified:\n                r = r.add(t);\n                break;\n\n              case Ws.Removed:\n                i = i.add(t);\n                break;\n\n              default:\n                Mr(\"Encountered invalid change type: \" + e);\n            }\n          }), new nu(this._resumeToken, this._current, n, r, i);\n        }, t.prototype.clearPendingChanges = function () {\n          this._hasPendingChanges = !1, this.documentChanges = cu();\n        }, t.prototype.addDocumentChange = function (t, e) {\n          this._hasPendingChanges = !0, this.documentChanges = this.documentChanges.insert(t, e);\n        }, t.prototype.removeDocumentChange = function (t) {\n          this._hasPendingChanges = !0, this.documentChanges = this.documentChanges.remove(t);\n        }, t.prototype.recordPendingTargetRequest = function () {\n          this.pendingResponses += 1;\n        }, t.prototype.recordTargetResponse = function () {\n          this.pendingResponses -= 1;\n        }, t.prototype.markCurrent = function () {\n          this._hasPendingChanges = !0, this._current = !0;\n        }, t;\n      }(),\n          su = function () {\n        function t(t) {\n          this.metadataProvider = t, this.targetStates = {}, this.pendingDocumentUpdates = zi(), this.pendingDocumentTargetMapping = uu(), this.pendingTargetResets = new ji(ui);\n        }\n\n        return t.prototype.handleDocumentChange = function (t) {\n          for (var e = 0, n = t.updatedTargetIds; e < n.length; e++) {\n            var r = n[e];\n            t.newDoc instanceof Mo ? this.addDocumentToTarget(r, t.newDoc) : t.newDoc instanceof Oo && this.removeDocumentFromTarget(r, t.key, t.newDoc);\n          }\n\n          for (var i = 0, o = t.removedTargetIds; i < o.length; i++) {\n            r = o[i];\n            this.removeDocumentFromTarget(r, t.key, t.newDoc);\n          }\n        }, t.prototype.handleTargetChange = function (n) {\n          var r = this;\n          this.forEachTarget(n, function (t) {\n            var e = r.ensureTargetState(t);\n\n            switch (n.state) {\n              case Js.NoChange:\n                r.isActiveTarget(t) && e.updateResumeToken(n.resumeToken);\n                break;\n\n              case Js.Added:\n                e.recordTargetResponse(), e.isPending || e.clearPendingChanges(), e.updateResumeToken(n.resumeToken);\n                break;\n\n              case Js.Removed:\n                e.recordTargetResponse(), e.isPending || r.removeTarget(t), Or(!n.cause, \"WatchChangeAggregator does not handle errored targets\");\n                break;\n\n              case Js.Current:\n                r.isActiveTarget(t) && (e.markCurrent(), e.updateResumeToken(n.resumeToken));\n                break;\n\n              case Js.Reset:\n                r.isActiveTarget(t) && (r.resetTarget(t), e.updateResumeToken(n.resumeToken));\n                break;\n\n              default:\n                Mr(\"Unknown target watch change state: \" + n.state);\n            }\n          });\n        }, t.prototype.forEachTarget = function (t, e) {\n          0 < t.targetIds.length ? t.targetIds.forEach(e) : Ur(this.targetStates, e);\n        }, t.prototype.handleExistenceFilter = function (t) {\n          var e = t.targetId,\n              n = t.existenceFilter.count,\n              r = this.queryDataForActiveTarget(e);\n\n          if (r) {\n            var i = r.query;\n            if (i.isDocumentQuery()) {\n              if (0 === n) {\n                var o = new Di(i.path);\n                this.removeDocumentFromTarget(e, o, new Oo(o, Vi.forDeletedDoc()));\n              } else Or(1 === n, \"Single document existence filter with count: \" + n);\n            } else this.getCurrentDocumentCountForTarget(e) !== n && (this.resetTarget(e), this.pendingTargetResets = this.pendingTargetResets.add(e));\n          }\n        }, t.prototype.createRemoteEvent = function (i) {\n          var o = this,\n              a = {};\n          Ur(this.targetStates, function (t, e) {\n            var n = o.queryDataForActiveTarget(t);\n\n            if (n) {\n              if (e.current && n.query.isDocumentQuery()) {\n                var r = new Di(n.query.path);\n                null !== o.pendingDocumentUpdates.get(r) || o.targetContainsDocument(t, r) || o.removeDocumentFromTarget(t, r, new Oo(r, i));\n              }\n\n              e.hasPendingChanges && (a[t] = e.toTargetChange(), e.clearPendingChanges());\n            }\n          });\n          var r = to();\n          this.pendingDocumentTargetMapping.forEach(function (t, e) {\n            var n = !0;\n            e.forEachWhile(function (t) {\n              var e = o.queryDataForActiveTarget(t);\n              return !e || e.purpose === ha.LimboResolution || (n = !1);\n            }), n && (r = r.add(t));\n          });\n          var t = new eu(i, a, this.pendingTargetResets, this.pendingDocumentUpdates, r);\n          return this.pendingDocumentUpdates = zi(), this.pendingDocumentTargetMapping = uu(), this.pendingTargetResets = new ji(ui), t;\n        }, t.prototype.addDocumentToTarget = function (t, e) {\n          if (this.isActiveTarget(t)) {\n            var n = this.targetContainsDocument(t, e.key) ? Ws.Modified : Ws.Added;\n            this.ensureTargetState(t).addDocumentChange(e.key, n), this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(e.key, e), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(e.key, this.ensureDocumentTargetMapping(e.key).add(t));\n          }\n        }, t.prototype.removeDocumentFromTarget = function (t, e, n) {\n          if (this.isActiveTarget(t)) {\n            var r = this.ensureTargetState(t);\n            this.targetContainsDocument(t, e) ? r.addDocumentChange(e, Ws.Removed) : r.removeDocumentChange(e), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(e, this.ensureDocumentTargetMapping(e).delete(t)), n && (this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(e, n));\n          }\n        }, t.prototype.removeTarget = function (t) {\n          delete this.targetStates[t];\n        }, t.prototype.getCurrentDocumentCountForTarget = function (t) {\n          var e = this.ensureTargetState(t).toTargetChange();\n          return this.metadataProvider.getRemoteKeysForTarget(t).size + e.addedDocuments.size - e.removedDocuments.size;\n        }, t.prototype.recordPendingTargetRequest = function (t) {\n          this.ensureTargetState(t).recordPendingTargetRequest();\n        }, t.prototype.ensureTargetState = function (t) {\n          return this.targetStates[t] || (this.targetStates[t] = new au()), this.targetStates[t];\n        }, t.prototype.ensureDocumentTargetMapping = function (t) {\n          var e = this.pendingDocumentTargetMapping.get(t);\n          return e || (e = new ji(ui), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(t, e)), e;\n        }, t.prototype.isActiveTarget = function (t) {\n          return null !== this.queryDataForActiveTarget(t);\n        }, t.prototype.queryDataForActiveTarget = function (t) {\n          var e = this.targetStates[t];\n          return e && e.isPending ? null : this.metadataProvider.getQueryDataForTarget(t);\n        }, t.prototype.resetTarget = function (e) {\n          var n = this;\n          Or(!this.targetStates[e].isPending, \"Should only reset active targets\"), this.targetStates[e] = new au(), this.metadataProvider.getRemoteKeysForTarget(e).forEach(function (t) {\n            n.removeDocumentFromTarget(e, t, null);\n          });\n        }, t.prototype.targetContainsDocument = function (t, e) {\n          return this.metadataProvider.getRemoteKeysForTarget(t).has(e);\n        }, t;\n      }();\n\n      function uu() {\n        return new Ui(Di.comparator);\n      }\n\n      function cu() {\n        return new Ui(Di.comparator);\n      }\n\n      var hu = \"RemoteStore\",\n          lu = function () {\n        function t(t, e, n, r, i) {\n          var o = this;\n          this.localStore = t, this.datastore = e, this.writePipeline = [], this.listenTargets = {}, this.watchChangeAggregator = null, this.networkEnabled = !1, this.isPrimary = !1, this.connectivityMonitor = i, this.connectivityMonitor.addCallback(function (t) {\n            n.enqueueAndForget(function () {\n              return h(o, void 0, void 0, function () {\n                return p(this, function (t) {\n                  switch (t.label) {\n                    case 0:\n                      return this.canUseNetwork() ? (Ar(hu, \"Restarting streams for network reachability change.\"), [4, this.restartNetwork()]) : [3, 2];\n\n                    case 1:\n                      t.sent(), t.label = 2;\n\n                    case 2:\n                      return [2];\n                  }\n                });\n              });\n            });\n          }), this.onlineStateTracker = new Ks(n, r), this.watchStream = this.datastore.newPersistentWatchStream({\n            onOpen: this.onWatchStreamOpen.bind(this),\n            onClose: this.onWatchStreamClose.bind(this),\n            onWatchChange: this.onWatchStreamChange.bind(this)\n          }), this.writeStream = this.datastore.newPersistentWriteStream({\n            onOpen: this.onWriteStreamOpen.bind(this),\n            onClose: this.onWriteStreamClose.bind(this),\n            onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n            onMutationResult: this.onMutationResult.bind(this)\n          });\n        }\n\n        return t.prototype.start = function () {\n          return this.enableNetwork();\n        }, t.prototype.enableNetwork = function () {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.networkEnabled = !0, this.canUseNetwork() ? (e = this.writeStream, [4, this.localStore.getLastStreamToken()]) : [3, 3];\n\n                case 1:\n                  return e.lastStreamToken = t.sent(), this.shouldStartWatchStream() ? this.startWatchStream() : this.onlineStateTracker.set(Os.Unknown), [4, this.fillWritePipeline()];\n\n                case 2:\n                  t.sent(), t.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.disableNetwork = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.networkEnabled = !1, [4, this.disableNetworkInternal()];\n\n                case 1:\n                  return t.sent(), this.onlineStateTracker.set(Os.Offline), [2];\n              }\n            });\n          });\n        }, t.prototype.disableNetworkInternal = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, this.writeStream.stop()];\n\n                case 1:\n                  return t.sent(), [4, this.watchStream.stop()];\n\n                case 2:\n                  return t.sent(), 0 < this.writePipeline.length && (Ar(hu, \"Stopping write stream with \" + this.writePipeline.length + \" pending writes\"), this.writePipeline = []), this.cleanUpWatchStreamState(), [2];\n              }\n            });\n          });\n        }, t.prototype.shutdown = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return Ar(hu, \"RemoteStore shutting down.\"), this.networkEnabled = !1, [4, this.disableNetworkInternal()];\n\n                case 1:\n                  return t.sent(), this.connectivityMonitor.shutdown(), this.onlineStateTracker.set(Os.Unknown), [2];\n              }\n            });\n          });\n        }, t.prototype.listen = function (t) {\n          Or(!Fr(this.listenTargets, t.targetId), \"listen called with duplicate targetId!\"), this.listenTargets[t.targetId] = t, this.shouldStartWatchStream() ? this.startWatchStream() : this.watchStream.isOpen() && this.sendWatchRequest(t);\n        }, t.prototype.unlisten = function (t) {\n          Or(Fr(this.listenTargets, t), \"unlisten called without assigned target ID!\"), delete this.listenTargets[t], this.watchStream.isOpen() && this.sendUnwatchRequest(t), Qr(this.listenTargets) && (this.watchStream.isOpen() ? this.watchStream.markIdle() : this.canUseNetwork() && this.onlineStateTracker.set(Os.Unknown));\n        }, t.prototype.getQueryDataForTarget = function (t) {\n          return this.listenTargets[t] || null;\n        }, t.prototype.getRemoteKeysForTarget = function (t) {\n          return this.syncEngine.getRemoteKeysForTarget(t);\n        }, t.prototype.sendWatchRequest = function (t) {\n          this.watchChangeAggregator.recordPendingTargetRequest(t.targetId), this.watchStream.watch(t);\n        }, t.prototype.sendUnwatchRequest = function (t) {\n          this.watchChangeAggregator.recordPendingTargetRequest(t), this.watchStream.unwatch(t);\n        }, t.prototype.startWatchStream = function () {\n          Or(this.shouldStartWatchStream(), \"startWatchStream() called when shouldStartWatchStream() is false.\"), this.watchChangeAggregator = new su(this), this.watchStream.start(), this.onlineStateTracker.handleWatchStreamStart();\n        }, t.prototype.shouldStartWatchStream = function () {\n          return this.canUseNetwork() && !this.watchStream.isStarted() && !Qr(this.listenTargets);\n        }, t.prototype.canUseNetwork = function () {\n          return this.isPrimary && this.networkEnabled;\n        }, t.prototype.cleanUpWatchStreamState = function () {\n          this.watchChangeAggregator = null;\n        }, t.prototype.onWatchStreamOpen = function () {\n          return h(this, void 0, void 0, function () {\n            var n = this;\n            return p(this, function (t) {\n              return Ur(this.listenTargets, function (t, e) {\n                n.sendWatchRequest(e);\n              }), [2];\n            });\n          });\n        }, t.prototype.onWatchStreamClose = function (e) {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return void 0 === e && Or(!this.shouldStartWatchStream(), \"Watch stream was stopped gracefully while still needed.\"), this.cleanUpWatchStreamState(), this.shouldStartWatchStream() ? (this.onlineStateTracker.handleWatchStreamFailure(e), this.startWatchStream()) : this.onlineStateTracker.set(Os.Unknown), [2];\n            });\n          });\n        }, t.prototype.onWatchStreamChange = function (n, r) {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.onlineStateTracker.set(Os.Online), n instanceof ou && n.state === Js.Removed && n.cause ? [2, this.handleTargetError(n)] : (n instanceof ru ? this.watchChangeAggregator.handleDocumentChange(n) : n instanceof iu ? this.watchChangeAggregator.handleExistenceFilter(n) : (Or(n instanceof ou, \"Expected watchChange to be an instance of WatchTargetChange\"), this.watchChangeAggregator.handleTargetChange(n)), r.isEqual(Vi.MIN) ? [3, 3] : [4, this.localStore.getLastRemoteSnapshotVersion()]);\n\n                case 1:\n                  return e = t.sent(), 0 <= r.compareTo(e) ? [4, this.raiseWatchSnapshot(r)] : [3, 3];\n\n                case 2:\n                  t.sent(), t.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.raiseWatchSnapshot = function (r) {\n          var i = this;\n          Or(!r.isEqual(Vi.MIN), \"Can't raise event for unknown SnapshotVersion\");\n          var t = this.watchChangeAggregator.createRemoteEvent(r);\n          return Ur(t.targetChanges, function (t, e) {\n            if (0 < e.resumeToken.length) {\n              var n = i.listenTargets[t];\n              n && (i.listenTargets[t] = n.copy({\n                resumeToken: e.resumeToken,\n                snapshotVersion: r\n              }));\n            }\n          }), t.targetMismatches.forEach(function (t) {\n            var e = i.listenTargets[t];\n\n            if (e) {\n              i.listenTargets[t] = e.copy({\n                resumeToken: Pr()\n              }), i.sendUnwatchRequest(t);\n              var n = new ma(e.query, t, ha.ExistenceFilterMismatch, e.sequenceNumber);\n              i.sendWatchRequest(n);\n            }\n          }), this.syncEngine.applyRemoteEvent(t);\n        }, t.prototype.handleTargetError = function (t) {\n          var n = this;\n          Or(!!t.cause, \"Handling target error without a cause\");\n          var r = t.cause,\n              i = Promise.resolve();\n          return t.targetIds.forEach(function (e) {\n            i = i.then(function () {\n              return h(n, void 0, void 0, function () {\n                return p(this, function (t) {\n                  return Fr(this.listenTargets, e) ? (delete this.listenTargets[e], this.watchChangeAggregator.removeTarget(e), [2, this.syncEngine.rejectListen(e, r)]) : [2];\n                });\n              });\n            });\n          }), i;\n        }, t.prototype.fillWritePipeline = function () {\n          return h(this, void 0, void 0, function () {\n            var e, n;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.canAddToWritePipeline() ? (e = 0 < this.writePipeline.length ? this.writePipeline[this.writePipeline.length - 1].batchId : -1, [4, this.localStore.nextMutationBatch(e)]) : [3, 4];\n\n                case 1:\n                  return null !== (n = t.sent()) ? [3, 2] : (0 === this.writePipeline.length && this.writeStream.markIdle(), [3, 4]);\n\n                case 2:\n                  return this.addToWritePipeline(n), [4, this.fillWritePipeline()];\n\n                case 3:\n                  t.sent(), t.label = 4;\n\n                case 4:\n                  return this.shouldStartWriteStream() && this.startWriteStream(), [2];\n              }\n            });\n          });\n        }, t.prototype.canAddToWritePipeline = function () {\n          return this.canUseNetwork() && this.writePipeline.length < 10;\n        }, t.prototype.outstandingWrites = function () {\n          return this.writePipeline.length;\n        }, t.prototype.addToWritePipeline = function (t) {\n          Or(this.canAddToWritePipeline(), \"addToWritePipeline called when pipeline is full\"), this.writePipeline.push(t), this.writeStream.isOpen() && this.writeStream.handshakeComplete && this.writeStream.writeMutations(t.mutations);\n        }, t.prototype.shouldStartWriteStream = function () {\n          return this.canUseNetwork() && !this.writeStream.isStarted() && 0 < this.writePipeline.length;\n        }, t.prototype.startWriteStream = function () {\n          Or(this.shouldStartWriteStream(), \"startWriteStream() called when shouldStartWriteStream() is false.\"), this.writeStream.start();\n        }, t.prototype.onWriteStreamOpen = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return this.writeStream.writeHandshake(), [2];\n            });\n          });\n        }, t.prototype.onWriteHandshakeComplete = function () {\n          var r = this;\n          return this.localStore.setLastStreamToken(this.writeStream.lastStreamToken).then(function () {\n            for (var t = 0, e = r.writePipeline; t < e.length; t++) {\n              var n = e[t];\n              r.writeStream.writeMutations(n.mutations);\n            }\n          }).catch(Aa);\n        }, t.prototype.onMutationResult = function (t, e) {\n          var n = this;\n          Or(0 < this.writePipeline.length, \"Got result for empty write pipeline\");\n          var r = this.writePipeline.shift(),\n              i = io.from(r, t, e, this.writeStream.lastStreamToken);\n          return this.syncEngine.applySuccessfulWrite(i).then(function () {\n            return n.fillWritePipeline();\n          });\n        }, t.prototype.onWriteStreamClose = function (n) {\n          return h(this, void 0, void 0, function () {\n            var e = this;\n            return p(this, function (t) {\n              return void 0 === n && Or(!this.shouldStartWriteStream(), \"Write stream was stopped gracefully while still needed.\"), n && 0 < this.writePipeline.length ? (void 0, [2, (this.writeStream.handshakeComplete ? this.handleWriteError(n) : this.handleHandshakeError(n)).then(function () {\n                e.shouldStartWriteStream() && e.startWriteStream();\n              })]) : [2];\n            });\n          });\n        }, t.prototype.handleHandshakeError = function (e) {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return js(e.code) ? (Ar(hu, \"RemoteStore error before completed handshake; resetting stream token: \", this.writeStream.lastStreamToken), this.writeStream.lastStreamToken = Pr(), [2, this.localStore.setLastStreamToken(Pr()).catch(Aa)]) : [2];\n            });\n          });\n        }, t.prototype.handleWriteError = function (i) {\n          return h(this, void 0, void 0, function () {\n            var n,\n                r = this;\n            return p(this, function (t) {\n              return js(e = i.code) && e !== Lr.ABORTED ? (n = this.writePipeline.shift(), this.writeStream.inhibitBackoff(), [2, this.syncEngine.rejectFailedWrite(n.batchId, i).then(function () {\n                return r.fillWritePipeline();\n              })]) : [2];\n              var e;\n            });\n          });\n        }, t.prototype.createTransaction = function () {\n          return new Us(this.datastore);\n        }, t.prototype.restartNetwork = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.networkEnabled = !1, [4, this.disableNetworkInternal()];\n\n                case 1:\n                  return t.sent(), this.onlineStateTracker.set(Os.Unknown), [4, this.enableNetwork()];\n\n                case 2:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.handleCredentialChange = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.canUseNetwork() ? (Ar(hu, \"RemoteStore restarting streams for new credential\"), [4, this.restartNetwork()]) : [3, 2];\n\n                case 1:\n                  t.sent(), t.label = 2;\n\n                case 2:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.applyPrimaryState = function (e) {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return (this.isPrimary = e) && this.networkEnabled ? [4, this.enableNetwork()] : [3, 2];\n\n                case 1:\n                  return t.sent(), [3, 4];\n\n                case 2:\n                  return e ? [3, 4] : [4, this.disableNetworkInternal()];\n\n                case 3:\n                  t.sent(), this.onlineStateTracker.set(Os.Unknown), t.label = 4;\n\n                case 4:\n                  return [2];\n              }\n            });\n          });\n        }, t;\n      }(),\n          fu = function () {\n        function t(t, e) {\n          if (jr(\"GeoPoint\", arguments, 2), zr(\"GeoPoint\", \"number\", 1, t), zr(\"GeoPoint\", \"number\", 2, e), !isFinite(t) || t < -90 || 90 < t) throw new xr(Lr.INVALID_ARGUMENT, \"Latitude must be a number between -90 and 90, but was: \" + t);\n          if (!isFinite(e) || e < -180 || 180 < e) throw new xr(Lr.INVALID_ARGUMENT, \"Longitude must be a number between -180 and 180, but was: \" + e);\n          this._lat = t, this._long = e;\n        }\n\n        return Object.defineProperty(t.prototype, \"latitude\", {\n          get: function () {\n            return this._lat;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"longitude\", {\n          get: function () {\n            return this._long;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.isEqual = function (t) {\n          return this._lat === t._lat && this._long === t._long;\n        }, t.prototype._compareTo = function (t) {\n          return ui(this._lat, t._lat) || ui(this._long, t._long);\n        }, t;\n      }(),\n          pu = function () {\n        function n(t, e, n, r, i, o, a) {\n          void 0 === e && (e = null), void 0 === n && (n = []), void 0 === r && (r = []), void 0 === i && (i = null), void 0 === o && (o = null), void 0 === a && (a = null), this.path = t, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = r, this.limit = i, this.startAt = o, this.endAt = a, this.memoizedCanonicalId = null, this.memoizedOrderBy = null, this.startAt && this.assertValidBound(this.startAt), this.endAt && this.assertValidBound(this.endAt);\n        }\n\n        return n.atPath = function (t) {\n          return new n(t);\n        }, Object.defineProperty(n.prototype, \"orderBy\", {\n          get: function () {\n            if (null === this.memoizedOrderBy) {\n              var t = this.getInequalityFilterField(),\n                  e = this.getFirstOrderByField();\n              if (null !== t && null === e) t.isKeyField() ? this.memoizedOrderBy = [Iu] : this.memoizedOrderBy = [new Tu(t), Iu];else {\n                Or(null === t || null !== e && t.isEqual(e), \"First orderBy should match inequality field.\");\n\n                for (var n = !(this.memoizedOrderBy = []), r = 0, i = this.explicitOrderBy; r < i.length; r++) {\n                  var o = i[r];\n                  this.memoizedOrderBy.push(o), o.field.isKeyField() && (n = !0);\n                }\n\n                if (!n) {\n                  var a = 0 < this.explicitOrderBy.length ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir : Eu.ASCENDING;\n                  this.memoizedOrderBy.push(a === Eu.ASCENDING ? Iu : Cu);\n                }\n              }\n            }\n\n            return this.memoizedOrderBy;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), n.prototype.addFilter = function (t) {\n          Or(null == this.getInequalityFilterField() || !(t instanceof yu) || !t.isInequality() || t.field.isEqual(this.getInequalityFilterField()), \"Query must only have one inequality field.\"), Or(!this.isDocumentQuery(), \"No filtering allowed for document query\");\n          var e = this.filters.concat([t]);\n          return new n(this.path, this.collectionGroup, this.explicitOrderBy.slice(), e, this.limit, this.startAt, this.endAt);\n        }, n.prototype.addOrderBy = function (t) {\n          Or(!this.startAt && !this.endAt, \"Bounds must be set after orderBy\");\n          var e = this.explicitOrderBy.concat([t]);\n          return new n(this.path, this.collectionGroup, e, this.filters.slice(), this.limit, this.startAt, this.endAt);\n        }, n.prototype.withLimit = function (t) {\n          return new n(this.path, this.collectionGroup, this.explicitOrderBy.slice(), this.filters.slice(), t, this.startAt, this.endAt);\n        }, n.prototype.withStartAt = function (t) {\n          return new n(this.path, this.collectionGroup, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, t, this.endAt);\n        }, n.prototype.withEndAt = function (t) {\n          return new n(this.path, this.collectionGroup, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, t);\n        }, n.prototype.asCollectionQueryAtPath = function (t) {\n          return new n(t, null, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, this.endAt);\n        }, n.prototype.canonicalId = function () {\n          if (null === this.memoizedCanonicalId) {\n            var t = this.path.canonicalString();\n            this.isCollectionGroupQuery() && (t += \"|cg:\" + this.collectionGroup), t += \"|f:\";\n\n            for (var e = 0, n = this.filters; e < n.length; e++) {\n              t += n[e].canonicalId(), t += \",\";\n            }\n\n            t += \"|ob:\";\n\n            for (var r = 0, i = this.orderBy; r < i.length; r++) {\n              t += i[r].canonicalId(), t += \",\";\n            }\n\n            Ds(this.limit) || (t += \"|l:\", t += this.limit), this.startAt && (t += \"|lb:\", t += this.startAt.canonicalId()), this.endAt && (t += \"|ub:\", t += this.endAt.canonicalId()), this.memoizedCanonicalId = t;\n          }\n\n          return this.memoizedCanonicalId;\n        }, n.prototype.toString = function () {\n          var t = \"Query(\" + this.path.canonicalString();\n          return this.isCollectionGroupQuery() && (t += \" collectionGroup=\" + this.collectionGroup), 0 < this.filters.length && (t += \", filters: [\" + this.filters.join(\", \") + \"]\"), Ds(this.limit) || (t += \", limit: \" + this.limit), 0 < this.explicitOrderBy.length && (t += \", orderBy: [\" + this.explicitOrderBy.join(\", \") + \"]\"), this.startAt && (t += \", startAt: \" + this.startAt.canonicalId()), this.endAt && (t += \", endAt: \" + this.endAt.canonicalId()), t + \")\";\n        }, n.prototype.isEqual = function (t) {\n          if (this.limit !== t.limit) return !1;\n          if (this.orderBy.length !== t.orderBy.length) return !1;\n\n          for (var e = 0; e < this.orderBy.length; e++) if (!this.orderBy[e].isEqual(t.orderBy[e])) return !1;\n\n          if (this.filters.length !== t.filters.length) return !1;\n\n          for (e = 0; e < this.filters.length; e++) if (!this.filters[e].isEqual(t.filters[e])) return !1;\n\n          return this.collectionGroup === t.collectionGroup && !!this.path.isEqual(t.path) && !(null !== this.startAt ? !this.startAt.isEqual(t.startAt) : null !== t.startAt) && (null !== this.endAt ? this.endAt.isEqual(t.endAt) : null === t.endAt);\n        }, n.prototype.docComparator = function (t, e) {\n          for (var n = !1, r = 0, i = this.orderBy; r < i.length; r++) {\n            var o = i[r],\n                a = o.compare(t, e);\n            if (0 !== a) return a;\n            n = n || o.field.isKeyField();\n          }\n\n          return Or(n, \"orderBy used that doesn't compare on key field\"), 0;\n        }, n.prototype.matches = function (t) {\n          return this.matchesPathAndCollectionGroup(t) && this.matchesOrderBy(t) && this.matchesFilters(t) && this.matchesBounds(t);\n        }, n.prototype.hasLimit = function () {\n          return !Ds(this.limit);\n        }, n.prototype.getFirstOrderByField = function () {\n          return 0 < this.explicitOrderBy.length ? this.explicitOrderBy[0].field : null;\n        }, n.prototype.getInequalityFilterField = function () {\n          for (var t = 0, e = this.filters; t < e.length; t++) {\n            var n = e[t];\n            if (n instanceof yu && n.isInequality()) return n.field;\n          }\n\n          return null;\n        }, n.prototype.findFilterOperator = function (t) {\n          for (var e = 0, n = this.filters; e < n.length; e++) {\n            var r = n[e];\n            if (r instanceof yu && 0 <= t.indexOf(r.op)) return r.op;\n          }\n\n          return null;\n        }, n.prototype.isDocumentQuery = function () {\n          return Di.isDocumentKey(this.path) && null === this.collectionGroup && 0 === this.filters.length;\n        }, n.prototype.isCollectionGroupQuery = function () {\n          return null !== this.collectionGroup;\n        }, n.prototype.matchesPathAndCollectionGroup = function (t) {\n          var e = t.key.path;\n          return null !== this.collectionGroup ? t.key.hasCollectionId(this.collectionGroup) && this.path.isPrefixOf(e) : Di.isDocumentKey(this.path) ? this.path.isEqual(e) : this.path.isImmediateParentOf(e);\n        }, n.prototype.matchesOrderBy = function (t) {\n          for (var e = 0, n = this.explicitOrderBy; e < n.length; e++) {\n            var r = n[e];\n            if (!r.field.isKeyField() && void 0 === t.field(r.field)) return !1;\n          }\n\n          return !0;\n        }, n.prototype.matchesFilters = function (t) {\n          for (var e = 0, n = this.filters; e < n.length; e++) {\n            if (!n[e].matches(t)) return !1;\n          }\n\n          return !0;\n        }, n.prototype.matchesBounds = function (t) {\n          return !(this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, t)) && (!this.endAt || !this.endAt.sortsBeforeDocument(this.orderBy, t));\n        }, n.prototype.assertValidBound = function (t) {\n          Or(t.position.length <= this.orderBy.length, \"Bound is longer than orderBy\");\n        }, n;\n      }(),\n          du = function () {},\n          mu = function () {\n        function e(t) {\n          this.name = t;\n        }\n\n        return e.fromString = function (t) {\n          switch (t) {\n            case \"<\":\n              return e.LESS_THAN;\n\n            case \"<=\":\n              return e.LESS_THAN_OR_EQUAL;\n\n            case \"==\":\n              return e.EQUAL;\n\n            case \">=\":\n              return e.GREATER_THAN_OR_EQUAL;\n\n            case \">\":\n              return e.GREATER_THAN;\n\n            case \"array-contains\":\n              return e.ARRAY_CONTAINS;\n\n            case \"in\":\n              return e.IN;\n\n            case \"array-contains-any\":\n              return e.ARRAY_CONTAINS_ANY;\n\n            default:\n              return Mr(\"Unknown FieldFilter operator: \" + t);\n          }\n        }, e.prototype.toString = function () {\n          return this.name;\n        }, e.prototype.isEqual = function (t) {\n          return this.name === t.name;\n        }, e.LESS_THAN = new e(\"<\"), e.LESS_THAN_OR_EQUAL = new e(\"<=\"), e.EQUAL = new e(\"==\"), e.GREATER_THAN = new e(\">\"), e.GREATER_THAN_OR_EQUAL = new e(\">=\"), e.ARRAY_CONTAINS = new e(\"array-contains\"), e.IN = new e(\"in\"), e.ARRAY_CONTAINS_ANY = new e(\"array-contains-any\"), e;\n      }(),\n          yu = function (i) {\n        function r(t, e, n) {\n          var r = i.call(this) || this;\n          return r.field = t, r.op = e, r.value = n, r;\n        }\n\n        return s(r, i), r.create = function (t, e, n) {\n          if (t.isKeyField()) return Or(n instanceof Ja, \"Comparing on key, but filter value not a RefValue\"), Or(e !== mu.ARRAY_CONTAINS && e !== mu.ARRAY_CONTAINS_ANY && e !== mu.IN, \"'\" + e.toString() + \"' queries don't make sense on document keys.\"), new gu(t, e, n);\n\n          if (n.isEqual(Va.INSTANCE)) {\n            if (e !== mu.EQUAL) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid query. You can only perform equals comparisons on null.\");\n            return new r(t, e, n);\n          }\n\n          if (n.isEqual(Wa.NAN)) {\n            if (e !== mu.EQUAL) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid query. You can only perform equals comparisons on NaN.\");\n            return new r(t, e, n);\n          }\n\n          return e === mu.ARRAY_CONTAINS ? new vu(t, n) : e === mu.IN ? (Or(n instanceof ts, \"IN filter has invalid value: \" + n.toString()), new bu(t, n)) : e === mu.ARRAY_CONTAINS_ANY ? (Or(n instanceof ts, \"ARRAY_CONTAINS_ANY filter has invalid value: \" + n.toString()), new wu(t, n)) : new r(t, e, n);\n        }, r.prototype.matches = function (t) {\n          var e = t.field(this.field);\n          return void 0 !== e && this.value.typeOrder === e.typeOrder && this.matchesComparison(e.compareTo(this.value));\n        }, r.prototype.matchesComparison = function (t) {\n          switch (this.op) {\n            case mu.LESS_THAN:\n              return t < 0;\n\n            case mu.LESS_THAN_OR_EQUAL:\n              return t <= 0;\n\n            case mu.EQUAL:\n              return 0 === t;\n\n            case mu.GREATER_THAN:\n              return 0 < t;\n\n            case mu.GREATER_THAN_OR_EQUAL:\n              return 0 <= t;\n\n            default:\n              return Mr(\"Unknown FieldFilter operator: \" + this.op);\n          }\n        }, r.prototype.isInequality = function () {\n          return 0 <= [mu.LESS_THAN, mu.LESS_THAN_OR_EQUAL, mu.GREATER_THAN, mu.GREATER_THAN_OR_EQUAL].indexOf(this.op);\n        }, r.prototype.canonicalId = function () {\n          return this.field.canonicalString() + this.op.toString() + this.value.toString();\n        }, r.prototype.isEqual = function (t) {\n          return t instanceof r && this.op.isEqual(t.op) && this.field.isEqual(t.field) && this.value.isEqual(t.value);\n        }, r.prototype.toString = function () {\n          return this.field.canonicalString() + \" \" + this.op + \" \" + this.value.value();\n        }, r;\n      }(du),\n          gu = function (r) {\n        function t(t, e, n) {\n          return r.call(this, t, e, n) || this;\n        }\n\n        return s(t, r), t.prototype.matches = function (t) {\n          var e = this.value,\n              n = Di.comparator(t.key, e.key);\n          return this.matchesComparison(n);\n        }, t;\n      }(yu),\n          vu = function (n) {\n        function t(t, e) {\n          return n.call(this, t, mu.ARRAY_CONTAINS, e) || this;\n        }\n\n        return s(t, n), t.prototype.matches = function (t) {\n          var e = t.field(this.field);\n          return e instanceof ts && e.contains(this.value);\n        }, t;\n      }(yu),\n          bu = function (n) {\n        function t(t, e) {\n          return n.call(this, t, mu.IN, e) || this;\n        }\n\n        return s(t, n), t.prototype.matches = function (t) {\n          var e = this.value,\n              n = t.field(this.field);\n          return void 0 !== n && e.contains(n);\n        }, t;\n      }(yu),\n          wu = function (n) {\n        function t(t, e) {\n          return n.call(this, t, mu.ARRAY_CONTAINS_ANY, e) || this;\n        }\n\n        return s(t, n), t.prototype.matches = function (t) {\n          var e = this.value,\n              n = t.field(this.field);\n          return n instanceof ts && n.internalValue.some(function (t) {\n            return e.contains(t);\n          });\n        }, t;\n      }(yu),\n          Eu = function () {\n        function t(t) {\n          this.name = t;\n        }\n\n        return t.prototype.toString = function () {\n          return this.name;\n        }, t.ASCENDING = new t(\"asc\"), t.DESCENDING = new t(\"desc\"), t;\n      }(),\n          Su = function () {\n        function t(t, e) {\n          this.position = t, this.before = e;\n        }\n\n        return t.prototype.canonicalId = function () {\n          for (var t = this.before ? \"b:\" : \"a:\", e = 0, n = this.position; e < n.length; e++) {\n            t += n[e].toString();\n          }\n\n          return t;\n        }, t.prototype.sortsBeforeDocument = function (t, e) {\n          Or(this.position.length <= t.length, \"Bound has more components than query's orderBy\");\n\n          for (var n = 0, r = 0; r < this.position.length; r++) {\n            var i = t[r],\n                o = this.position[r];\n            if (i.field.isKeyField()) Or(o instanceof Ja, \"Bound has a non-key value where the key path is being used.\"), n = Di.comparator(o.key, e.key);else {\n              var a = e.field(i.field);\n              Or(void 0 !== a, \"Field should exist since document matched the orderBy already.\"), n = o.compareTo(a);\n            }\n            if (i.dir === Eu.DESCENDING && (n *= -1), 0 !== n) break;\n          }\n\n          return this.before ? n <= 0 : n < 0;\n        }, t.prototype.isEqual = function (t) {\n          if (null === t) return !1;\n          if (this.before !== t.before || this.position.length !== t.position.length) return !1;\n\n          for (var e = 0; e < this.position.length; e++) {\n            var n = this.position[e],\n                r = t.position[e];\n            if (!n.isEqual(r)) return !1;\n          }\n\n          return !0;\n        }, t;\n      }(),\n          Tu = function () {\n        function t(t, e) {\n          this.field = t, void 0 === e && (e = Eu.ASCENDING), this.dir = e, this.isKeyOrderBy = t.isKeyField();\n        }\n\n        return t.prototype.compare = function (t, e) {\n          var n = this.isKeyOrderBy ? Mo.compareByKey(t, e) : Mo.compareByField(this.field, t, e);\n\n          switch (this.dir) {\n            case Eu.ASCENDING:\n              return n;\n\n            case Eu.DESCENDING:\n              return -1 * n;\n\n            default:\n              return Mr(\"Unknown direction: \" + this.dir);\n          }\n        }, t.prototype.canonicalId = function () {\n          return this.field.canonicalString() + this.dir.toString();\n        }, t.prototype.toString = function () {\n          return this.field.canonicalString() + \" (\" + this.dir + \")\";\n        }, t.prototype.isEqual = function (t) {\n          return this.dir === t.dir && this.field.isEqual(t.field);\n        }, t;\n      }(),\n          Iu = new Tu(Ci.keyField(), Eu.ASCENDING),\n          Cu = new Tu(Ci.keyField(), Eu.DESCENDING),\n          Du = function () {\n        function e() {\n          this.isIdempotent = !0;\n        }\n\n        return e.prototype.applyToLocalView = function (t, e) {\n          return new Ya(e, t);\n        }, e.prototype.applyToRemoteDocument = function (t, e) {\n          return e;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e;\n        }, e.instance = new e(), e;\n      }(),\n          Nu = function () {\n        function e(t) {\n          this.elements = t, this.isIdempotent = !0;\n        }\n\n        return e.prototype.applyToLocalView = function (t, e) {\n          return this.apply(t);\n        }, e.prototype.applyToRemoteDocument = function (t, e) {\n          return this.apply(t);\n        }, e.prototype.apply = function (t) {\n          for (var n = Ru(t), e = function (e) {\n            n.find(function (t) {\n              return t.isEqual(e);\n            }) || n.push(e);\n          }, r = 0, i = this.elements; r < i.length; r++) {\n            e(i[r]);\n          }\n\n          return new ts(n);\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && ci(t.elements, this.elements);\n        }, e;\n      }(),\n          Au = function () {\n        function e(t) {\n          this.elements = t, this.isIdempotent = !0;\n        }\n\n        return e.prototype.applyToLocalView = function (t, e) {\n          return this.apply(t);\n        }, e.prototype.applyToRemoteDocument = function (t, e) {\n          return this.apply(t);\n        }, e.prototype.apply = function (t) {\n          for (var n = Ru(t), e = function (e) {\n            n = n.filter(function (t) {\n              return !t.isEqual(e);\n            });\n          }, r = 0, i = this.elements; r < i.length; r++) {\n            e(i[r]);\n          }\n\n          return new ts(n);\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && ci(t.elements, this.elements);\n        }, e;\n      }(),\n          ku = function () {\n        function e(t) {\n          this.operand = t, this.isIdempotent = !1;\n        }\n\n        return e.prototype.applyToLocalView = function (t, e) {\n          if (t instanceof Ga && this.operand instanceof Ga) {\n            var n = t.internalValue + this.operand.internalValue;\n            return new Ga(n);\n          }\n\n          if (t instanceof Ba) {\n            n = t.internalValue + this.operand.internalValue;\n            return new Wa(n);\n          }\n\n          return this.operand;\n        }, e.prototype.applyToRemoteDocument = function (t, e) {\n          return Or(null !== e, \"Didn't receive transformResult for NUMERIC_ADD transform\"), e;\n        }, e.prototype.isEqual = function (t) {\n          return t instanceof e && this.operand.isEqual(t.operand);\n        }, e;\n      }();\n\n      function Ru(t) {\n        return t instanceof ts ? t.internalValue.slice() : [];\n      }\n\n      var Mu,\n          Ou,\n          _u = function () {\n        function t(t) {\n          this.count = t;\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return t && t.count === this.count;\n        }, t;\n      }(),\n          Pu = ((Mu = {})[Eu.ASCENDING.name] = \"ASCENDING\", Mu[Eu.DESCENDING.name] = \"DESCENDING\", Mu),\n          Lu = ((Ou = {})[mu.LESS_THAN.name] = \"LESS_THAN\", Ou[mu.LESS_THAN_OR_EQUAL.name] = \"LESS_THAN_OR_EQUAL\", Ou[mu.GREATER_THAN.name] = \"GREATER_THAN\", Ou[mu.GREATER_THAN_OR_EQUAL.name] = \"GREATER_THAN_OR_EQUAL\", Ou[mu.EQUAL.name] = \"EQUAL\", Ou[mu.ARRAY_CONTAINS.name] = \"ARRAY_CONTAINS\", Ou[mu.IN.name] = \"IN\", Ou[mu.ARRAY_CONTAINS_ANY.name] = \"ARRAY_CONTAINS_ANY\", Ou),\n          xu = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n\n      function qu(t, e) {\n        Or(!Ds(t), e + \" is missing\");\n      }\n\n      function Fu(t) {\n        return \"number\" == typeof t ? t : \"string\" == typeof t ? Number(t) : Mr(\"can't parse \" + t);\n      }\n\n      var Vu = function () {\n        function t(t, e) {\n          this.databaseId = t, this.options = e;\n        }\n\n        return t.prototype.emptyByteString = function () {\n          return this.options.useProto3Json ? \"\" : new Uint8Array(0);\n        }, t.prototype.unsafeCastProtoByteString = function (t) {\n          return t;\n        }, t.prototype.fromRpcStatus = function (t) {\n          var e = void 0 === t.code ? Lr.UNKNOWN : Gs(t.code);\n          return new xr(e, t.message || \"\");\n        }, t.prototype.toInt32Value = function (t) {\n          return Ds(t) ? void 0 : {\n            value: t\n          };\n        }, t.prototype.fromInt32Value = function (t) {\n          var e;\n          return Ds(e = \"object\" == typeof t ? t.value : t) ? null : e;\n        }, t.prototype.toTimestamp = function (t) {\n          return {\n            seconds: \"\" + t.seconds,\n            nanos: t.nanoseconds\n          };\n        }, t.prototype.fromTimestamp = function (t) {\n          if (\"string\" == typeof t) return this.fromIso8601String(t);\n          Or(!!t, \"Cannot deserialize null or undefined timestamp.\");\n          var e = Fu(t.seconds || \"0\"),\n              n = t.nanos || 0;\n          return new Fi(e, n);\n        }, t.prototype.fromIso8601String = function (t) {\n          var e = 0,\n              n = xu.exec(t);\n\n          if (Or(!!n, \"invalid timestamp: \" + t), n[1]) {\n            var r = n[1];\n            r = (r + \"000000000\").substr(0, 9), e = Number(r);\n          }\n\n          var i = new Date(t),\n              o = Math.floor(i.getTime() / 1e3);\n          return new Fi(o, e);\n        }, t.prototype.toBytes = function (t) {\n          return this.options.useProto3Json ? t.toBase64() : this.unsafeCastProtoByteString(t.toUint8Array());\n        }, t.prototype.fromBlob = function (t) {\n          return \"string\" == typeof t ? (Or(this.options.useProto3Json, \"Expected bytes to be passed in as Uint8Array, but got a string instead.\"), mi.fromBase64String(t)) : (Or(!this.options.useProto3Json, \"Expected bytes to be passed in as Uint8Array, but got a string instead.\"), mi.fromUint8Array(t));\n        }, t.prototype.toVersion = function (t) {\n          return this.toTimestamp(t.toTimestamp());\n        }, t.prototype.fromVersion = function (t) {\n          return Or(!!t, \"Trying to deserialize version that isn't set\"), Vi.fromTimestamp(this.fromTimestamp(t));\n        }, t.prototype.toResourceName = function (t, e) {\n          return this.fullyQualifiedPrefixPath(t).child(\"documents\").child(e).canonicalString();\n        }, t.prototype.fromResourceName = function (t) {\n          var e = Ti.fromString(t);\n          return Or(this.isValidResourceName(e), \"Tried to deserialize invalid key \" + e.toString()), e;\n        }, t.prototype.toName = function (t) {\n          return this.toResourceName(this.databaseId, t.path);\n        }, t.prototype.fromName = function (t) {\n          var e = this.fromResourceName(t);\n          return Or(e.get(1) === this.databaseId.projectId, \"Tried to deserialize key from different project: \" + e.get(1) + \" vs \" + this.databaseId.projectId), Or(!e.get(3) && !this.databaseId.database || e.get(3) === this.databaseId.database, \"Tried to deserialize key from different database: \" + e.get(3) + \" vs \" + this.databaseId.database), new Di(this.extractLocalPathFromResourceName(e));\n        }, t.prototype.toQueryPath = function (t) {\n          return this.toResourceName(this.databaseId, t);\n        }, t.prototype.fromQueryPath = function (t) {\n          var e = this.fromResourceName(t);\n          return 4 === e.length ? Ti.EMPTY_PATH : this.extractLocalPathFromResourceName(e);\n        }, Object.defineProperty(t.prototype, \"encodedDatabaseId\", {\n          get: function () {\n            return new Ti([\"projects\", this.databaseId.projectId, \"databases\", this.databaseId.database]).canonicalString();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.fullyQualifiedPrefixPath = function (t) {\n          return new Ti([\"projects\", t.projectId, \"databases\", t.database]);\n        }, t.prototype.extractLocalPathFromResourceName = function (t) {\n          return Or(4 < t.length && \"documents\" === t.get(4), \"tried to deserialize invalid key \" + t.toString()), t.popFirst(5);\n        }, t.prototype.isValidResourceName = function (t) {\n          return 4 <= t.length && \"projects\" === t.get(0) && \"databases\" === t.get(2);\n        }, t.prototype.toValue = function (t) {\n          if (t instanceof Va) return {\n            nullValue: \"NULL_VALUE\"\n          };\n          if (t instanceof Ua) return {\n            booleanValue: t.value()\n          };\n          if (t instanceof Ga) return {\n            integerValue: \"\" + t.value()\n          };\n\n          if (t instanceof Wa) {\n            var e = t.value();\n\n            if (this.options.useProto3Json) {\n              if (isNaN(e)) return {\n                doubleValue: \"NaN\"\n              };\n              if (e === 1 / 0) return {\n                doubleValue: \"Infinity\"\n              };\n              if (e === -1 / 0) return {\n                doubleValue: \"-Infinity\"\n              };\n            }\n\n            return {\n              doubleValue: t.value()\n            };\n          }\n\n          return t instanceof za ? {\n            stringValue: t.value()\n          } : t instanceof Za ? {\n            mapValue: this.toMapValue(t)\n          } : t instanceof ts ? {\n            arrayValue: this.toArrayValue(t)\n          } : t instanceof Ha ? {\n            timestampValue: this.toTimestamp(t.internalValue)\n          } : t instanceof $a ? {\n            geoPointValue: {\n              latitude: t.value().latitude,\n              longitude: t.value().longitude\n            }\n          } : t instanceof Xa ? {\n            bytesValue: this.toBytes(t.value())\n          } : t instanceof Ja ? {\n            referenceValue: this.toResourceName(t.databaseId, t.key.path)\n          } : Mr(\"Unknown FieldValue \" + JSON.stringify(t));\n        }, t.prototype.fromValue = function (t) {\n          var e = this;\n          if (\"nullValue\" in t) return Va.INSTANCE;\n          if (\"booleanValue\" in t) return Ua.of(t.booleanValue);\n          if (\"integerValue\" in t) return new Ga(Fu(t.integerValue));\n\n          if (\"doubleValue\" in t) {\n            if (this.options.useProto3Json) {\n              if (\"NaN\" === t.doubleValue) return Wa.NAN;\n              if (\"Infinity\" === t.doubleValue) return Wa.POSITIVE_INFINITY;\n              if (\"-Infinity\" === t.doubleValue) return Wa.NEGATIVE_INFINITY;\n            }\n\n            return new Wa(t.doubleValue);\n          }\n\n          if (\"stringValue\" in t) return new za(t.stringValue);\n          if (\"mapValue\" in t) return this.fromFields(t.mapValue.fields || {});\n\n          if (\"arrayValue\" in t) {\n            qu(t.arrayValue, \"arrayValue\");\n            var n = t.arrayValue.values || [];\n            return new ts(n.map(function (t) {\n              return e.fromValue(t);\n            }));\n          }\n\n          if (\"timestampValue\" in t) return qu(t.timestampValue, \"timestampValue\"), new Ha(this.fromTimestamp(t.timestampValue));\n\n          if (\"geoPointValue\" in t) {\n            qu(t.geoPointValue, \"geoPointValue\");\n            var r = t.geoPointValue.latitude || 0,\n                i = t.geoPointValue.longitude || 0;\n            return new $a(new fu(r, i));\n          }\n\n          if (\"bytesValue\" in t) {\n            qu(t.bytesValue, \"bytesValue\");\n            var o = this.fromBlob(t.bytesValue);\n            return new Xa(o);\n          }\n\n          if (\"referenceValue\" in t) {\n            qu(t.referenceValue, \"referenceValue\");\n            var a = this.fromResourceName(t.referenceValue),\n                s = new bi(a.get(1), a.get(3)),\n                u = new Di(this.extractLocalPathFromResourceName(a));\n            return new Ja(s, u);\n          }\n\n          return Mr(\"Unknown Value proto \" + JSON.stringify(t));\n        }, t.prototype.toMutationDocument = function (t, e) {\n          return {\n            name: this.toName(t),\n            fields: this.toFields(e)\n          };\n        }, t.prototype.toDocument = function (t) {\n          return Or(!t.hasLocalMutations, \"Can't serialize documents with mutations.\"), {\n            name: this.toName(t.key),\n            fields: this.toFields(t.data),\n            updateTime: this.toTimestamp(t.version.toTimestamp())\n          };\n        }, t.prototype.fromDocument = function (t, e) {\n          return new Mo(this.fromName(t.name), this.fromVersion(t.updateTime), this.fromFields(t.fields || {}), {\n            hasCommittedMutations: !!e\n          });\n        }, t.prototype.toFields = function (t) {\n          var n = this,\n              r = {};\n          return t.forEach(function (t, e) {\n            r[t] = n.toValue(e);\n          }), r;\n        }, t.prototype.fromFields = function (t) {\n          var n = this,\n              e = t,\n              r = Za.EMPTY;\n          return Br(e, function (t, e) {\n            r = r.set(new Ci([t]), n.fromValue(e));\n          }), r;\n        }, t.prototype.toMapValue = function (t) {\n          return {\n            fields: this.toFields(t)\n          };\n        }, t.prototype.toArrayValue = function (t) {\n          var e = this,\n              n = [];\n          return t.forEach(function (t) {\n            n.push(e.toValue(t));\n          }), {\n            values: n\n          };\n        }, t.prototype.fromFound = function (t) {\n          Or(!!t.found, \"Tried to deserialize a found document from a missing document.\"), qu(t.found.name, \"doc.found.name\"), qu(t.found.updateTime, \"doc.found.updateTime\");\n          var e = this.fromName(t.found.name),\n              n = this.fromVersion(t.found.updateTime),\n              r = this.fromFields(t.found.fields || {});\n          return new Mo(e, n, r, {}, t.found);\n        }, t.prototype.fromMissing = function (t) {\n          Or(!!t.missing, \"Tried to deserialize a missing document from a found document.\"), Or(!!t.readTime, \"Tried to deserialize a missing document without a read time.\");\n          var e = this.fromName(t.missing),\n              n = this.fromVersion(t.readTime);\n          return new Oo(e, n);\n        }, t.prototype.fromMaybeDocument = function (t) {\n          return \"found\" in t ? this.fromFound(t) : \"missing\" in t ? this.fromMissing(t) : Mr(\"invalid batch get response: \" + JSON.stringify(t));\n        }, t.prototype.toWatchTargetChangeState = function (t) {\n          switch (t) {\n            case Js.Added:\n              return \"ADD\";\n\n            case Js.Current:\n              return \"CURRENT\";\n\n            case Js.NoChange:\n              return \"NO_CHANGE\";\n\n            case Js.Removed:\n              return \"REMOVE\";\n\n            case Js.Reset:\n              return \"RESET\";\n\n            default:\n              return Mr(\"Unknown WatchTargetChangeState: \" + t);\n          }\n        }, t.prototype.toTestWatchChange = function (t) {\n          if (t instanceof iu) return {\n            filter: {\n              count: t.existenceFilter.count,\n              targetId: t.targetId\n            }\n          };\n\n          if (t instanceof ru) {\n            if (t.newDoc instanceof Mo) {\n              var e = t.newDoc;\n              return {\n                documentChange: {\n                  document: {\n                    name: this.toName(e.key),\n                    fields: this.toFields(e.data),\n                    updateTime: this.toVersion(e.version)\n                  },\n                  targetIds: t.updatedTargetIds,\n                  removedTargetIds: t.removedTargetIds\n                }\n              };\n            }\n\n            if (t.newDoc instanceof Oo) {\n              e = t.newDoc;\n              return {\n                documentDelete: {\n                  document: this.toName(e.key),\n                  readTime: this.toVersion(e.version),\n                  removedTargetIds: t.removedTargetIds\n                }\n              };\n            }\n\n            if (null === t.newDoc) return {\n              documentRemove: {\n                document: this.toName(t.key),\n                removedTargetIds: t.removedTargetIds\n              }\n            };\n          }\n\n          if (t instanceof ou) {\n            var n = void 0;\n            return t.cause && (n = {\n              code: function (t) {\n                if (void 0 === t) return Bs.OK;\n\n                switch (t) {\n                  case Lr.OK:\n                    return Bs.OK;\n\n                  case Lr.CANCELLED:\n                    return Bs.CANCELLED;\n\n                  case Lr.UNKNOWN:\n                    return Bs.UNKNOWN;\n\n                  case Lr.DEADLINE_EXCEEDED:\n                    return Bs.DEADLINE_EXCEEDED;\n\n                  case Lr.RESOURCE_EXHAUSTED:\n                    return Bs.RESOURCE_EXHAUSTED;\n\n                  case Lr.INTERNAL:\n                    return Bs.INTERNAL;\n\n                  case Lr.UNAVAILABLE:\n                    return Bs.UNAVAILABLE;\n\n                  case Lr.UNAUTHENTICATED:\n                    return Bs.UNAUTHENTICATED;\n\n                  case Lr.INVALID_ARGUMENT:\n                    return Bs.INVALID_ARGUMENT;\n\n                  case Lr.NOT_FOUND:\n                    return Bs.NOT_FOUND;\n\n                  case Lr.ALREADY_EXISTS:\n                    return Bs.ALREADY_EXISTS;\n\n                  case Lr.PERMISSION_DENIED:\n                    return Bs.PERMISSION_DENIED;\n\n                  case Lr.FAILED_PRECONDITION:\n                    return Bs.FAILED_PRECONDITION;\n\n                  case Lr.ABORTED:\n                    return Bs.ABORTED;\n\n                  case Lr.OUT_OF_RANGE:\n                    return Bs.OUT_OF_RANGE;\n\n                  case Lr.UNIMPLEMENTED:\n                    return Bs.UNIMPLEMENTED;\n\n                  case Lr.DATA_LOSS:\n                    return Bs.DATA_LOSS;\n\n                  default:\n                    return Mr(\"Unknown status code: \" + t);\n                }\n              }(t.cause.code),\n              message: t.cause.message\n            }), {\n              targetChange: {\n                targetChangeType: this.toWatchTargetChangeState(t.state),\n                targetIds: t.targetIds,\n                resumeToken: this.unsafeCastProtoByteString(t.resumeToken),\n                cause: n\n              }\n            };\n          }\n\n          return Mr(\"Unrecognized watch change: \" + JSON.stringify(t));\n        }, t.prototype.fromWatchChange = function (t) {\n          var e;\n\n          if (\"targetChange\" in t) {\n            qu(t.targetChange, \"targetChange\");\n            var n = this.fromWatchTargetChangeState(t.targetChange.targetChangeType || \"NO_CHANGE\"),\n                r = t.targetChange.targetIds || [],\n                i = t.targetChange.resumeToken || this.emptyByteString(),\n                o = t.targetChange.cause,\n                a = o && this.fromRpcStatus(o);\n            e = new ou(n, r, i, a || null);\n          } else if (\"documentChange\" in t) {\n            qu(t.documentChange, \"documentChange\"), qu(t.documentChange.document, \"documentChange.name\"), qu(t.documentChange.document.name, \"documentChange.document.name\"), qu(t.documentChange.document.updateTime, \"documentChange.document.updateTime\");\n            var s = t.documentChange,\n                u = this.fromName(s.document.name),\n                c = this.fromVersion(s.document.updateTime),\n                h = this.fromFields(s.document.fields || {}),\n                l = new Mo(u, c, h, {}, s.document),\n                f = s.targetIds || [],\n                p = s.removedTargetIds || [];\n            e = new ru(f, p, l.key, l);\n          } else if (\"documentDelete\" in t) {\n            qu(t.documentDelete, \"documentDelete\"), qu(t.documentDelete.document, \"documentDelete.document\");\n            var d = t.documentDelete;\n            u = this.fromName(d.document), c = d.readTime ? this.fromVersion(d.readTime) : Vi.forDeletedDoc(), l = new Oo(u, c), p = d.removedTargetIds || [];\n            e = new ru([], p, l.key, l);\n          } else if (\"documentRemove\" in t) {\n            qu(t.documentRemove, \"documentRemove\"), qu(t.documentRemove.document, \"documentRemove\");\n            var m = t.documentRemove;\n            u = this.fromName(m.document), p = m.removedTargetIds || [];\n            e = new ru([], p, u, null);\n          } else {\n            if (!(\"filter\" in t)) return Mr(\"Unknown change type \" + JSON.stringify(t));\n            qu(t.filter, \"filter\"), qu(t.filter.targetId, \"filter.targetId\");\n            var y = t.filter,\n                g = y.count || 0,\n                v = new _u(g),\n                b = y.targetId;\n            e = new iu(b, v);\n          }\n\n          return e;\n        }, t.prototype.fromWatchTargetChangeState = function (t) {\n          return \"NO_CHANGE\" === t ? Js.NoChange : \"ADD\" === t ? Js.Added : \"REMOVE\" === t ? Js.Removed : \"CURRENT\" === t ? Js.Current : \"RESET\" === t ? Js.Reset : Mr(\"Got unexpected TargetChange.state: \" + t);\n        }, t.prototype.versionFromListenResponse = function (t) {\n          if (!(\"targetChange\" in t)) return Vi.MIN;\n          var e = t.targetChange;\n          return e.targetIds && e.targetIds.length ? Vi.MIN : e.readTime ? this.fromVersion(e.readTime) : Vi.MIN;\n        }, t.prototype.toMutation = function (t) {\n          var e,\n              n = this;\n          if (t instanceof as) e = {\n            update: this.toMutationDocument(t.key, t.value)\n          };else if (t instanceof cs) e = {\n            delete: this.toName(t.key)\n          };else if (t instanceof ss) e = {\n            update: this.toMutationDocument(t.key, t.data),\n            updateMask: this.toDocumentMask(t.fieldMask)\n          };else {\n            if (!(t instanceof us)) return Mr(\"Unknown mutation type \" + t.type);\n            e = {\n              transform: {\n                document: this.toName(t.key),\n                fieldTransforms: t.fieldTransforms.map(function (t) {\n                  return n.toFieldTransform(t);\n                })\n              }\n            };\n          }\n          return t.precondition.isNone || (e.currentDocument = this.toPrecondition(t.precondition)), e;\n        }, t.prototype.fromMutation = function (t) {\n          var e = this,\n              n = t.currentDocument ? this.fromPrecondition(t.currentDocument) : is.NONE;\n\n          if (t.update) {\n            qu(t.update.name, \"name\");\n            var r = this.fromName(t.update.name),\n                i = this.fromFields(t.update.fields || {});\n\n            if (t.updateMask) {\n              var o = this.fromDocumentMask(t.updateMask);\n              return new ss(r, i, o, n);\n            }\n\n            return new as(r, i, n);\n          }\n\n          if (t.delete) {\n            r = this.fromName(t.delete);\n            return new cs(r, n);\n          }\n\n          if (t.transform) {\n            r = this.fromName(t.transform.document);\n            var a = t.transform.fieldTransforms.map(function (t) {\n              return e.fromFieldTransform(t);\n            });\n            return Or(!0 === n.exists, 'Transforms only support precondition \"exists == true\"'), new us(r, a);\n          }\n\n          return Mr(\"unknown mutation proto: \" + JSON.stringify(t));\n        }, t.prototype.toPrecondition = function (t) {\n          return Or(!t.isNone, \"Can't serialize an empty precondition\"), void 0 !== t.updateTime ? {\n            updateTime: this.toVersion(t.updateTime)\n          } : void 0 !== t.exists ? {\n            exists: t.exists\n          } : Mr(\"Unknown precondition\");\n        }, t.prototype.fromPrecondition = function (t) {\n          return void 0 !== t.updateTime ? is.updateTime(this.fromVersion(t.updateTime)) : void 0 !== t.exists ? is.exists(t.exists) : is.NONE;\n        }, t.prototype.fromWriteResult = function (t, e) {\n          var n = this,\n              r = t.updateTime ? this.fromVersion(t.updateTime) : this.fromVersion(e),\n              i = null;\n          return t.transformResults && 0 < t.transformResults.length && (i = t.transformResults.map(function (t) {\n            return n.fromValue(t);\n          })), new rs(r, i);\n        }, t.prototype.fromWriteResults = function (t, e) {\n          var n = this;\n          return t && 0 < t.length ? (Or(void 0 !== e, \"Received a write result without a commit time\"), t.map(function (t) {\n            return n.fromWriteResult(t, e);\n          })) : [];\n        }, t.prototype.toFieldTransform = function (t) {\n          var e = this,\n              n = t.transform;\n          if (n instanceof Du) return {\n            fieldPath: t.field.canonicalString(),\n            setToServerValue: \"REQUEST_TIME\"\n          };\n          if (n instanceof Nu) return {\n            fieldPath: t.field.canonicalString(),\n            appendMissingElements: {\n              values: n.elements.map(function (t) {\n                return e.toValue(t);\n              })\n            }\n          };\n          if (n instanceof Au) return {\n            fieldPath: t.field.canonicalString(),\n            removeAllFromArray: {\n              values: n.elements.map(function (t) {\n                return e.toValue(t);\n              })\n            }\n          };\n          if (n instanceof ku) return {\n            fieldPath: t.field.canonicalString(),\n            increment: this.toValue(n.operand)\n          };\n          throw Mr(\"Unknown transform: \" + t.transform);\n        }, t.prototype.fromFieldTransform = function (t) {\n          var e = this,\n              n = null;\n          if (\"setToServerValue\" in t) Or(\"REQUEST_TIME\" === t.setToServerValue, \"Unknown server value transform proto: \" + JSON.stringify(t)), n = Du.instance;else if (\"appendMissingElements\" in t) {\n            var r = t.appendMissingElements.values || [];\n            n = new Nu(r.map(function (t) {\n              return e.fromValue(t);\n            }));\n          } else if (\"removeAllFromArray\" in t) {\n            r = t.removeAllFromArray.values || [];\n            n = new Au(r.map(function (t) {\n              return e.fromValue(t);\n            }));\n          } else if (\"increment\" in t) {\n            var i = this.fromValue(t.increment);\n            Or(i instanceof Ba, \"NUMERIC_ADD transform requires a NumberValue\"), n = new ku(i);\n          } else Mr(\"Unknown transform proto: \" + JSON.stringify(t));\n          var o = Ci.fromServerFormat(t.fieldPath);\n          return new ns(o, n);\n        }, t.prototype.toDocumentsTarget = function (t) {\n          return {\n            documents: [this.toQueryPath(t.path)]\n          };\n        }, t.prototype.fromDocumentsTarget = function (t) {\n          var e = t.documents.length;\n          Or(1 === e, \"DocumentsTarget contained other than 1 document: \" + e);\n          var n = t.documents[0];\n          return pu.atPath(this.fromQueryPath(n));\n        }, t.prototype.toQueryTarget = function (t) {\n          var e = {\n            structuredQuery: {}\n          },\n              n = t.path;\n          null !== t.collectionGroup ? (Or(n.length % 2 == 0, \"Collection Group queries should be within a document path or root.\"), e.parent = this.toQueryPath(n), e.structuredQuery.from = [{\n            collectionId: t.collectionGroup,\n            allDescendants: !0\n          }]) : (Or(n.length % 2 != 0, \"Document queries with filters are not supported.\"), e.parent = this.toQueryPath(n.popLast()), e.structuredQuery.from = [{\n            collectionId: n.lastSegment()\n          }]);\n          var r = this.toFilter(t.filters);\n          r && (e.structuredQuery.where = r);\n          var i = this.toOrder(t.orderBy);\n          i && (e.structuredQuery.orderBy = i);\n          var o = this.toInt32Value(t.limit);\n          return void 0 !== o && (e.structuredQuery.limit = o), t.startAt && (e.structuredQuery.startAt = this.toCursor(t.startAt)), t.endAt && (e.structuredQuery.endAt = this.toCursor(t.endAt)), e;\n        }, t.prototype.fromQueryTarget = function (t) {\n          var e = this.fromQueryPath(t.parent),\n              n = t.structuredQuery,\n              r = n.from ? n.from.length : 0,\n              i = null;\n\n          if (0 < r) {\n            Or(1 === r, \"StructuredQuery.from with more than one collection is not supported.\");\n            var o = n.from[0];\n            o.allDescendants ? i = o.collectionId : e = e.child(o.collectionId);\n          }\n\n          var a = [];\n          n.where && (a = this.fromFilter(n.where));\n          var s = [];\n          n.orderBy && (s = this.fromOrder(n.orderBy));\n          var u = null;\n          n.limit && (u = this.fromInt32Value(n.limit));\n          var c = null;\n          n.startAt && (c = this.fromCursor(n.startAt));\n          var h = null;\n          return n.endAt && (h = this.fromCursor(n.endAt)), new pu(e, i, s, a, u, c, h);\n        }, t.prototype.toListenRequestLabels = function (t) {\n          var e = this.toLabel(t.purpose);\n          return null == e ? null : {\n            \"goog-listen-tags\": e\n          };\n        }, t.prototype.toLabel = function (t) {\n          switch (t) {\n            case ha.Listen:\n              return null;\n\n            case ha.ExistenceFilterMismatch:\n              return \"existence-filter-mismatch\";\n\n            case ha.LimboResolution:\n              return \"limbo-document\";\n\n            default:\n              return Mr(\"Unrecognized query purpose: \" + t);\n          }\n        }, t.prototype.toTarget = function (t) {\n          var e,\n              n = t.query;\n          return (e = n.isDocumentQuery() ? {\n            documents: this.toDocumentsTarget(n)\n          } : {\n            query: this.toQueryTarget(n)\n          }).targetId = t.targetId, 0 < t.resumeToken.length && (e.resumeToken = this.unsafeCastProtoByteString(t.resumeToken)), e;\n        }, t.prototype.toFilter = function (t) {\n          var e = this;\n\n          if (0 !== t.length) {\n            var n = t.map(function (t) {\n              return t instanceof yu ? e.toUnaryOrFieldFilter(t) : Mr(\"Unrecognized filter: \" + JSON.stringify(t));\n            });\n            return 1 === n.length ? n[0] : {\n              compositeFilter: {\n                op: \"AND\",\n                filters: n\n              }\n            };\n          }\n        }, t.prototype.fromFilter = function (t) {\n          var e = this;\n          return t ? void 0 !== t.unaryFilter ? [this.fromUnaryFilter(t)] : void 0 !== t.fieldFilter ? [this.fromFieldFilter(t)] : void 0 !== t.compositeFilter ? t.compositeFilter.filters.map(function (t) {\n            return e.fromFilter(t);\n          }).reduce(function (t, e) {\n            return t.concat(e);\n          }) : Mr(\"Unknown filter: \" + JSON.stringify(t)) : [];\n        }, t.prototype.toOrder = function (t) {\n          var e = this;\n          if (0 !== t.length) return t.map(function (t) {\n            return e.toPropertyOrder(t);\n          });\n        }, t.prototype.fromOrder = function (t) {\n          var e = this;\n          return t.map(function (t) {\n            return e.fromPropertyOrder(t);\n          });\n        }, t.prototype.toCursor = function (t) {\n          var e = this;\n          return {\n            before: t.before,\n            values: t.position.map(function (t) {\n              return e.toValue(t);\n            })\n          };\n        }, t.prototype.fromCursor = function (t) {\n          var e = this,\n              n = !!t.before,\n              r = t.values.map(function (t) {\n            return e.fromValue(t);\n          });\n          return new Su(r, n);\n        }, t.prototype.toDirection = function (t) {\n          return Pu[t.name];\n        }, t.prototype.fromDirection = function (t) {\n          switch (t) {\n            case \"ASCENDING\":\n              return Eu.ASCENDING;\n\n            case \"DESCENDING\":\n              return Eu.DESCENDING;\n\n            default:\n              return;\n          }\n        }, t.prototype.toOperatorName = function (t) {\n          return Lu[t.name];\n        }, t.prototype.fromOperatorName = function (t) {\n          switch (t) {\n            case \"EQUAL\":\n              return mu.EQUAL;\n\n            case \"GREATER_THAN\":\n              return mu.GREATER_THAN;\n\n            case \"GREATER_THAN_OR_EQUAL\":\n              return mu.GREATER_THAN_OR_EQUAL;\n\n            case \"LESS_THAN\":\n              return mu.LESS_THAN;\n\n            case \"LESS_THAN_OR_EQUAL\":\n              return mu.LESS_THAN_OR_EQUAL;\n\n            case \"ARRAY_CONTAINS\":\n              return mu.ARRAY_CONTAINS;\n\n            case \"IN\":\n              return mu.IN;\n\n            case \"ARRAY_CONTAINS_ANY\":\n              return mu.ARRAY_CONTAINS_ANY;\n\n            case \"OPERATOR_UNSPECIFIED\":\n              return Mr(\"Unspecified operator\");\n\n            default:\n              return Mr(\"Unknown operator\");\n          }\n        }, t.prototype.toFieldPathReference = function (t) {\n          return {\n            fieldPath: t.canonicalString()\n          };\n        }, t.prototype.fromFieldPathReference = function (t) {\n          return Ci.fromServerFormat(t.fieldPath);\n        }, t.prototype.toPropertyOrder = function (t) {\n          return {\n            field: this.toFieldPathReference(t.field),\n            direction: this.toDirection(t.dir)\n          };\n        }, t.prototype.fromPropertyOrder = function (t) {\n          return new Tu(this.fromFieldPathReference(t.field), this.fromDirection(t.direction));\n        }, t.prototype.fromFieldFilter = function (t) {\n          return yu.create(this.fromFieldPathReference(t.fieldFilter.field), this.fromOperatorName(t.fieldFilter.op), this.fromValue(t.fieldFilter.value));\n        }, t.prototype.toUnaryOrFieldFilter = function (t) {\n          if (t.op === mu.EQUAL) {\n            if (t.value.isEqual(Wa.NAN)) return {\n              unaryFilter: {\n                field: this.toFieldPathReference(t.field),\n                op: \"IS_NAN\"\n              }\n            };\n            if (t.value.isEqual(Va.INSTANCE)) return {\n              unaryFilter: {\n                field: this.toFieldPathReference(t.field),\n                op: \"IS_NULL\"\n              }\n            };\n          }\n\n          return {\n            fieldFilter: {\n              field: this.toFieldPathReference(t.field),\n              op: this.toOperatorName(t.op),\n              value: this.toValue(t.value)\n            }\n          };\n        }, t.prototype.fromUnaryFilter = function (t) {\n          switch (t.unaryFilter.op) {\n            case \"IS_NAN\":\n              var e = this.fromFieldPathReference(t.unaryFilter.field);\n              return yu.create(e, mu.EQUAL, Wa.NAN);\n\n            case \"IS_NULL\":\n              var n = this.fromFieldPathReference(t.unaryFilter.field);\n              return yu.create(n, mu.EQUAL, Va.INSTANCE);\n\n            case \"OPERATOR_UNSPECIFIED\":\n              return Mr(\"Unspecified filter\");\n\n            default:\n              return Mr(\"Unknown filter\");\n          }\n        }, t.prototype.toDocumentMask = function (t) {\n          var e = [];\n          return t.fields.forEach(function (t) {\n            return e.push(t.canonicalString());\n          }), {\n            fieldPaths: e\n          };\n        }, t.prototype.fromDocumentMask = function (t) {\n          var e = (t.fieldPaths || []).map(function (t) {\n            return Ci.fromServerFormat(t);\n          });\n          return es.fromArray(e);\n        }, t;\n      }(),\n          Uu = function () {\n        this.listeners = [];\n      },\n          Bu = function () {\n        function t(t) {\n          this.syncEngine = t, this.queries = new Po(function (t) {\n            return t.canonicalId();\n          }), this.onlineState = Os.Unknown, this.syncEngine.subscribe(this);\n        }\n\n        return t.prototype.listen = function (t) {\n          var e = t.query,\n              n = !1,\n              r = this.queries.get(e);\n          return r || (n = !0, r = new Uu(), this.queries.set(e, r)), r.listeners.push(t), t.applyOnlineStateChange(this.onlineState), r.viewSnap && t.onViewSnapshot(r.viewSnap), n ? this.syncEngine.listen(e).then(function (t) {\n            return r.targetId = t;\n          }) : Promise.resolve(r.targetId);\n        }, t.prototype.unlisten = function (o) {\n          return h(this, void 0, void 0, function () {\n            var e, n, r, i;\n            return p(this, function (t) {\n              return e = o.query, n = !1, (r = this.queries.get(e)) && 0 <= (i = r.listeners.indexOf(o)) && (r.listeners.splice(i, 1), n = 0 === r.listeners.length), n ? (this.queries.delete(e), [2, this.syncEngine.unlisten(e)]) : [2];\n            });\n          });\n        }, t.prototype.onWatchChange = function (t) {\n          for (var e = 0, n = t; e < n.length; e++) {\n            var r = n[e],\n                i = r.query,\n                o = this.queries.get(i);\n\n            if (o) {\n              for (var a = 0, s = o.listeners; a < s.length; a++) {\n                s[a].onViewSnapshot(r);\n              }\n\n              o.viewSnap = r;\n            }\n          }\n        }, t.prototype.onWatchError = function (t, e) {\n          var n = this.queries.get(t);\n          if (n) for (var r = 0, i = n.listeners; r < i.length; r++) {\n            i[r].onError(e);\n          }\n          this.queries.delete(t);\n        }, t.prototype.onOnlineStateChange = function (i) {\n          this.onlineState = i, this.queries.forEach(function (t, e) {\n            for (var n = 0, r = e.listeners; n < r.length; n++) {\n              r[n].applyOnlineStateChange(i);\n            }\n          });\n        }, t;\n      }(),\n          Qu = function () {\n        function t(t, e, n) {\n          this.query = t, this.queryObserver = e, this.raisedInitialEvent = !1, this.onlineState = Os.Unknown, this.options = n || {};\n        }\n\n        return t.prototype.onViewSnapshot = function (t) {\n          if (Or(0 < t.docChanges.length || t.syncStateChanged, \"We got a new snapshot with no changes?\"), !this.options.includeMetadataChanges) {\n            for (var e = [], n = 0, r = t.docChanges; n < r.length; n++) {\n              var i = r[n];\n              i.type !== Ws.Metadata && e.push(i);\n            }\n\n            t = new tu(t.query, t.docs, t.oldDocs, e, t.mutatedKeys, t.fromCache, t.syncStateChanged, !0);\n          }\n\n          this.raisedInitialEvent ? this.shouldRaiseEvent(t) && this.queryObserver.next(t) : this.shouldRaiseInitialEvent(t, this.onlineState) && this.raiseInitialEvent(t), this.snap = t;\n        }, t.prototype.onError = function (t) {\n          this.queryObserver.error(t);\n        }, t.prototype.applyOnlineStateChange = function (t) {\n          this.onlineState = t, this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, t) && this.raiseInitialEvent(this.snap);\n        }, t.prototype.shouldRaiseInitialEvent = function (t, e) {\n          if (Or(!this.raisedInitialEvent, \"Determining whether to raise first event but already had first event\"), !t.fromCache) return !0;\n          var n = e !== Os.Offline;\n          return this.options.waitForSyncWhenOnline && n ? (Or(t.fromCache, \"Waiting for sync, but snapshot is not from cache\"), !1) : !t.docs.isEmpty() || e === Os.Offline;\n        }, t.prototype.shouldRaiseEvent = function (t) {\n          if (0 < t.docChanges.length) return !0;\n          var e = this.snap && this.snap.hasPendingWrites !== t.hasPendingWrites;\n          return !(!t.syncStateChanged && !e) && !0 === this.options.includeMetadataChanges;\n        }, t.prototype.raiseInitialEvent = function (t) {\n          Or(!this.raisedInitialEvent, \"Trying to raise initial events for second time\"), t = tu.fromInitialDocuments(t.query, t.docs, t.mutatedKeys, t.fromCache), this.raisedInitialEvent = !0, this.queryObserver.next(t);\n        }, t;\n      }(),\n          Ku = function () {\n        function s(t, e, n) {\n          this.targetId = t, this.addedKeys = e, this.removedKeys = n;\n        }\n\n        return s.fromSnapshot = function (t, e) {\n          for (var n = to(), r = to(), i = 0, o = e.docChanges; i < o.length; i++) {\n            var a = o[i];\n\n            switch (a.type) {\n              case Ws.Added:\n                n = n.add(a.doc.key);\n                break;\n\n              case Ws.Removed:\n                r = r.add(a.doc.key);\n            }\n          }\n\n          return new s(t, n, r);\n        }, s;\n      }(),\n          ju = function (t) {\n        this.key = t;\n      },\n          Gu = function (t) {\n        this.key = t;\n      },\n          Wu = function () {\n        function t(t, e) {\n          this.query = t, this._syncedDocuments = e, this.syncState = null, this.current = !1, this.limboDocuments = to(), this.mutatedKeys = to(), this.documentSet = new Xs(t.docComparator.bind(t));\n        }\n\n        return Object.defineProperty(t.prototype, \"syncedDocuments\", {\n          get: function () {\n            return this._syncedDocuments;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.computeDocChanges = function (t, e) {\n          var s = this,\n              u = e ? e.changeSet : new Zs(),\n              c = e ? e.documentSet : this.documentSet,\n              h = e ? e.mutatedKeys : this.mutatedKeys,\n              l = c,\n              f = !1,\n              p = this.query.hasLimit() && c.size === this.query.limit ? c.last() : null;\n          if (t.inorderTraversal(function (t, e) {\n            var n = c.get(t),\n                r = e instanceof Mo ? e : null;\n            r && (Or(t.isEqual(r.key), \"Mismatching keys found in document changes: \" + t + \" != \" + r.key), r = s.query.matches(r) ? r : null);\n            var i = !!n && s.mutatedKeys.has(n.key),\n                o = !!r && (r.hasLocalMutations || s.mutatedKeys.has(r.key) && r.hasCommittedMutations),\n                a = !1;\n            n && r ? n.data.isEqual(r.data) ? i !== o && (u.track({\n              type: Ws.Metadata,\n              doc: r\n            }), a = !0) : s.shouldWaitForSyncedDocument(n, r) || (u.track({\n              type: Ws.Modified,\n              doc: r\n            }), a = !0, p && 0 < s.query.docComparator(r, p) && (f = !0)) : !n && r ? (u.track({\n              type: Ws.Added,\n              doc: r\n            }), a = !0) : n && !r && (u.track({\n              type: Ws.Removed,\n              doc: n\n            }), a = !0, p && (f = !0));\n            a && (h = r ? (l = l.add(r), o ? h.add(t) : h.delete(t)) : (l = l.delete(t), h.delete(t)));\n          }), this.query.hasLimit()) for (; l.size > this.query.limit;) {\n            var n = l.last();\n            l = l.delete(n.key), h = h.delete(n.key), u.track({\n              type: Ws.Removed,\n              doc: n\n            });\n          }\n          return Or(!f || !e, \"View was refilled using docs that themselves needed refilling.\"), {\n            documentSet: l,\n            changeSet: u,\n            needsRefill: f,\n            mutatedKeys: h\n          };\n        }, t.prototype.shouldWaitForSyncedDocument = function (t, e) {\n          return t.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;\n        }, t.prototype.applyChanges = function (t, e, n) {\n          var o = this;\n          Or(!t.needsRefill, \"Cannot apply changes that need a refill\");\n          var r = this.documentSet;\n          this.documentSet = t.documentSet, this.mutatedKeys = t.mutatedKeys;\n          var i = t.changeSet.getChanges();\n          i.sort(function (t, e) {\n            return n = t.type, r = e.type, (i = function (t) {\n              switch (t) {\n                case Ws.Added:\n                  return 1;\n\n                case Ws.Modified:\n                case Ws.Metadata:\n                  return 2;\n\n                case Ws.Removed:\n                  return 0;\n\n                default:\n                  return Mr(\"Unknown ChangeType: \" + t);\n              }\n            })(n) - i(r) || o.query.docComparator(t.doc, e.doc);\n            var n, r, i;\n          }), this.applyTargetChange(n);\n          var a = e ? this.updateLimboDocuments() : [],\n              s = 0 === this.limboDocuments.size && this.current ? Hs.Synced : Hs.Local,\n              u = s !== this.syncState;\n          return this.syncState = s, 0 !== i.length || u ? {\n            snapshot: new tu(this.query, t.documentSet, r, i, t.mutatedKeys, s === Hs.Local, u, !1),\n            limboChanges: a\n          } : {\n            limboChanges: a\n          };\n        }, t.prototype.applyOnlineStateChange = function (t) {\n          return this.current && t === Os.Offline ? (this.current = !1, this.applyChanges({\n            documentSet: this.documentSet,\n            changeSet: new Zs(),\n            mutatedKeys: this.mutatedKeys,\n            needsRefill: !1\n          }, !1)) : {\n            limboChanges: []\n          };\n        }, t.prototype.shouldBeInLimbo = function (t) {\n          return !this._syncedDocuments.has(t) && !!this.documentSet.has(t) && !this.documentSet.get(t).hasLocalMutations;\n        }, t.prototype.applyTargetChange = function (t) {\n          var e = this;\n          t && (t.addedDocuments.forEach(function (t) {\n            return e._syncedDocuments = e._syncedDocuments.add(t);\n          }), t.modifiedDocuments.forEach(function (t) {\n            return Or(e._syncedDocuments.has(t), \"Modified document \" + t + \" not found in view.\");\n          }), t.removedDocuments.forEach(function (t) {\n            return e._syncedDocuments = e._syncedDocuments.delete(t);\n          }), this.current = t.current);\n        }, t.prototype.updateLimboDocuments = function () {\n          var e = this;\n          if (!this.current) return [];\n          var n = this.limboDocuments;\n          this.limboDocuments = to(), this.documentSet.forEach(function (t) {\n            e.shouldBeInLimbo(t.key) && (e.limboDocuments = e.limboDocuments.add(t.key));\n          });\n          var r = [];\n          return n.forEach(function (t) {\n            e.limboDocuments.has(t) || r.push(new Gu(t));\n          }), this.limboDocuments.forEach(function (t) {\n            n.has(t) || r.push(new ju(t));\n          }), r;\n        }, t.prototype.synchronizeWithPersistedState = function (t, e) {\n          this._syncedDocuments = e, this.limboDocuments = to();\n          var n = this.computeDocChanges(t);\n          return this.applyChanges(n, !0);\n        }, t.prototype.computeInitialSnapshot = function () {\n          return tu.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === Hs.Local);\n        }, t;\n      }();\n\n      var zu = \"SyncEngine\",\n          Hu = function (t, e, n) {\n        this.query = t, this.targetId = e, this.view = n;\n      },\n          Yu = function (t) {\n        this.key = t;\n      },\n          Xu = function () {\n        function t(t, e, n, r) {\n          this.localStore = t, this.remoteStore = e, this.sharedClientState = n, this.currentUser = r, this.syncEngineListener = null, this.queryViewsByQuery = new Po(function (t) {\n            return t.canonicalId();\n          }), this.queryViewsByTarget = {}, this.limboTargetsByKey = new Ui(Di.comparator), this.limboResolutionsByTarget = {}, this.limboDocumentRefs = new ls(), this.mutationUserCallbacks = {}, this.limboTargetIdGenerator = yo.forSyncEngine(), this.isPrimary = void 0, this.onlineState = Os.Unknown;\n        }\n\n        return Object.defineProperty(t.prototype, \"isPrimaryClient\", {\n          get: function () {\n            return !0 === this.isPrimary;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.subscribe = function (t) {\n          Or(null !== t, \"SyncEngine listener cannot be null\"), Or(null === this.syncEngineListener, \"SyncEngine already has a subscriber.\"), this.syncEngineListener = t;\n        }, t.prototype.listen = function (a) {\n          return h(this, void 0, void 0, function () {\n            var e, n, r, i, o;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.assertSubscribed(\"listen()\"), (r = this.queryViewsByQuery.get(a)) ? (e = r.targetId, this.sharedClientState.addLocalQueryTarget(e), n = r.view.computeInitialSnapshot(), [3, 4]) : [3, 1];\n\n                case 1:\n                  return [4, this.localStore.allocateQuery(a)];\n\n                case 2:\n                  return i = t.sent(), o = this.sharedClientState.addLocalQueryTarget(i.targetId), e = i.targetId, [4, this.initializeViewAndComputeSnapshot(i, \"current\" === o)];\n\n                case 3:\n                  n = t.sent(), this.isPrimary && this.remoteStore.listen(i), t.label = 4;\n\n                case 4:\n                  return this.syncEngineListener.onWatchChange([n]), [2, e];\n              }\n            });\n          });\n        }, t.prototype.initializeViewAndComputeSnapshot = function (s, u) {\n          var c = this,\n              h = s.query;\n          return this.localStore.executeQuery(h).then(function (a) {\n            return c.localStore.remoteDocumentKeys(s.targetId).then(function (t) {\n              var e = new Wu(h, t),\n                  n = e.computeDocChanges(a),\n                  r = nu.createSynthesizedTargetChangeForCurrentChange(s.targetId, u && c.onlineState !== Os.Offline),\n                  i = e.applyChanges(n, !0 === c.isPrimary, r);\n              Or(0 === i.limboChanges.length, \"View returned limbo docs before target ack from the server.\"), Or(!!i.snapshot, \"applyChanges for new view should always return a snapshot\");\n              var o = new Hu(h, s.targetId, e);\n              return c.queryViewsByQuery.set(h, o), c.queryViewsByTarget[s.targetId] = o, i.snapshot;\n            });\n          });\n        }, t.prototype.synchronizeViewAndComputeSnapshot = function (i) {\n          var t = this;\n          return this.localStore.executeQuery(i.query).then(function (r) {\n            return t.localStore.remoteDocumentKeys(i.targetId).then(function (n) {\n              return h(t, void 0, void 0, function () {\n                var e;\n                return p(this, function (t) {\n                  return e = i.view.synchronizeWithPersistedState(r, n), this.isPrimary && this.updateTrackedLimbos(i.targetId, e.limboChanges), [2, e];\n                });\n              });\n            });\n          });\n        }, t.prototype.unlisten = function (r) {\n          return h(this, void 0, void 0, function () {\n            var e,\n                n = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.assertSubscribed(\"unlisten()\"), Or(!!(e = this.queryViewsByQuery.get(r)), \"Trying to unlisten on query not found:\" + r), this.isPrimary ? (this.sharedClientState.removeLocalQueryTarget(e.targetId), this.sharedClientState.isActiveQueryTarget(e.targetId) ? [3, 2] : [4, this.localStore.releaseQuery(r, !1).then(function () {\n                    n.sharedClientState.clearQueryState(e.targetId), n.remoteStore.unlisten(e.targetId), n.removeAndCleanupQuery(e);\n                  }).catch(Aa)]) : [3, 3];\n\n                case 1:\n                  t.sent(), t.label = 2;\n\n                case 2:\n                  return [3, 5];\n\n                case 3:\n                  return this.removeAndCleanupQuery(e), [4, this.localStore.releaseQuery(r, !0)];\n\n                case 4:\n                  t.sent(), t.label = 5;\n\n                case 5:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.write = function (t, e) {\n          var n = this;\n          return this.assertSubscribed(\"write()\"), this.localStore.localWrite(t).then(function (t) {\n            return n.sharedClientState.addPendingMutation(t.batchId), n.addMutationCallback(t.batchId, e), n.emitNewSnapsAndNotifyLocalStore(t.changes);\n          }).then(function () {\n            return n.remoteStore.fillWritePipeline();\n          });\n        }, t.prototype.wrapUpdateFunctionError = function (t) {\n          return t;\n        }, t.prototype.runTransaction = function (e, n) {\n          var r = this;\n          void 0 === n && (n = 5), Or(0 <= n, \"Got negative number of retries for transaction.\");\n          var i = this.remoteStore.createTransaction();\n          return function () {\n            try {\n              var t = e(i);\n              return !Ds(t) && t.catch && t.then ? t.catch(function (t) {\n                return Promise.reject(r.wrapUpdateFunctionError(t));\n              }) : Promise.reject(Error(\"Transaction callback must return a Promise\"));\n            } catch (t) {\n              return Promise.reject(r.wrapUpdateFunctionError(t));\n            }\n          }().then(function (t) {\n            return i.commit().then(function () {\n              return t;\n            }).catch(function (t) {\n              return 0 === n ? Promise.reject(t) : r.runTransaction(e, n - 1);\n            });\n          });\n        }, t.prototype.applyRemoteEvent = function (e) {\n          var r = this;\n          return this.assertSubscribed(\"applyRemoteEvent()\"), this.localStore.applyRemoteEvent(e).then(function (t) {\n            return Br(e.targetChanges, function (t, e) {\n              var n = r.limboResolutionsByTarget[Number(t)];\n              n && (Or(e.addedDocuments.size + e.modifiedDocuments.size + e.removedDocuments.size <= 1, \"Limbo resolution for single document contains multiple changes.\"), 0 < e.addedDocuments.size ? n.receivedDocument = !0 : 0 < e.modifiedDocuments.size ? Or(n.receivedDocument, \"Received change for limbo target document without add.\") : 0 < e.removedDocuments.size && (Or(n.receivedDocument, \"Received remove for limbo target document without add.\"), n.receivedDocument = !1));\n            }), r.emitNewSnapsAndNotifyLocalStore(t, e);\n          }).catch(Aa);\n        }, t.prototype.applyOnlineStateChange = function (r, t) {\n          if (this.isPrimary && t === Ps.RemoteStore || !this.isPrimary && t === Ps.SharedClientState) {\n            var i = [];\n            this.queryViewsByQuery.forEach(function (t, e) {\n              var n = e.view.applyOnlineStateChange(r);\n              Or(0 === n.limboChanges.length, \"OnlineState should not affect limbo documents.\"), n.snapshot && i.push(n.snapshot);\n            }), this.syncEngineListener.onOnlineStateChange(r), this.syncEngineListener.onWatchChange(i), this.onlineState = r, this.isPrimary && this.sharedClientState.setOnlineState(r);\n          }\n        }, t.prototype.rejectListen = function (u, c) {\n          return h(this, void 0, void 0, function () {\n            var e,\n                n,\n                r,\n                i,\n                o,\n                a,\n                s = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.assertSubscribed(\"rejectListens()\"), this.sharedClientState.updateQueryState(u, \"rejected\", c), e = this.limboResolutionsByTarget[u], (n = e && e.key) ? (this.limboTargetsByKey = this.limboTargetsByKey.remove(n), delete this.limboResolutionsByTarget[u], r = (r = new Ui(Di.comparator)).insert(n, new Oo(n, Vi.forDeletedDoc())), i = to().add(n), o = new eu(Vi.MIN, {}, new ji(ui), r, i), [2, this.applyRemoteEvent(o)]) : [3, 1];\n\n                case 1:\n                  return Or(!!(a = this.queryViewsByTarget[u]), \"Unknown targetId: \" + u), [4, this.localStore.releaseQuery(a.query, !1).then(function () {\n                    return s.removeAndCleanupQuery(a);\n                  }).catch(Aa)];\n\n                case 2:\n                  t.sent(), this.syncEngineListener.onWatchError(a.query, c), t.label = 3;\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.applyBatchState = function (n, r, i) {\n          return h(this, void 0, void 0, function () {\n            var e;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.assertSubscribed(\"applyBatchState()\"), [4, this.localStore.lookupMutationDocuments(n)];\n\n                case 1:\n                  return null === (e = t.sent()) ? (Ar(zu, \"Cannot apply mutation batch with id: \" + n), [2]) : \"pending\" !== r ? [3, 3] : [4, this.remoteStore.fillWritePipeline()];\n\n                case 2:\n                  return t.sent(), [3, 4];\n\n                case 3:\n                  \"acknowledged\" === r || \"rejected\" === r ? (this.processUserCallback(n, i || null), this.localStore.removeCachedMutationBatchMetadata(n)) : Mr(\"Unknown batchState: \" + r), t.label = 4;\n\n                case 4:\n                  return [4, this.emitNewSnapsAndNotifyLocalStore(e)];\n\n                case 5:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.applySuccessfulWrite = function (t) {\n          var e = this;\n          this.assertSubscribed(\"applySuccessfulWrite()\");\n          var n = t.batch.batchId;\n          return this.processUserCallback(n, null), this.localStore.acknowledgeBatch(t).then(function (t) {\n            return e.sharedClientState.updateMutationState(n, \"acknowledged\"), e.emitNewSnapsAndNotifyLocalStore(t);\n          }).catch(Aa);\n        }, t.prototype.rejectFailedWrite = function (e, n) {\n          var r = this;\n          return this.assertSubscribed(\"rejectFailedWrite()\"), this.processUserCallback(e, n), this.localStore.rejectBatch(e).then(function (t) {\n            return r.sharedClientState.updateMutationState(e, \"rejected\", n), r.emitNewSnapsAndNotifyLocalStore(t);\n          }).catch(Aa);\n        }, t.prototype.addMutationCallback = function (t, e) {\n          var n = this.mutationUserCallbacks[this.currentUser.toKey()];\n          n || (n = new Ui(ui)), n = n.insert(t, e), this.mutationUserCallbacks[this.currentUser.toKey()] = n;\n        }, t.prototype.processUserCallback = function (t, e) {\n          var n = this.mutationUserCallbacks[this.currentUser.toKey()];\n\n          if (n) {\n            var r = n.get(t);\n            r && (Or(t === n.minKey(), \"Mutation callbacks processed out-of-order?\"), e ? r.reject(e) : r.resolve(), n = n.remove(t)), this.mutationUserCallbacks[this.currentUser.toKey()] = n;\n          }\n        }, t.prototype.removeAndCleanupQuery = function (t) {\n          var e = this;\n\n          if (this.sharedClientState.removeLocalQueryTarget(t.targetId), this.queryViewsByQuery.delete(t.query), delete this.queryViewsByTarget[t.targetId], this.isPrimary) {\n            var n = this.limboDocumentRefs.referencesForId(t.targetId);\n            this.limboDocumentRefs.removeReferencesForId(t.targetId), n.forEach(function (t) {\n              e.limboDocumentRefs.containsKey(t) || e.removeLimboTarget(t);\n            });\n          }\n        }, t.prototype.removeLimboTarget = function (t) {\n          var e = this.limboTargetsByKey.get(t);\n          null !== e && (this.remoteStore.unlisten(e), this.limboTargetsByKey = this.limboTargetsByKey.remove(t), delete this.limboResolutionsByTarget[e]);\n        }, t.prototype.updateTrackedLimbos = function (t, e) {\n          for (var n = 0, r = e; n < r.length; n++) {\n            var i = r[n];\n            if (i instanceof ju) this.limboDocumentRefs.addReference(i.key, t), this.trackLimboChange(i);else if (i instanceof Gu) {\n              Ar(zu, \"Document no longer in limbo: \" + i.key), this.limboDocumentRefs.removeReference(i.key, t), this.limboDocumentRefs.containsKey(i.key) || this.removeLimboTarget(i.key);\n            } else Mr(\"Unknown limbo change: \" + JSON.stringify(i));\n          }\n        }, t.prototype.trackLimboChange = function (t) {\n          var e = t.key;\n\n          if (!this.limboTargetsByKey.get(e)) {\n            Ar(zu, \"New document in limbo: \" + e);\n            var n = this.limboTargetIdGenerator.next(),\n                r = pu.atPath(e.path);\n            this.limboResolutionsByTarget[n] = new Yu(e), this.remoteStore.listen(new ma(r, n, ha.LimboResolution, wi.INVALID)), this.limboTargetsByKey = this.limboTargetsByKey.insert(e, n);\n          }\n        }, t.prototype.currentLimboDocs = function () {\n          return this.limboTargetsByKey;\n        }, t.prototype.emitNewSnapsAndNotifyLocalStore = function (n, u) {\n          return h(this, void 0, void 0, function () {\n            var o,\n                a,\n                e,\n                s = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return o = [], a = [], e = [], this.queryViewsByQuery.forEach(function (t, i) {\n                    e.push(Promise.resolve().then(function () {\n                      var e = i.view.computeDocChanges(n);\n                      return e.needsRefill ? s.localStore.executeQuery(i.query).then(function (t) {\n                        return i.view.computeDocChanges(t, e);\n                      }) : e;\n                    }).then(function (t) {\n                      var e = u && u.targetChanges[i.targetId],\n                          n = i.view.applyChanges(t, !0 === s.isPrimary, e);\n\n                      if (s.updateTrackedLimbos(i.targetId, n.limboChanges), n.snapshot) {\n                        s.isPrimary && s.sharedClientState.updateQueryState(i.targetId, n.snapshot.fromCache ? \"not-current\" : \"current\"), o.push(n.snapshot);\n                        var r = Ku.fromSnapshot(i.targetId, n.snapshot);\n                        a.push(r);\n                      }\n                    }));\n                  }), [4, Promise.all(e)];\n\n                case 1:\n                  return t.sent(), this.syncEngineListener.onWatchChange(o), [4, this.localStore.notifyLocalViewChanges(a)];\n\n                case 2:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.assertSubscribed = function (t) {\n          Or(null !== this.syncEngineListener, \"Trying to call \" + t + \" before calling subscribe().\");\n        }, t.prototype.handleCredentialChange = function (r) {\n          return h(this, void 0, void 0, function () {\n            var e, n;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return e = !this.currentUser.isEqual(r), this.currentUser = r, e ? [4, this.localStore.handleUserChange(r)] : [3, 3];\n\n                case 1:\n                  return n = t.sent(), this.sharedClientState.handleUserChange(r, n.removedBatchIds, n.addedBatchIds), [4, this.emitNewSnapsAndNotifyLocalStore(n.affectedDocuments)];\n\n                case 2:\n                  t.sent(), t.label = 3;\n\n                case 3:\n                  return [4, this.remoteStore.handleCredentialChange()];\n\n                case 4:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        }, t.prototype.applyPrimaryState = function (c) {\n          return h(this, void 0, void 0, function () {\n            var e,\n                n,\n                r,\n                i,\n                o,\n                a,\n                s,\n                u = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return !0 !== c || !0 === this.isPrimary ? [3, 3] : (this.isPrimary = !0, [4, this.remoteStore.applyPrimaryState(!0)]);\n\n                case 1:\n                  return t.sent(), e = this.sharedClientState.getAllActiveQueryTargets(), [4, this.synchronizeQueryViewsAndRaiseSnapshots(e.toArray())];\n\n                case 2:\n                  for (n = t.sent(), r = 0, i = n; r < i.length; r++) o = i[r], this.remoteStore.listen(o);\n\n                  return [3, 7];\n\n                case 3:\n                  return !1 !== c || !1 === this.isPrimary ? [3, 7] : (this.isPrimary = !1, a = [], s = Promise.resolve(), Ur(this.queryViewsByTarget, function (t, e) {\n                    u.sharedClientState.isLocalQueryTarget(t) ? a.push(t) : s = s.then(function () {\n                      return u.unlisten(e.query);\n                    }), u.remoteStore.unlisten(e.targetId);\n                  }), [4, s]);\n\n                case 4:\n                  return t.sent(), [4, this.synchronizeQueryViewsAndRaiseSnapshots(a)];\n\n                case 5:\n                  return t.sent(), this.resetLimboDocuments(), [4, this.remoteStore.applyPrimaryState(!1)];\n\n                case 6:\n                  t.sent(), t.label = 7;\n\n                case 7:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.resetLimboDocuments = function () {\n          var e = this;\n          Ur(this.limboResolutionsByTarget, function (t) {\n            e.remoteStore.unlisten(t);\n          }), this.limboDocumentRefs.removeAllReferences(), this.limboResolutionsByTarget = [], this.limboTargetsByKey = new Ui(Di.comparator);\n        }, t.prototype.synchronizeQueryViewsAndRaiseSnapshots = function (t) {\n          for (var e = this, n = Promise.resolve(), a = [], s = [], r = function (o) {\n            n = n.then(function () {\n              return h(e, void 0, void 0, function () {\n                var e, n, r, i;\n                return p(this, function (t) {\n                  switch (t.label) {\n                    case 0:\n                      return (n = this.queryViewsByTarget[o]) ? [4, this.localStore.releaseQuery(n.query, !0)] : [3, 4];\n\n                    case 1:\n                      return t.sent(), [4, this.localStore.allocateQuery(n.query)];\n\n                    case 2:\n                      return e = t.sent(), [4, this.synchronizeViewAndComputeSnapshot(n)];\n\n                    case 3:\n                      return (r = t.sent()).snapshot && s.push(r.snapshot), [3, 8];\n\n                    case 4:\n                      return Or(!0 === this.isPrimary, \"A secondary tab should never have an active query without an active view.\"), [4, this.localStore.getQueryForTarget(o)];\n\n                    case 5:\n                      return Or(!!(i = t.sent()), \"Query data for target \" + o + \" not found\"), [4, this.localStore.allocateQuery(i)];\n\n                    case 6:\n                      return e = t.sent(), [4, this.initializeViewAndComputeSnapshot(e, !1)];\n\n                    case 7:\n                      t.sent(), t.label = 8;\n\n                    case 8:\n                      return a.push(e), [2];\n                  }\n                });\n              });\n            });\n          }, i = 0, o = t; i < o.length; i++) {\n            r(o[i]);\n          }\n\n          return n.then(function () {\n            return e.syncEngineListener.onWatchChange(s), a;\n          });\n        }, t.prototype.getActiveClients = function () {\n          return this.localStore.getActiveClients();\n        }, t.prototype.applyTargetState = function (r, o, n) {\n          return h(this, void 0, void 0, function () {\n            var e,\n                i = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  if (this.isPrimary) return Ar(zu, \"Ignoring unexpected query state notification.\"), [2];\n                  if (!this.queryViewsByTarget[r]) return [3, 5];\n\n                  switch (o) {\n                    case \"current\":\n                    case \"not-current\":\n                      return [3, 1];\n\n                    case \"rejected\":\n                      return [3, 2];\n                  }\n\n                  return [3, 4];\n\n                case 1:\n                  return [2, this.localStore.getNewDocumentChanges().then(function (n) {\n                    return h(i, void 0, void 0, function () {\n                      var e;\n                      return p(this, function (t) {\n                        switch (t.label) {\n                          case 0:\n                            return e = eu.createSynthesizedRemoteEventForCurrentChange(r, \"current\" === o), [4, this.emitNewSnapsAndNotifyLocalStore(n, e)];\n\n                          case 1:\n                            return t.sent(), [2];\n                        }\n                      });\n                    });\n                  }, function (r) {\n                    return h(i, void 0, void 0, function () {\n                      var n;\n                      return p(this, function (t) {\n                        switch (t.label) {\n                          case 0:\n                            return (e = r).code !== Lr.DATA_LOSS || e.message !== xo ? [3, 2] : (n = [], Ur(this.queryViewsByTarget, function (t) {\n                              return n.push(t);\n                            }), [4, this.synchronizeQueryViewsAndRaiseSnapshots(n)]);\n\n                          case 1:\n                            return t.sent(), [3, 3];\n\n                          case 2:\n                            throw r;\n\n                          case 3:\n                            return [2];\n                        }\n\n                        var e;\n                      });\n                    });\n                  })];\n\n                case 2:\n                  return e = this.queryViewsByTarget[r], this.removeAndCleanupQuery(e), [4, this.localStore.releaseQuery(e.query, !0)];\n\n                case 3:\n                  return t.sent(), this.syncEngineListener.onWatchError(e.query, n), [3, 5];\n\n                case 4:\n                  Mr(\"Unexpected target state: \" + o), t.label = 5;\n\n                case 5:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.applyActiveTargetsChange = function (l, f) {\n          return h(this, void 0, void 0, function () {\n            var e,\n                n,\n                r,\n                i,\n                o,\n                a,\n                s,\n                u,\n                c,\n                h = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  if (!this.isPrimary) return [2];\n                  e = 0, n = l, t.label = 1;\n\n                case 1:\n                  return e < n.length ? (c = n[e], Or(!this.queryViewsByTarget[c], \"Trying to add an already active target\"), [4, this.localStore.getQueryForTarget(c)]) : [3, 6];\n\n                case 2:\n                  return Or(!!(r = t.sent()), \"Query data for active target \" + c + \" not found\"), [4, this.localStore.allocateQuery(r)];\n\n                case 3:\n                  return i = t.sent(), [4, this.initializeViewAndComputeSnapshot(i, !1)];\n\n                case 4:\n                  t.sent(), this.remoteStore.listen(i), t.label = 5;\n\n                case 5:\n                  return e++, [3, 1];\n\n                case 6:\n                  o = function (e) {\n                    var n;\n                    return p(this, function (t) {\n                      switch (t.label) {\n                        case 0:\n                          return (n = a.queryViewsByTarget[e]) ? [4, a.localStore.releaseQuery(n.query, !1).then(function () {\n                            h.remoteStore.unlisten(e), h.removeAndCleanupQuery(n);\n                          }).catch(Aa)] : [3, 2];\n\n                        case 1:\n                          t.sent(), t.label = 2;\n\n                        case 2:\n                          return [2];\n                      }\n                    });\n                  }, a = this, s = 0, u = f, t.label = 7;\n\n                case 7:\n                  return s < u.length ? (c = u[s], [5, o(c)]) : [3, 10];\n\n                case 8:\n                  t.sent(), t.label = 9;\n\n                case 9:\n                  return s++, [3, 7];\n\n                case 10:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.enableNetwork = function () {\n          return this.localStore.setNetworkEnabled(!0), this.remoteStore.enableNetwork();\n        }, t.prototype.disableNetwork = function () {\n          return this.localStore.setNetworkEnabled(!1), this.remoteStore.disableNetwork();\n        }, t.prototype.getRemoteKeysForTarget = function (t) {\n          var e = this.limboResolutionsByTarget[t];\n          return e && e.receivedDocument ? to().add(e.key) : this.queryViewsByTarget[t] ? this.queryViewsByTarget[t].view.syncedDocuments : to();\n        }, t;\n      }(),\n          Ju = function () {\n        function t(t) {\n          this.uid = t;\n        }\n\n        return t.prototype.isAuthenticated = function () {\n          return null != this.uid;\n        }, t.prototype.toKey = function () {\n          return this.isAuthenticated() ? \"uid:\" + this.uid : \"anonymous-user\";\n        }, t.prototype.isEqual = function (t) {\n          return t.uid === this.uid;\n        }, t.UNAUTHENTICATED = new t(null), t.GOOGLE_CREDENTIALS = new t(\"google-credentials-uid\"), t.FIRST_PARTY = new t(\"first-party-uid\"), t;\n      }(),\n          $u = \"SharedClientState\",\n          Zu = \"firestore_clients\",\n          tc = \"firestore_mutations\",\n          ec = \"firestore_targets\",\n          nc = function () {\n        function a(t, e, n, r) {\n          this.user = t, this.batchId = e, this.state = n, Or(void 0 !== (this.error = r) == (\"rejected\" === n), \"MutationMetadata must contain an error iff state is 'rejected'\");\n        }\n\n        return a.fromWebStorageEntry = function (t, e, n) {\n          var r = JSON.parse(n),\n              i = \"object\" == typeof r && -1 !== [\"pending\", \"acknowledged\", \"rejected\"].indexOf(r.state) && (void 0 === r.error || \"object\" == typeof r.error),\n              o = void 0;\n          return i && r.error && (i = \"string\" == typeof r.error.message && \"string\" == typeof r.error.code) && (o = new xr(r.error.code, r.error.message)), i ? new a(t, e, r.state, o) : (kr($u, \"Failed to parse mutation state for ID '\" + e + \"': \" + n), null);\n        }, a.prototype.toWebStorageJSON = function () {\n          var t = {\n            state: this.state,\n            updateTimeMs: Date.now()\n          };\n          return this.error && (t.error = {\n            code: this.error.code,\n            message: this.error.message\n          }), JSON.stringify(t);\n        }, a;\n      }(),\n          rc = function () {\n        function o(t, e, n) {\n          this.targetId = t, this.state = e, Or(void 0 !== (this.error = n) == (\"rejected\" === e), \"QueryTargetMetadata must contain an error iff state is 'rejected'\");\n        }\n\n        return o.fromWebStorageEntry = function (t, e) {\n          var n = JSON.parse(e),\n              r = \"object\" == typeof n && -1 !== [\"not-current\", \"current\", \"rejected\"].indexOf(n.state) && (void 0 === n.error || \"object\" == typeof n.error),\n              i = void 0;\n          return r && n.error && (r = \"string\" == typeof n.error.message && \"string\" == typeof n.error.code) && (i = new xr(n.error.code, n.error.message)), r ? new o(t, n.state, i) : (kr($u, \"Failed to parse target state for ID '\" + t + \"': \" + e), null);\n        }, o.prototype.toWebStorageJSON = function () {\n          var t = {\n            state: this.state,\n            updateTimeMs: Date.now()\n          };\n          return this.error && (t.error = {\n            code: this.error.code,\n            message: this.error.message\n          }), JSON.stringify(t);\n        }, o;\n      }(),\n          ic = function () {\n        function a(t, e) {\n          this.clientId = t, this.activeTargetIds = e;\n        }\n\n        return a.fromWebStorageEntry = function (t, e) {\n          for (var n = JSON.parse(e), r = \"object\" == typeof n && n.activeTargetIds instanceof Array, i = no(), o = 0; r && o < n.activeTargetIds.length; ++o) r = Ns(n.activeTargetIds[o]), i = i.add(n.activeTargetIds[o]);\n\n          return r ? new a(t, i) : (kr($u, \"Failed to parse client data for instance '\" + t + \"': \" + e), null);\n        }, a;\n      }(),\n          oc = function () {\n        function n(t, e) {\n          this.clientId = t, this.onlineState = e;\n        }\n\n        return n.fromWebStorageEntry = function (t) {\n          var e = JSON.parse(t);\n          return \"object\" == typeof e && e.onlineState in Os && \"string\" == typeof e.clientId ? new n(e.clientId, Os[e.onlineState]) : (kr($u, \"Failed to parse online state: \" + t), null);\n        }, n;\n      }(),\n          ac = function () {\n        function t() {\n          this.activeTargetIds = no();\n        }\n\n        return t.prototype.addQueryTarget = function (t) {\n          Or(!this.activeTargetIds.has(t), \"Target with ID '\" + t + \"' already active.\"), this.activeTargetIds = this.activeTargetIds.add(t);\n        }, t.prototype.removeQueryTarget = function (t) {\n          this.activeTargetIds = this.activeTargetIds.delete(t);\n        }, t.prototype.toWebStorageJSON = function () {\n          var t = {\n            activeTargetIds: this.activeTargetIds.toArray(),\n            updateTimeMs: Date.now()\n          };\n          return JSON.stringify(t);\n        }, t;\n      }(),\n          sc = function () {\n        function a(t, e, n, r, i) {\n          if (this.queue = t, this.platform = e, this.persistenceKey = n, this.localClientId = r, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.activeClients = {}, this.storageListener = this.handleWebStorageEvent.bind(this), this.started = !1, this.earlyEvents = [], !a.isAvailable(this.platform)) throw new xr(Lr.UNIMPLEMENTED, \"LocalStorage is not available on this platform.\");\n          var o = n.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n          this.storage = this.platform.window.localStorage, this.currentUser = i, this.localClientStorageKey = this.toWebStorageClientStateKey(this.localClientId), this.sequenceNumberKey = \"firestore_sequence_number_\" + n, this.activeClients[this.localClientId] = new ac(), this.clientStateKeyRe = new RegExp(\"^\" + Zu + \"_\" + o + \"_([^_]*)$\"), this.mutationBatchKeyRe = new RegExp(\"^\" + tc + \"_\" + o + \"_(\\\\d+)(?:_(.*))?$\"), this.queryTargetKeyRe = new RegExp(\"^\" + ec + \"_\" + o + \"_(\\\\d+)$\"), this.onlineStateKey = \"firestore_online_state_\" + n, this.platform.window.addEventListener(\"storage\", this.storageListener);\n        }\n\n        return a.isAvailable = function (t) {\n          return !(!t.window || null == t.window.localStorage);\n        }, a.prototype.start = function () {\n          return h(this, void 0, void 0, function () {\n            var e,\n                n,\n                r,\n                i,\n                o,\n                a,\n                s,\n                u,\n                c,\n                h,\n                l,\n                f = this;\n            return p(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return Or(!this.started, \"WebStorageSharedClientState already started\"), Or(null !== this.syncEngine, \"syncEngine property must be set before calling start()\"), Or(null !== this.onlineStateHandler, \"onlineStateHandler property must be set before calling start()\"), [4, this.syncEngine.getActiveClients()];\n\n                case 1:\n                  for (e = t.sent(), n = 0, r = e; n < r.length; n++) (i = r[n]) !== this.localClientId && (o = this.getItem(this.toWebStorageClientStateKey(i))) && (a = ic.fromWebStorageEntry(i, o)) && (this.activeClients[a.clientId] = a);\n\n                  for (this.persistClientState(), (s = this.storage.getItem(this.onlineStateKey)) && (u = this.fromWebStorageOnlineState(s)) && this.handleOnlineStateEvent(u), c = 0, h = this.earlyEvents; c < h.length; c++) l = h[c], this.handleWebStorageEvent(l);\n\n                  return this.earlyEvents = [], this.platform.window.addEventListener(\"unload\", function () {\n                    return f.shutdown();\n                  }), this.started = !0, [2];\n              }\n            });\n          });\n        }, a.prototype.writeSequenceNumber = function (t) {\n          this.setItem(this.sequenceNumberKey, JSON.stringify(t));\n        }, a.prototype.getAllActiveQueryTargets = function () {\n          var n = no();\n          return Br(this.activeClients, function (t, e) {\n            n = n.unionWith(e.activeTargetIds);\n          }), n;\n        }, a.prototype.isActiveQueryTarget = function (t) {\n          for (var e in this.activeClients) if (this.activeClients.hasOwnProperty(e) && this.activeClients[e].activeTargetIds.has(t)) return !0;\n\n          return !1;\n        }, a.prototype.addPendingMutation = function (t) {\n          this.persistMutationState(t, \"pending\");\n        }, a.prototype.updateMutationState = function (t, e, n) {\n          this.persistMutationState(t, e, n), this.removeMutationState(t);\n        }, a.prototype.addLocalQueryTarget = function (t) {\n          var e = \"not-current\";\n\n          if (this.isActiveQueryTarget(t)) {\n            var n = this.storage.getItem(this.toWebStorageQueryTargetMetadataKey(t));\n\n            if (n) {\n              var r = rc.fromWebStorageEntry(t, n);\n              r && (e = r.state);\n            }\n          }\n\n          return this.localClientState.addQueryTarget(t), this.persistClientState(), e;\n        }, a.prototype.removeLocalQueryTarget = function (t) {\n          this.localClientState.removeQueryTarget(t), this.persistClientState();\n        }, a.prototype.isLocalQueryTarget = function (t) {\n          return this.localClientState.activeTargetIds.has(t);\n        }, a.prototype.clearQueryState = function (t) {\n          this.removeItem(this.toWebStorageQueryTargetMetadataKey(t));\n        }, a.prototype.updateQueryState = function (t, e, n) {\n          this.persistQueryTargetState(t, e, n);\n        }, a.prototype.handleUserChange = function (t, e, n) {\n          var r = this;\n          e.forEach(function (t) {\n            r.removeMutationState(t);\n          }), this.currentUser = t, n.forEach(function (t) {\n            r.addPendingMutation(t);\n          });\n        }, a.prototype.setOnlineState = function (t) {\n          this.persistOnlineState(t);\n        }, a.prototype.shutdown = function () {\n          this.started && (this.platform.window.removeEventListener(\"storage\", this.storageListener), this.removeItem(this.localClientStorageKey), this.started = !1);\n        }, a.prototype.getItem = function (t) {\n          var e = this.storage.getItem(t);\n          return Ar($u, \"READ\", t, e), e;\n        }, a.prototype.setItem = function (t, e) {\n          Ar($u, \"SET\", t, e), this.storage.setItem(t, e);\n        }, a.prototype.removeItem = function (t) {\n          Ar($u, \"REMOVE\", t), this.storage.removeItem(t);\n        }, a.prototype.handleWebStorageEvent = function (s) {\n          var t = this;\n\n          if (s.storageArea === this.storage) {\n            if (Ar($u, \"EVENT\", s.key, s.newValue), s.key === this.localClientStorageKey) return void kr(\"Received WebStorage notification for local change. Another client might have garbage-collected our state\");\n            this.queue.enqueueAndForget(function () {\n              return h(t, void 0, void 0, function () {\n                var e, n, r, i, o, a;\n                return p(this, function (t) {\n                  if (!this.started) return this.earlyEvents.push(s), [2];\n                  if (null === s.key) return [2];\n\n                  if (this.clientStateKeyRe.test(s.key)) {\n                    if (null == s.newValue) return n = this.fromWebStorageClientStateKey(s.key), [2, this.handleClientStateEvent(n, null)];\n                    if (e = this.fromWebStorageClientState(s.key, s.newValue)) return [2, this.handleClientStateEvent(e.clientId, e)];\n                  } else if (this.mutationBatchKeyRe.test(s.key)) {\n                    if (null !== s.newValue && (r = this.fromWebStorageMutationMetadata(s.key, s.newValue))) return [2, this.handleMutationBatchEvent(r)];\n                  } else if (this.queryTargetKeyRe.test(s.key)) {\n                    if (null !== s.newValue && (i = this.fromWebStorageQueryTargetMetadata(s.key, s.newValue))) return [2, this.handleQueryTargetEvent(i)];\n                  } else if (s.key === this.onlineStateKey) {\n                    if (null !== s.newValue && (o = this.fromWebStorageOnlineState(s.newValue))) return [2, this.handleOnlineStateEvent(o)];\n                  } else s.key === this.sequenceNumberKey && (Or(!!this.sequenceNumberHandler, \"Missing sequenceNumberHandler\"), (a = function (t) {\n                    var e = wi.INVALID;\n                    if (null != t) try {\n                      var n = JSON.parse(t);\n                      Or(\"number\" == typeof n, \"Found non-numeric sequence number\"), e = n;\n                    } catch (t) {\n                      kr($u, \"Failed to read sequence number from WebStorage\", t);\n                    }\n                    return e;\n                  }(s.newValue)) !== wi.INVALID && this.sequenceNumberHandler(a));\n\n                  return [2];\n                });\n              });\n            });\n          }\n        }, Object.defineProperty(a.prototype, \"localClientState\", {\n          get: function () {\n            return this.activeClients[this.localClientId];\n          },\n          enumerable: !0,\n          configurable: !0\n        }), a.prototype.persistClientState = function () {\n          this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\n        }, a.prototype.persistMutationState = function (t, e, n) {\n          var r = new nc(this.currentUser, t, e, n),\n              i = this.toWebStorageMutationBatchKey(t);\n          this.setItem(i, r.toWebStorageJSON());\n        }, a.prototype.removeMutationState = function (t) {\n          var e = this.toWebStorageMutationBatchKey(t);\n          this.removeItem(e);\n        }, a.prototype.persistOnlineState = function (t) {\n          var e = {\n            clientId: this.localClientId,\n            onlineState: Os[t]\n          };\n          this.storage.setItem(this.onlineStateKey, JSON.stringify(e));\n        }, a.prototype.persistQueryTargetState = function (t, e, n) {\n          var r = this.toWebStorageQueryTargetMetadataKey(t),\n              i = new rc(t, e, n);\n          this.setItem(r, i.toWebStorageJSON());\n        }, a.prototype.toWebStorageClientStateKey = function (t) {\n          return Or(-1 === t.indexOf(\"_\"), \"Client key cannot contain '_', but was '\" + t + \"'\"), Zu + \"_\" + this.persistenceKey + \"_\" + t;\n        }, a.prototype.toWebStorageQueryTargetMetadataKey = function (t) {\n          return ec + \"_\" + this.persistenceKey + \"_\" + t;\n        }, a.prototype.toWebStorageMutationBatchKey = function (t) {\n          var e = tc + \"_\" + this.persistenceKey + \"_\" + t;\n          return this.currentUser.isAuthenticated() && (e += \"_\" + this.currentUser.uid), e;\n        }, a.prototype.fromWebStorageClientStateKey = function (t) {\n          var e = this.clientStateKeyRe.exec(t);\n          return e ? e[1] : null;\n        }, a.prototype.fromWebStorageClientState = function (t, e) {\n          var n = this.fromWebStorageClientStateKey(t);\n          return Or(null !== n, \"Cannot parse client state key '\" + t + \"'\"), ic.fromWebStorageEntry(n, e);\n        }, a.prototype.fromWebStorageMutationMetadata = function (t, e) {\n          var n = this.mutationBatchKeyRe.exec(t);\n          Or(null !== n, \"Cannot parse mutation batch key '\" + t + \"'\");\n          var r = Number(n[1]),\n              i = void 0 !== n[2] ? n[2] : null;\n          return nc.fromWebStorageEntry(new Ju(i), r, e);\n        }, a.prototype.fromWebStorageQueryTargetMetadata = function (t, e) {\n          var n = this.queryTargetKeyRe.exec(t);\n          Or(null !== n, \"Cannot parse query target key '\" + t + \"'\");\n          var r = Number(n[1]);\n          return rc.fromWebStorageEntry(r, e);\n        }, a.prototype.fromWebStorageOnlineState = function (t) {\n          return oc.fromWebStorageEntry(t);\n        }, a.prototype.handleMutationBatchEvent = function (e) {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return e.user.uid !== this.currentUser.uid ? (Ar($u, \"Ignoring mutation for non-active user \" + e.user.uid), [2]) : [2, this.syncEngine.applyBatchState(e.batchId, e.state, e.error)];\n            });\n          });\n        }, a.prototype.handleQueryTargetEvent = function (t) {\n          return this.syncEngine.applyTargetState(t.targetId, t.state, t.error);\n        }, a.prototype.handleClientStateEvent = function (t, e) {\n          var n = this,\n              r = this.getAllActiveQueryTargets();\n          e ? this.activeClients[t] = e : delete this.activeClients[t];\n          var i = this.getAllActiveQueryTargets(),\n              o = [],\n              a = [];\n          return i.forEach(function (e) {\n            return h(n, void 0, void 0, function () {\n              return p(this, function (t) {\n                return r.has(e) || o.push(e), [2];\n              });\n            });\n          }), r.forEach(function (e) {\n            return h(n, void 0, void 0, function () {\n              return p(this, function (t) {\n                return i.has(e) || a.push(e), [2];\n              });\n            });\n          }), this.syncEngine.applyActiveTargetsChange(o, a);\n        }, a.prototype.handleOnlineStateEvent = function (t) {\n          this.activeClients[t.clientId] && this.onlineStateHandler(t.onlineState);\n        }, a;\n      }();\n\n      var uc = function () {\n        function t() {\n          this.localState = new ac(), this.queryState = {}, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null;\n        }\n\n        return t.prototype.addPendingMutation = function (t) {}, t.prototype.updateMutationState = function (t, e, n) {}, t.prototype.addLocalQueryTarget = function (t) {\n          return this.localState.addQueryTarget(t), this.queryState[t] || \"not-current\";\n        }, t.prototype.updateQueryState = function (t, e, n) {\n          this.queryState[t] = e;\n        }, t.prototype.removeLocalQueryTarget = function (t) {\n          this.localState.removeQueryTarget(t);\n        }, t.prototype.isLocalQueryTarget = function (t) {\n          return this.localState.activeTargetIds.has(t);\n        }, t.prototype.clearQueryState = function (t) {\n          delete this.queryState[t];\n        }, t.prototype.getAllActiveQueryTargets = function () {\n          return this.localState.activeTargetIds;\n        }, t.prototype.isActiveQueryTarget = function (t) {\n          return this.localState.activeTargetIds.has(t);\n        }, t.prototype.start = function () {\n          return this.localState = new ac(), Promise.resolve();\n        }, t.prototype.handleUserChange = function (t, e, n) {}, t.prototype.setOnlineState = function (t) {}, t.prototype.shutdown = function () {}, t.prototype.writeSequenceNumber = function (t) {}, t;\n      }(),\n          cc = \"FirestoreClient\",\n          hc = function () {\n        function t(t, e) {\n          this.cacheSizeBytes = t, this.synchronizeTabs = e;\n        }\n\n        return t.prototype.lruParams = function () {\n          return wa.withCacheSize(this.cacheSizeBytes);\n        }, t;\n      }(),\n          lc = function () {},\n          fc = function () {\n        function t(t, e, n, r) {\n          this.platform = t, this.databaseInfo = e, this.credentials = n, this.asyncQueue = r, this.clientId = si.newId(), this._clientShutdown = !1;\n        }\n\n        return t.prototype.start = function (t) {\n          var n = this;\n          this.verifyNotShutdown();\n          var r = new Ni(),\n              i = new Ni(),\n              o = !1;\n          return this.credentials.setChangeListener(function (e) {\n            o ? n.asyncQueue.enqueueAndForget(function () {\n              return n.handleCredentialChange(e);\n            }) : (o = !0, n.initializePersistence(t, i, e).then(function (t) {\n              return n.initializeRest(e, t);\n            }).then(r.resolve, r.reject));\n          }), this.asyncQueue.enqueueAndForget(function () {\n            return r.promise;\n          }), i.promise;\n        }, t.prototype.enableNetwork = function () {\n          var t = this;\n          return this.verifyNotShutdown(), this.asyncQueue.enqueue(function () {\n            return t.syncEngine.enableNetwork();\n          });\n        }, t.prototype.initializePersistence = function (t, e, n) {\n          var r = this;\n          return t instanceof hc ? this.startIndexedDbPersistence(n, t).then(function (t) {\n            return e.resolve(), t;\n          }).catch(function (t) {\n            if (e.reject(t), !r.canFallback(t)) throw t;\n            return console.warn(\"Error enabling offline persistence. Falling back to persistence disabled: \" + t), r.startMemoryPersistence();\n          }) : (e.resolve(), this.startMemoryPersistence());\n        }, t.prototype.canFallback = function (t) {\n          return t instanceof xr ? t.code === Lr.FAILED_PRECONDITION || t.code === Lr.UNIMPLEMENTED : !(\"undefined\" != typeof DOMException && t instanceof DOMException) || 22 === t.code || 20 === t.code || 11 === t.code;\n        }, t.prototype.verifyNotShutdown = function () {\n          if (this._clientShutdown) throw new xr(Lr.FAILED_PRECONDITION, \"The client has already been shutdown.\");\n        }, t.prototype.startIndexedDbPersistence = function (r, i) {\n          var t = this,\n              o = Na.buildStoragePrefix(this.databaseInfo),\n              a = new Vu(this.databaseInfo.databaseId, {\n            useProto3Json: !0\n          });\n          return Promise.resolve().then(function () {\n            return h(t, void 0, void 0, function () {\n              var e, n;\n              return p(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    if (i.synchronizeTabs && !sc.isAvailable(this.platform)) throw new xr(Lr.UNIMPLEMENTED, \"IndexedDB persistence is only available on platforms that support LocalStorage.\");\n                    return n = i.lruParams(), i.synchronizeTabs ? (this.sharedClientState = new sc(this.asyncQueue, this.platform, o, this.clientId, r), [4, Na.createMultiClientIndexedDbPersistence(o, this.clientId, this.platform, this.asyncQueue, a, n, {\n                      sequenceNumberSyncer: this.sharedClientState\n                    })]) : [3, 2];\n\n                  case 1:\n                    return e = t.sent(), [3, 4];\n\n                  case 2:\n                    return this.sharedClientState = new uc(), [4, Na.createIndexedDbPersistence(o, this.clientId, this.platform, this.asyncQueue, a, n)];\n\n                  case 3:\n                    e = t.sent(), t.label = 4;\n\n                  case 4:\n                    return [2, (this.persistence = e).referenceDelegate.garbageCollector];\n                }\n              });\n            });\n          });\n        }, t.prototype.startMemoryPersistence = function () {\n          return this.persistence = vs.createEagerPersistence(this.clientId), this.sharedClientState = new uc(), Promise.resolve(null);\n        }, t.prototype.initializeRest = function (u, c) {\n          var t = this;\n          return Ar(cc, \"Initializing. user=\", u.uid), this.platform.loadConnection(this.databaseInfo).then(function (s) {\n            return h(t, void 0, void 0, function () {\n              var e,\n                  n,\n                  r,\n                  i,\n                  o,\n                  a = this;\n              return p(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    return this.localStore = new ps(this.persistence, u), c && (this.lruScheduler = new Ea(c, this.asyncQueue, this.localStore)), e = this.platform.newConnectivityMonitor(), n = this.platform.newSerializer(this.databaseInfo.databaseId), r = new Vs(this.asyncQueue, s, this.credentials, n), i = function (t) {\n                      return a.syncEngine.applyOnlineStateChange(t, Ps.RemoteStore);\n                    }, o = function (t) {\n                      return a.syncEngine.applyOnlineStateChange(t, Ps.SharedClientState);\n                    }, this.remoteStore = new lu(this.localStore, r, this.asyncQueue, i, e), this.syncEngine = new Xu(this.localStore, this.remoteStore, this.sharedClientState, u), this.sharedClientState.onlineStateHandler = o, this.remoteStore.syncEngine = this.syncEngine, this.sharedClientState.syncEngine = this.syncEngine, this.eventMgr = new Bu(this.syncEngine), [4, this.sharedClientState.start()];\n\n                  case 1:\n                    return t.sent(), [4, this.remoteStore.start()];\n\n                  case 2:\n                    return t.sent(), [4, this.persistence.setPrimaryStateListener(function (e) {\n                      return h(a, void 0, void 0, function () {\n                        return p(this, function (t) {\n                          switch (t.label) {\n                            case 0:\n                              return [4, this.syncEngine.applyPrimaryState(e)];\n\n                            case 1:\n                              return t.sent(), this.lruScheduler && (e && !this.lruScheduler.started ? this.lruScheduler.start() : e || this.lruScheduler.stop()), [2];\n                          }\n                        });\n                      });\n                    })];\n\n                  case 3:\n                    return t.sent(), [4, this.persistence.setDatabaseDeletedListener(function () {\n                      return h(a, void 0, void 0, function () {\n                        return p(this, function (t) {\n                          switch (t.label) {\n                            case 0:\n                              return [4, this.shutdown()];\n\n                            case 1:\n                              return t.sent(), [2];\n                          }\n                        });\n                      });\n                    })];\n\n                  case 4:\n                    return t.sent(), [2];\n                }\n              });\n            });\n          });\n        }, t.prototype.handleCredentialChange = function (t) {\n          return this.asyncQueue.verifyOperationInProgress(), Ar(cc, \"Credential Changed. Current user: \" + t.uid), this.syncEngine.handleCredentialChange(t);\n        }, t.prototype.disableNetwork = function () {\n          var t = this;\n          return this.verifyNotShutdown(), this.asyncQueue.enqueue(function () {\n            return t.syncEngine.disableNetwork();\n          });\n        }, t.prototype.shutdown = function () {\n          var t = this;\n          return this.asyncQueue.enqueue(function () {\n            return h(t, void 0, void 0, function () {\n              return p(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    return this._clientShutdown ? [3, 4] : (this.lruScheduler && this.lruScheduler.stop(), [4, this.remoteStore.shutdown()]);\n\n                  case 1:\n                    return t.sent(), [4, this.sharedClientState.shutdown()];\n\n                  case 2:\n                    return t.sent(), [4, this.persistence.shutdown()];\n\n                  case 3:\n                    t.sent(), this.credentials.removeChangeListener(), this._clientShutdown = !0, t.label = 4;\n\n                  case 4:\n                    return [2];\n                }\n              });\n            });\n          });\n        }, t.prototype.listen = function (t, e, n) {\n          var r = this;\n          this.verifyNotShutdown();\n          var i = new Qu(t, e, n);\n          return this.asyncQueue.enqueueAndForget(function () {\n            return r.eventMgr.listen(i);\n          }), i;\n        }, t.prototype.unlisten = function (t) {\n          var e = this;\n          this.verifyNotShutdown(), this.asyncQueue.enqueueAndForget(function () {\n            return e.eventMgr.unlisten(t);\n          });\n        }, t.prototype.getDocumentFromLocalCache = function (t) {\n          var e = this;\n          return this.verifyNotShutdown(), this.asyncQueue.enqueue(function () {\n            return e.localStore.readDocument(t);\n          }).then(function (t) {\n            if (t instanceof Mo) return t;\n            if (t instanceof Oo) return null;\n            throw new xr(Lr.UNAVAILABLE, \"Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)\");\n          });\n        }, t.prototype.getDocumentsFromLocalCache = function (i) {\n          var t = this;\n          return this.verifyNotShutdown(), this.asyncQueue.enqueue(function () {\n            return t.localStore.executeQuery(i);\n          }).then(function (t) {\n            var e = to(),\n                n = new Wu(i, e),\n                r = n.computeDocChanges(t);\n            return n.applyChanges(r, !1).snapshot;\n          });\n        }, t.prototype.write = function (t) {\n          var e = this;\n          this.verifyNotShutdown();\n          var n = new Ni();\n          return this.asyncQueue.enqueueAndForget(function () {\n            return e.syncEngine.write(t, n);\n          }), n.promise;\n        }, t.prototype.databaseId = function () {\n          return this.databaseInfo.databaseId;\n        }, Object.defineProperty(t.prototype, \"clientShutdown\", {\n          get: function () {\n            return this._clientShutdown;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.transaction = function (t) {\n          var e = this;\n          return this.verifyNotShutdown(), this.asyncQueue.enqueue(function () {\n            return h(e, void 0, void 0, function () {\n              return p(this, function (t) {\n                return [2];\n              });\n            });\n          }).then(function () {\n            return e.syncEngine.runTransaction(t);\n          });\n        }, t;\n      }(),\n          pc = function () {\n        function t(t) {\n          this.observer = t, this.muted = !1;\n        }\n\n        return t.prototype.next = function (t) {\n          this.scheduleEvent(this.observer.next, t);\n        }, t.prototype.error = function (t) {\n          this.scheduleEvent(this.observer.error, t);\n        }, t.prototype.mute = function () {\n          this.muted = !0;\n        }, t.prototype.scheduleEvent = function (t, e) {\n          var n = this;\n          this.muted || setTimeout(function () {\n            n.muted || t(e);\n          }, 0);\n        }, t;\n      }(),\n          dc = function () {\n        function e() {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          !function (t, e, n, r) {\n            if (!(e instanceof Array) || e.length < r) throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + n + \" argument to be an array with at least \" + ai(r, \"element\") + \".\");\n          }(\"FieldPath\", t, \"fieldNames\", 1);\n\n          for (var n = 0; n < t.length; ++n) if (zr(\"FieldPath\", \"string\", n, t[n]), 0 === t[n].length) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid field name at argument $(i + 1). Field names must not be empty.\");\n\n          this._internalPath = new Ci(t);\n        }\n\n        return e.documentId = function () {\n          return e._DOCUMENT_ID;\n        }, e.prototype.isEqual = function (t) {\n          if (!(t instanceof e)) throw ii(\"isEqual\", \"FieldPath\", 1, t);\n          return this._internalPath.isEqual(t._internalPath);\n        }, e._DOCUMENT_ID = new e(Ci.keyField().canonicalString()), e;\n      }(),\n          mc = new RegExp(\"[~\\\\*/\\\\[\\\\]]\");\n\n      var yc = function (t, e) {\n        this.user = e, this.type = \"OAuth\", this.authHeaders = {\n          Authorization: \"Bearer \" + t\n        };\n      },\n          gc = function () {\n        function t() {\n          this.changeListener = null;\n        }\n\n        return t.prototype.getToken = function () {\n          return Promise.resolve(null);\n        }, t.prototype.invalidateToken = function () {}, t.prototype.setChangeListener = function (t) {\n          Or(!this.changeListener, \"Can only call setChangeListener() once.\"), (this.changeListener = t)(Ju.UNAUTHENTICATED);\n        }, t.prototype.removeChangeListener = function () {\n          Or(null !== this.changeListener, \"removeChangeListener() when no listener registered\"), this.changeListener = null;\n        }, t;\n      }(),\n          vc = function () {\n        function t(t) {\n          var e = this;\n          this.app = t, this.tokenListener = null, this.tokenCounter = 0, this.changeListener = null, this.forceRefresh = !1, this.tokenListener = function () {\n            e.tokenCounter++, e.currentUser = e.getUser(), e.changeListener && e.changeListener(e.currentUser);\n          }, this.tokenCounter = 0, this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n        }\n\n        return t.prototype.getToken = function () {\n          var e = this;\n          Or(null != this.tokenListener, \"getToken cannot be called after listener removed.\");\n          var n = this.tokenCounter,\n              t = this.forceRefresh;\n          return this.forceRefresh = !1, this.app.INTERNAL.getToken(t).then(function (t) {\n            if (e.tokenCounter !== n) throw new xr(Lr.ABORTED, \"getToken aborted due to token change.\");\n            return t ? (Or(\"string\" == typeof t.accessToken, \"Invalid tokenData returned from getToken():\" + t), new yc(t.accessToken, e.currentUser)) : null;\n          });\n        }, t.prototype.invalidateToken = function () {\n          this.forceRefresh = !0;\n        }, t.prototype.setChangeListener = function (t) {\n          Or(!this.changeListener, \"Can only call setChangeListener() once.\"), this.changeListener = t, this.currentUser && t(this.currentUser);\n        }, t.prototype.removeChangeListener = function () {\n          Or(null != this.tokenListener, \"removeChangeListener() called twice\"), Or(null !== this.changeListener, \"removeChangeListener() called when no listener registered\"), this.app.INTERNAL.removeAuthTokenListener(this.tokenListener), this.tokenListener = null, this.changeListener = null;\n        }, t.prototype.getUser = function () {\n          var t = this.app.INTERNAL.getUid();\n          return Or(null === t || \"string\" == typeof t, \"Received invalid UID: \" + t), new Ju(t);\n        }, t;\n      }(),\n          bc = function () {\n        function t(t, e) {\n          this.gapi = t, this.sessionIndex = e, this.type = \"FirstParty\", this.user = Ju.FIRST_PARTY;\n        }\n\n        return Object.defineProperty(t.prototype, \"authHeaders\", {\n          get: function () {\n            var t = {\n              \"X-Goog-AuthUser\": this.sessionIndex\n            },\n                e = this.gapi.auth.getAuthHeaderValueForFirstParty([]);\n            return e && (t.Authorization = e), t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t;\n      }(),\n          wc = function () {\n        function t(t, e) {\n          this.gapi = t, this.sessionIndex = e;\n        }\n\n        return t.prototype.getToken = function () {\n          return Promise.resolve(new bc(this.gapi, this.sessionIndex));\n        }, t.prototype.setChangeListener = function (t) {\n          t(Ju.FIRST_PARTY);\n        }, t.prototype.removeChangeListener = function () {}, t.prototype.invalidateToken = function () {}, t;\n      }();\n\n      function Ec(t) {\n        return function (t, e) {\n          if (\"object\" != typeof t || null === t) return !1;\n\n          for (var n = t, r = 0, i = e; r < i.length; r++) {\n            var o = i[r];\n            if (o in n && \"function\" == typeof n[o]) return !0;\n          }\n\n          return !1;\n        }(t, [\"next\", \"error\", \"complete\"]);\n      }\n\n      var Sc,\n          Tc,\n          Ic = function () {\n        function t(t) {\n          this._methodName = t;\n        }\n\n        return t.delete = function () {\n          return Kr(\"FieldValue.delete\", arguments), Cc.instance;\n        }, t.serverTimestamp = function () {\n          return Kr(\"FieldValue.serverTimestamp\", arguments), Dc.instance;\n        }, t.arrayUnion = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          return Gr(\"FieldValue.arrayUnion\", arguments, 1), new Nc(t);\n        }, t.arrayRemove = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          return Gr(\"FieldValue.arrayRemove\", arguments, 1), new Ac(t);\n        }, t.increment = function (t) {\n          return zr(\"FieldValue.increment\", \"number\", 1, t), jr(\"FieldValue.increment\", arguments, 1), new kc(t);\n        }, t.prototype.isEqual = function (t) {\n          return this === t;\n        }, t;\n      }(),\n          Cc = function (t) {\n        function e() {\n          return t.call(this, \"FieldValue.delete\") || this;\n        }\n\n        return s(e, t), e.instance = new e(), e;\n      }(Ic),\n          Dc = function (t) {\n        function e() {\n          return t.call(this, \"FieldValue.serverTimestamp\") || this;\n        }\n\n        return s(e, t), e.instance = new e(), e;\n      }(Ic),\n          Nc = function (n) {\n        function t(t) {\n          var e = n.call(this, \"FieldValue.arrayUnion\") || this;\n          return e._elements = t, e;\n        }\n\n        return s(t, n), t;\n      }(Ic),\n          Ac = function (n) {\n        function t(t) {\n          var e = n.call(this, \"FieldValue.arrayRemove\") || this;\n          return e._elements = t, e;\n        }\n\n        return s(t, n), t;\n      }(Ic),\n          kc = function (n) {\n        function t(t) {\n          var e = n.call(this, \"FieldValue.increment\") || this;\n          return e._operand = t, e;\n        }\n\n        return s(t, n), t;\n      }(Ic),\n          Rc = qr(Ic, \"Use FieldValue.<field>() instead.\"),\n          Mc = /^__.*__$/,\n          Oc = function () {\n        function t(t, e, n) {\n          this.data = t, this.fieldMask = e, this.fieldTransforms = n;\n        }\n\n        return t.prototype.toMutations = function (t, e) {\n          var n = [];\n          return null !== this.fieldMask ? n.push(new ss(t, this.data, this.fieldMask, e)) : n.push(new as(t, this.data, e)), 0 < this.fieldTransforms.length && n.push(new us(t, this.fieldTransforms)), n;\n        }, t;\n      }(),\n          _c = function () {\n        function t(t, e, n) {\n          this.data = t, this.fieldMask = e, this.fieldTransforms = n;\n        }\n\n        return t.prototype.toMutations = function (t, e) {\n          var n = [new ss(t, this.data, this.fieldMask, e)];\n          return 0 < this.fieldTransforms.length && n.push(new us(t, this.fieldTransforms)), n;\n        }, t;\n      }();\n\n      function Pc(t) {\n        switch (t) {\n          case Sc.Set:\n          case Sc.MergeSet:\n          case Sc.Update:\n            return !0;\n\n          case Sc.Argument:\n            return !1;\n\n          default:\n            throw Mr(\"Unexpected case for UserDataSource: \" + t);\n        }\n      }\n\n      (Tc = Sc || (Sc = {}))[Tc.Set = 0] = \"Set\", Tc[Tc.Update = 1] = \"Update\", Tc[Tc.MergeSet = 2] = \"MergeSet\", Tc[Tc.Argument = 3] = \"Argument\";\n\n      var Lc = function () {\n        function r(t, e, n, r, i, o) {\n          this.dataSource = t, this.methodName = e, this.path = n, this.arrayElement = r, void 0 === i && this.validatePath(), this.arrayElement = void 0 !== r && r, this.fieldTransforms = i || [], this.fieldMask = o || [];\n        }\n\n        return r.prototype.childContextForField = function (t) {\n          var e = null == this.path ? null : this.path.child(t),\n              n = new r(this.dataSource, this.methodName, e, !1, this.fieldTransforms, this.fieldMask);\n          return n.validatePathSegment(t), n;\n        }, r.prototype.childContextForFieldPath = function (t) {\n          var e = null == this.path ? null : this.path.child(t),\n              n = new r(this.dataSource, this.methodName, e, !1, this.fieldTransforms, this.fieldMask);\n          return n.validatePath(), n;\n        }, r.prototype.childContextForArray = function (t) {\n          return new r(this.dataSource, this.methodName, null, !0, this.fieldTransforms, this.fieldMask);\n        }, r.prototype.createError = function (t) {\n          var e = null === this.path || this.path.isEmpty() ? \"\" : \" (found in field \" + this.path.toString() + \")\";\n          return new xr(Lr.INVALID_ARGUMENT, \"Function \" + this.methodName + \"() called with invalid data. \" + t + e);\n        }, r.prototype.contains = function (e) {\n          return void 0 !== this.fieldMask.find(function (t) {\n            return e.isPrefixOf(t);\n          }) || void 0 !== this.fieldTransforms.find(function (t) {\n            return e.isPrefixOf(t.field);\n          });\n        }, r.prototype.validatePath = function () {\n          if (null !== this.path) for (var t = 0; t < this.path.length; t++) this.validatePathSegment(this.path.get(t));\n        }, r.prototype.validatePathSegment = function (t) {\n          if (Pc(this.dataSource) && Mc.test(t)) throw this.createError(\"Document fields cannot begin and end with __\");\n        }, r;\n      }(),\n          xc = function (t, e) {\n        this.databaseId = t, this.key = e;\n      },\n          qc = function () {\n        function t(t) {\n          this.preConverter = t;\n        }\n\n        return t.prototype.parseSetData = function (t, e) {\n          var n = new Lc(Sc.Set, t, Ci.EMPTY_PATH);\n          Vc(\"Data must be an object, but it was:\", n, e);\n          var r = this.parseData(e, n);\n          return new Oc(r, null, n.fieldTransforms);\n        }, t.prototype.parseMergeData = function (t, e, n) {\n          var r = new Lc(Sc.MergeSet, t, Ci.EMPTY_PATH);\n          Vc(\"Data must be an object, but it was:\", r, e);\n          var i,\n              o,\n              a = this.parseData(e, r);\n\n          if (n) {\n            for (var s = new ji(Ci.comparator), u = 0, c = n; u < c.length; u++) {\n              var h = c[u],\n                  l = void 0;\n              if (h instanceof dc) l = h._internalPath;else {\n                if (\"string\" != typeof h) throw Mr(\"Expected stringOrFieldPath to be a string or a FieldPath\");\n                l = Bc(t, h);\n              }\n              if (!r.contains(l)) throw new xr(Lr.INVALID_ARGUMENT, \"Field '\" + l + \"' is specified in your field mask but missing from your input data.\");\n              s = s.add(l);\n            }\n\n            i = es.fromSet(s), o = r.fieldTransforms.filter(function (t) {\n              return i.covers(t.field);\n            });\n          } else i = es.fromArray(r.fieldMask), o = r.fieldTransforms;\n\n          return new Oc(a, i, o);\n        }, t.prototype.parseUpdateData = function (o, t) {\n          var a = this,\n              s = new Lc(Sc.Update, o, Ci.EMPTY_PATH);\n          Vc(\"Data must be an object, but it was:\", s, t);\n          var u = new ji(Ci.comparator),\n              c = Za.EMPTY;\n          Br(t, function (t, e) {\n            var n = Bc(o, t),\n                r = s.childContextForFieldPath(n);\n            if ((e = a.runPreConverter(e, r)) instanceof Cc) u = u.add(n);else {\n              var i = a.parseData(e, r);\n              null != i && (u = u.add(n), c = c.set(n, i));\n            }\n          });\n          var e = es.fromSet(u);\n          return new _c(c, e, s.fieldTransforms);\n        }, t.prototype.parseUpdateVarargs = function (t, e, n, r) {\n          var i = new Lc(Sc.Update, t, Ci.EMPTY_PATH),\n              o = [Uc(t, e)],\n              a = [n];\n          if (r.length % 2 != 0) throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() needs to be called with an even number of arguments that alternate between field names and values.\");\n\n          for (var s = 0; s < r.length; s += 2) o.push(Uc(t, r[s])), a.push(r[s + 1]);\n\n          var u = new ji(Ci.comparator),\n              c = Za.EMPTY;\n\n          for (s = 0; s < o.length; ++s) {\n            var h = o[s],\n                l = i.childContextForFieldPath(h),\n                f = this.runPreConverter(a[s], l);\n            if (f instanceof Cc) u = u.add(h);else {\n              var p = this.parseData(f, l);\n              null != p && (u = u.add(h), c = c.set(h, p));\n            }\n          }\n\n          var d = es.fromSet(u);\n          return new _c(c, d, i.fieldTransforms);\n        }, t.prototype.parseQueryValue = function (t, e) {\n          var n = new Lc(Sc.Argument, t, Ci.EMPTY_PATH),\n              r = this.parseData(e, n);\n          return Or(null != r, \"Parsed data should not be null.\"), Or(0 === n.fieldTransforms.length, \"Field transforms should have been disallowed.\"), r;\n        }, t.prototype.runPreConverter = function (t, e) {\n          try {\n            return this.preConverter(t);\n          } catch (t) {\n            var n = Qc(t);\n            throw e.createError(n);\n          }\n        }, t.prototype.parseData = function (t, e) {\n          if (Fc(t = this.runPreConverter(t, e))) return Vc(\"Unsupported field value:\", e, t), this.parseObject(t, e);\n          if (t instanceof Ic) return this.parseSentinelFieldValue(t, e), null;\n\n          if (e.path && e.fieldMask.push(e.path), t instanceof Array) {\n            if (e.arrayElement) throw e.createError(\"Nested arrays are not supported\");\n            return this.parseArray(t, e);\n          }\n\n          return this.parseScalarValue(t, e);\n        }, t.prototype.parseObject = function (t, r) {\n          var i = this,\n              o = new Ui(ui);\n          return Qr(t) ? r.path && 0 < r.path.length && r.fieldMask.push(r.path) : Br(t, function (t, e) {\n            var n = i.parseData(e, r.childContextForField(t));\n            null != n && (o = o.insert(t, n));\n          }), new Za(o);\n        }, t.prototype.parseArray = function (t, e) {\n          for (var n = [], r = 0, i = 0, o = t; i < o.length; i++) {\n            var a = o[i],\n                s = this.parseData(a, e.childContextForArray(r));\n            null == s && (s = Va.INSTANCE), n.push(s), r++;\n          }\n\n          return new ts(n);\n        }, t.prototype.parseSentinelFieldValue = function (t, e) {\n          if (!Pc(e.dataSource)) throw e.createError(t._methodName + \"() can only be used with update() and set()\");\n          if (null === e.path) throw e.createError(t._methodName + \"() is not currently supported inside arrays\");\n\n          if (t instanceof Cc) {\n            if (e.dataSource !== Sc.MergeSet) throw e.dataSource === Sc.Update ? (Or(0 < e.path.length, \"FieldValue.delete() at the top level should have already been handled.\"), e.createError(\"FieldValue.delete() can only appear at the top level of your update data\")) : e.createError(\"FieldValue.delete() cannot be used with set() unless you pass {merge:true}\");\n            e.fieldMask.push(e.path);\n          } else if (t instanceof Dc) e.fieldTransforms.push(new ns(e.path, Du.instance));else if (t instanceof Nc) {\n            var n = this.parseArrayTransformElements(t._methodName, t._elements),\n                r = new Nu(n);\n            e.fieldTransforms.push(new ns(e.path, r));\n          } else if (t instanceof Ac) {\n            n = this.parseArrayTransformElements(t._methodName, t._elements);\n            var i = new Au(n);\n            e.fieldTransforms.push(new ns(e.path, i));\n          } else if (t instanceof kc) {\n            var o = this.parseQueryValue(\"FieldValue.increment\", t._operand),\n                a = new ku(o);\n            e.fieldTransforms.push(new ns(e.path, a));\n          } else Mr(\"Unknown FieldValue type: \" + t);\n        }, t.prototype.parseScalarValue = function (t, e) {\n          if (null === t) return Va.INSTANCE;\n          if (\"number\" == typeof t) return Ns(t) ? new Ga(t) : new Wa(t);\n          if (\"boolean\" == typeof t) return Ua.of(t);\n          if (\"string\" == typeof t) return new za(t);\n          if (t instanceof Date) return new Ha(Fi.fromDate(t));\n          if (t instanceof Fi) return new Ha(new Fi(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3)));\n          if (t instanceof fu) return new $a(t);\n          if (t instanceof mi) return new Xa(t);\n          if (t instanceof xc) return new Ja(t.databaseId, t.key);\n          throw e.createError(\"Unsupported field value: \" + ei(t));\n        }, t.prototype.parseArrayTransformElements = function (r, t) {\n          var i = this;\n          return t.map(function (t, e) {\n            var n = new Lc(Sc.Argument, r, Ci.EMPTY_PATH);\n            return i.parseData(t, n.childContextForArray(e));\n          });\n        }, t;\n      }();\n\n      function Fc(t) {\n        return !(\"object\" != typeof t || null === t || t instanceof Array || t instanceof Date || t instanceof Fi || t instanceof fu || t instanceof mi || t instanceof xc || t instanceof Ic);\n      }\n\n      function Vc(t, e, n) {\n        if (!Fc(n) || !ti(n)) {\n          var r = ei(n);\n          throw \"an object\" === r ? e.createError(t + \" a custom object\") : e.createError(t + \" \" + r);\n        }\n      }\n\n      function Uc(t, e) {\n        if (e instanceof dc) return e._internalPath;\n        if (\"string\" == typeof e) return Bc(t, e);\n        throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + t + \"() called with invalid data. Field path arguments must be of type string or FieldPath.\");\n      }\n\n      function Bc(e, t) {\n        try {\n          return function (e) {\n            if (0 <= e.search(mc)) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid field path (\" + e + \"). Paths must not contain '~', '*', '/', '[', or ']'\");\n\n            try {\n              return new (dc.bind.apply(dc, [void 0].concat(e.split(\".\"))))();\n            } catch (t) {\n              throw new xr(Lr.INVALID_ARGUMENT, \"Invalid field path (\" + e + \"). Paths must not be empty, begin with '.', end with '.', or contain '..'\");\n            }\n          }(t)._internalPath;\n        } catch (t) {\n          var n = Qc(t);\n          throw new xr(Lr.INVALID_ARGUMENT, \"Function \" + e + \"() called with invalid data. \" + n);\n        }\n      }\n\n      function Qc(t) {\n        return t instanceof Error ? t.message : t.toString();\n      }\n\n      var Kc = wa.COLLECTION_DISABLED,\n          jc = function () {\n        function t(t) {\n          if (void 0 === t.host) {\n            if (void 0 !== t.ssl) throw new xr(Lr.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            this.host = \"firestore.googleapis.com\", this.ssl = !0;\n          } else Yr(\"settings\", \"non-empty string\", \"host\", t.host), this.host = t.host, Xr(\"settings\", \"boolean\", \"ssl\", t.ssl), this.ssl = Vr(t.ssl, !0);\n\n          if (ri(\"settings\", t, [\"host\", \"ssl\", \"credentials\", \"timestampsInSnapshots\", \"cacheSizeBytes\", \"experimentalForceLongPolling\"]), Xr(\"settings\", \"object\", \"credentials\", t.credentials), this.credentials = t.credentials, Xr(\"settings\", \"boolean\", \"timestampsInSnapshots\", t.timestampsInSnapshots), !0 === t.timestampsInSnapshots ? kr(\"\\n  The timestampsInSnapshots setting now defaults to true and you no\\n  longer need to explicitly set it. In a future release, the setting\\n  will be removed entirely and so it is recommended that you remove it\\n  from your firestore.settings() call now.\") : !1 === t.timestampsInSnapshots && kr(\"\\n  The timestampsInSnapshots setting will soon be removed. YOU MUST UPDATE\\n  YOUR CODE.\\n\\n  To hide this warning, stop using the timestampsInSnapshots setting in your\\n  firestore.settings({ ... }) call.\\n\\n  Once you remove the setting, Timestamps stored in Cloud Firestore will be\\n  read back as Firebase Timestamp objects instead of as system Date objects.\\n  So you will also need to update code expecting a Date to instead expect a\\n  Timestamp. For example:\\n\\n  // Old:\\n  const date = snapshot.get('created_at');\\n  // New:\\n  const timestamp = snapshot.get('created_at'); const date =\\n  timestamp.toDate();\\n\\n  Please audit all existing usages of Date when you enable the new\\n  behavior.\"), this.timestampsInSnapshots = Vr(t.timestampsInSnapshots, !0), Xr(\"settings\", \"number\", \"cacheSizeBytes\", t.cacheSizeBytes), void 0 === t.cacheSizeBytes) this.cacheSizeBytes = wa.DEFAULT_CACHE_SIZE_BYTES;else {\n            if (t.cacheSizeBytes !== Kc && t.cacheSizeBytes < wa.MINIMUM_CACHE_SIZE_BYTES) throw new xr(Lr.INVALID_ARGUMENT, \"cacheSizeBytes must be at least \" + wa.MINIMUM_CACHE_SIZE_BYTES);\n            this.cacheSizeBytes = t.cacheSizeBytes;\n          }\n          Xr(\"settings\", \"boolean\", \"experimentalForceLongPolling\", t.experimentalForceLongPolling), this.forceLongPolling = void 0 !== t.experimentalForceLongPolling && t.experimentalForceLongPolling;\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return this.host === t.host && this.ssl === t.ssl && this.timestampsInSnapshots === t.timestampsInSnapshots && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes && this.forceLongPolling === t.forceLongPolling;\n        }, t;\n      }(),\n          Gc = function () {},\n          Wc = function () {\n        function o(t) {\n          var e = this;\n          this._queue = new ki(), this.INTERNAL = {\n            delete: function () {\n              return h(e, void 0, void 0, function () {\n                return p(this, function (t) {\n                  switch (t.label) {\n                    case 0:\n                      return this.ensureClientConfigured(), [4, this._firestoreClient.shutdown()];\n\n                    case 1:\n                      return t.sent(), [2];\n                  }\n                });\n              });\n            }\n          };\n          var n = new Gc();\n\n          if (\"object\" == typeof t.options) {\n            var r = t;\n            n.firebaseApp = r, n.databaseId = o.databaseIdFromApp(r), n.persistenceKey = n.firebaseApp.name, n.credentials = new vc(r);\n          } else {\n            var i = t;\n            if (!i.projectId) throw new xr(Lr.INVALID_ARGUMENT, \"Must provide projectId\");\n            n.databaseId = new bi(i.projectId, i.database), n.persistenceKey = \"[DEFAULT]\", n.credentials = new gc();\n          }\n\n          n.settings = new jc({}), this._config = n, this._databaseId = n.databaseId;\n        }\n\n        return o.prototype.settings = function (t) {\n          if (jr(\"Firestore.settings\", arguments, 1), zr(\"Firestore.settings\", \"object\", 1, t), Fr(t, \"persistence\")) throw new xr(Lr.INVALID_ARGUMENT, '\"persistence\" is now specified with a separate call to firestore.enablePersistence().');\n          var e = new jc(t);\n          if (this._firestoreClient && !this._config.settings.isEqual(e)) throw new xr(Lr.FAILED_PRECONDITION, \"Firestore has already been started and its settings can no longer be changed. You can only call settings() before calling any other methods on a Firestore object.\");\n          void 0 !== (this._config.settings = e).credentials && (this._config.credentials = function (t) {\n            if (!t) return new gc();\n\n            switch (t.type) {\n              case \"gapi\":\n                var e = t.client;\n                return Or(!(\"object\" != typeof e || null === e || !e.auth || !e.auth.getAuthHeaderValueForFirstParty), \"unexpected gapi interface\"), new wc(e, t.sessionIndex || \"0\");\n\n              case \"provider\":\n                return t.client;\n\n              default:\n                throw new xr(Lr.INVALID_ARGUMENT, \"makeCredentialsProvider failed due to invalid credential type\");\n            }\n          }(e.credentials));\n        }, o.prototype.enableNetwork = function () {\n          return this.ensureClientConfigured(), this._firestoreClient.enableNetwork();\n        }, o.prototype.disableNetwork = function () {\n          return this.ensureClientConfigured(), this._firestoreClient.disableNetwork();\n        }, o.prototype.enablePersistence = function (t) {\n          if (this._firestoreClient) throw new xr(Lr.FAILED_PRECONDITION, \"Firestore has already been started and persistence can no longer be enabled. You can only call enablePersistence() before calling any other methods on a Firestore object.\");\n          var e = !1;\n          return t && (void 0 !== t.experimentalTabSynchronization && kr(\"The 'experimentalTabSynchronization' setting has been renamed to 'synchronizeTabs'. In a future release, the setting will be removed and it is recommended that you update your firestore.enablePersistence() call to use 'synchronizeTabs'.\"), e = Vr(void 0 !== t.synchronizeTabs ? t.synchronizeTabs : t.experimentalTabSynchronization, !1)), this.configureClient(new hc(this._config.settings.cacheSizeBytes, e));\n        }, o.prototype.clearPersistence = function () {\n          var t = this,\n              n = Na.buildStoragePrefix(this.makeDatabaseInfo()),\n              r = new Ni();\n          return this._queue.enqueueAndForget(function () {\n            return h(t, void 0, void 0, function () {\n              var e;\n              return p(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    if (t.trys.push([0, 2,, 3]), void 0 !== this._firestoreClient && !this._firestoreClient.clientShutdown) throw new xr(Lr.FAILED_PRECONDITION, \"Persistence cannot be cleared after this Firestore instance is initialized.\");\n                    return [4, Na.clearPersistence(n)];\n\n                  case 1:\n                    return t.sent(), r.resolve(), [3, 3];\n\n                  case 2:\n                    return e = t.sent(), r.reject(e), [3, 3];\n\n                  case 3:\n                    return [2];\n                }\n              });\n            });\n          }), r.promise;\n        }, o.prototype.ensureClientConfigured = function () {\n          return this._firestoreClient || this.configureClient(new lc()), this._firestoreClient;\n        }, o.prototype.makeDatabaseInfo = function () {\n          return new gi(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl, this._config.settings.forceLongPolling);\n        }, o.prototype.configureClient = function (t) {\n          var r = this;\n          Or(!!this._config.settings.host, \"FirestoreSettings.host cannot be falsey\"), Or(!this._firestoreClient, \"configureClient() called multiple times\");\n          var e = this.makeDatabaseInfo();\n          return this._dataConverter = new qc(function (t) {\n            if (t instanceof Yc) {\n              var e = r._config.databaseId,\n                  n = t.firestore._config.databaseId;\n              if (!n.isEqual(e)) throw new xr(Lr.INVALID_ARGUMENT, \"Document reference is for database \" + n.projectId + \"/\" + n.database + \" but should be for database \" + e.projectId + \"/\" + e.database);\n              return new xc(r._config.databaseId, t._key);\n            }\n\n            return t;\n          }), this._firestoreClient = new fc(_r.getPlatform(), e, this._config.credentials, this._queue), this._firestoreClient.start(t);\n        }, o.databaseIdFromApp = function (t) {\n          var e = t.options;\n          if (!Fr(e, \"projectId\")) throw new xr(Lr.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n          var n = e.projectId;\n          if (!n || \"string\" != typeof n) throw new xr(Lr.INVALID_ARGUMENT, \"projectId must be a string in FirebaseApp.options\");\n          return new bi(n);\n        }, Object.defineProperty(o.prototype, \"app\", {\n          get: function () {\n            if (!this._config.firebaseApp) throw new xr(Lr.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is not available\");\n            return this._config.firebaseApp;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), o.prototype.collection = function (t) {\n          return jr(\"Firestore.collection\", arguments, 1), zr(\"Firestore.collection\", \"non-empty string\", 1, t), this.ensureClientConfigured(), new eh(Ti.fromString(t), this);\n        }, o.prototype.doc = function (t) {\n          return jr(\"Firestore.doc\", arguments, 1), zr(\"Firestore.doc\", \"non-empty string\", 1, t), this.ensureClientConfigured(), Yc.forPath(Ti.fromString(t), this);\n        }, o.prototype.collectionGroup = function (t) {\n          if (jr(\"Firestore.collectionGroup\", arguments, 1), zr(\"Firestore.collectionGroup\", \"non-empty string\", 1, t), 0 <= t.indexOf(\"/\")) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid collection ID '\" + t + \"' passed to function Firestore.collectionGroup(). Collection IDs must not contain '/'.\");\n          return this.ensureClientConfigured(), new Zc(new pu(Ti.EMPTY_PATH, t), this);\n        }, o.prototype.runTransaction = function (e) {\n          var n = this;\n          return jr(\"Firestore.runTransaction\", arguments, 1), zr(\"Firestore.runTransaction\", \"function\", 1, e), this.ensureClientConfigured().transaction(function (t) {\n            return e(new zc(n, t));\n          });\n        }, o.prototype.batch = function () {\n          return this.ensureClientConfigured(), new Hc(this);\n        }, Object.defineProperty(o, \"logLevel\", {\n          get: function () {\n            switch (Dr()) {\n              case yr.DEBUG:\n                return \"debug\";\n\n              case yr.ERROR:\n                return \"error\";\n\n              case yr.SILENT:\n                return \"silent\";\n\n              default:\n                return Mr(\"Unknown log level: \" + Dr());\n            }\n          },\n          enumerable: !0,\n          configurable: !0\n        }), o.setLogLevel = function (t) {\n          switch (jr(\"Firestore.setLogLevel\", arguments, 1), zr(\"Firestore.setLogLevel\", \"non-empty string\", 1, t), t) {\n            case \"debug\":\n              Nr(yr.DEBUG);\n              break;\n\n            case \"error\":\n              Nr(yr.ERROR);\n              break;\n\n            case \"silent\":\n              Nr(yr.SILENT);\n              break;\n\n            default:\n              throw new xr(Lr.INVALID_ARGUMENT, \"Invalid log level: \" + t);\n          }\n        }, o.prototype._areTimestampsInSnapshotsEnabled = function () {\n          return this._config.settings.timestampsInSnapshots;\n        }, o;\n      }(),\n          zc = function () {\n        function t(t, e) {\n          this._firestore = t, this._transaction = e;\n        }\n\n        return t.prototype.get = function (t) {\n          var n = this;\n          jr(\"Transaction.get\", arguments, 1);\n          var r = oh(\"Transaction.get\", t, this._firestore);\n          return this._transaction.lookup([r._key]).then(function (t) {\n            if (!t || 1 !== t.length) return Mr(\"Mismatch in docs returned from document lookup.\");\n            var e = t[0];\n            if (e instanceof Oo) return new Jc(n._firestore, r._key, null, !1, !1);\n            if (e instanceof Mo) return new Jc(n._firestore, r._key, e, !1, !1);\n            throw Mr(\"BatchGetDocumentsRequest returned unexpected document type: \" + e.constructor.name);\n          });\n        }, t.prototype.set = function (t, e, n) {\n          Wr(\"Transaction.set\", arguments, 2, 3);\n          var r = oh(\"Transaction.set\", t, this._firestore),\n              i = (n = nh(\"Transaction.set\", n)).merge || n.mergeFields ? this._firestore._dataConverter.parseMergeData(\"Transaction.set\", e, n.mergeFields) : this._firestore._dataConverter.parseSetData(\"Transaction.set\", e);\n          return this._transaction.set(r._key, i), this;\n        }, t.prototype.update = function (t, e, n) {\n          for (var r, i, o = [], a = 3; a < arguments.length; a++) o[a - 3] = arguments[a];\n\n          return i = \"string\" == typeof e || e instanceof dc ? (Gr(\"Transaction.update\", arguments, 3), r = oh(\"Transaction.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateVarargs(\"Transaction.update\", e, n, o)) : (jr(\"Transaction.update\", arguments, 2), r = oh(\"Transaction.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateData(\"Transaction.update\", e)), this._transaction.update(r._key, i), this;\n        }, t.prototype.delete = function (t) {\n          jr(\"Transaction.delete\", arguments, 1);\n          var e = oh(\"Transaction.delete\", t, this._firestore);\n          return this._transaction.delete(e._key), this;\n        }, t;\n      }(),\n          Hc = function () {\n        function t(t) {\n          this._firestore = t, this._mutations = [], this._committed = !1;\n        }\n\n        return t.prototype.set = function (t, e, n) {\n          Wr(\"WriteBatch.set\", arguments, 2, 3), this.verifyNotCommitted();\n          var r = oh(\"WriteBatch.set\", t, this._firestore),\n              i = (n = nh(\"WriteBatch.set\", n)).merge || n.mergeFields ? this._firestore._dataConverter.parseMergeData(\"WriteBatch.set\", e, n.mergeFields) : this._firestore._dataConverter.parseSetData(\"WriteBatch.set\", e);\n          return this._mutations = this._mutations.concat(i.toMutations(r._key, is.NONE)), this;\n        }, t.prototype.update = function (t, e, n) {\n          for (var r, i, o = [], a = 3; a < arguments.length; a++) o[a - 3] = arguments[a];\n\n          return this.verifyNotCommitted(), i = \"string\" == typeof e || e instanceof dc ? (Gr(\"WriteBatch.update\", arguments, 3), r = oh(\"WriteBatch.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateVarargs(\"WriteBatch.update\", e, n, o)) : (jr(\"WriteBatch.update\", arguments, 2), r = oh(\"WriteBatch.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateData(\"WriteBatch.update\", e)), this._mutations = this._mutations.concat(i.toMutations(r._key, is.exists(!0))), this;\n        }, t.prototype.delete = function (t) {\n          jr(\"WriteBatch.delete\", arguments, 1), this.verifyNotCommitted();\n          var e = oh(\"WriteBatch.delete\", t, this._firestore);\n          return this._mutations = this._mutations.concat(new cs(e._key, is.NONE)), this;\n        }, t.prototype.commit = function () {\n          return h(this, void 0, void 0, function () {\n            return p(this, function (t) {\n              return this.verifyNotCommitted(), this._committed = !0, 0 < this._mutations.length ? [2, this._firestore.ensureClientConfigured().write(this._mutations)] : [2];\n            });\n          });\n        }, t.prototype.verifyNotCommitted = function () {\n          if (this._committed) throw new xr(Lr.FAILED_PRECONDITION, \"A write batch can no longer be used after commit() has been called.\");\n        }, t;\n      }(),\n          Yc = function () {\n        function n(t, e) {\n          this._key = t, this.firestore = e, this._firestoreClient = this.firestore.ensureClientConfigured();\n        }\n\n        return n.forPath = function (t, e) {\n          if (t.length % 2 != 0) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid document reference. Document references must have an even number of segments, but \" + t.canonicalString() + \" has \" + t.length);\n          return new n(new Di(t), e);\n        }, Object.defineProperty(n.prototype, \"id\", {\n          get: function () {\n            return this._key.path.lastSegment();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(n.prototype, \"parent\", {\n          get: function () {\n            return new eh(this._key.path.popLast(), this.firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(n.prototype, \"path\", {\n          get: function () {\n            return this._key.path.canonicalString();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), n.prototype.collection = function (t) {\n          if (jr(\"DocumentReference.collection\", arguments, 1), zr(\"DocumentReference.collection\", \"non-empty string\", 1, t), !t) throw new xr(Lr.INVALID_ARGUMENT, \"Must provide a non-empty collection name to collection()\");\n          var e = Ti.fromString(t);\n          return new eh(this._key.path.child(e), this.firestore);\n        }, n.prototype.isEqual = function (t) {\n          if (!(t instanceof n)) throw ii(\"isEqual\", \"DocumentReference\", 1, t);\n          return this.firestore === t.firestore && this._key.isEqual(t._key);\n        }, n.prototype.set = function (t, e) {\n          Wr(\"DocumentReference.set\", arguments, 1, 2);\n          var n = (e = nh(\"DocumentReference.set\", e)).merge || e.mergeFields ? this.firestore._dataConverter.parseMergeData(\"DocumentReference.set\", t, e.mergeFields) : this.firestore._dataConverter.parseSetData(\"DocumentReference.set\", t);\n          return this._firestoreClient.write(n.toMutations(this._key, is.NONE));\n        }, n.prototype.update = function (t, e) {\n          for (var n, r = [], i = 2; i < arguments.length; i++) r[i - 2] = arguments[i];\n\n          return n = \"string\" == typeof t || t instanceof dc ? (Gr(\"DocumentReference.update\", arguments, 2), this.firestore._dataConverter.parseUpdateVarargs(\"DocumentReference.update\", t, e, r)) : (jr(\"DocumentReference.update\", arguments, 1), this.firestore._dataConverter.parseUpdateData(\"DocumentReference.update\", t)), this._firestoreClient.write(n.toMutations(this._key, is.exists(!0)));\n        }, n.prototype.delete = function () {\n          return jr(\"DocumentReference.delete\", arguments, 0), this._firestoreClient.write([new cs(this._key, is.NONE)]);\n        }, n.prototype.onSnapshot = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          Wr(\"DocumentReference.onSnapshot\", arguments, 1, 4);\n          var n,\n              r = {\n            includeMetadataChanges: !1\n          },\n              i = 0;\n          \"object\" != typeof t[i] || Ec(t[i]) || (ri(\"DocumentReference.onSnapshot\", r = t[i], [\"includeMetadataChanges\"]), Xr(\"DocumentReference.onSnapshot\", \"boolean\", \"includeMetadataChanges\", r.includeMetadataChanges), i++);\n          var o = {\n            includeMetadataChanges: r.includeMetadataChanges\n          };\n          return n = Ec(t[i]) ? t[i] : (zr(\"DocumentReference.onSnapshot\", \"function\", i, t[i]), Hr(\"DocumentReference.onSnapshot\", \"function\", i + 1, t[i + 1]), Hr(\"DocumentReference.onSnapshot\", \"function\", i + 2, t[i + 2]), {\n            next: t[i],\n            error: t[i + 1],\n            complete: t[i + 2]\n          }), this.onSnapshotInternal(o, n);\n        }, n.prototype.onSnapshotInternal = function (t, n) {\n          var r = this,\n              e = function (t) {\n            console.error(\"Uncaught Error in onSnapshot:\", t);\n          };\n\n          n.error && (e = n.error.bind(n));\n\n          var i = new pc({\n            next: function (t) {\n              if (n.next) {\n                Or(t.docs.size <= 1, \"Too many documents returned on a document query\");\n                var e = t.docs.get(r._key);\n                n.next(new Jc(r.firestore, r._key, e, t.fromCache, t.hasPendingWrites));\n              }\n            },\n            error: e\n          }),\n              o = this._firestoreClient.listen(pu.atPath(this._key.path), i, t);\n\n          return function () {\n            i.mute(), r._firestoreClient.unlisten(o);\n          };\n        }, n.prototype.get = function (n) {\n          var r = this;\n          return Wr(\"DocumentReference.get\", arguments, 0, 1), ih(\"DocumentReference.get\", n), new Promise(function (e, t) {\n            n && \"cache\" === n.source ? r.firestore.ensureClientConfigured().getDocumentFromLocalCache(r._key).then(function (t) {\n              e(new Jc(r.firestore, r._key, t, !0, t instanceof Mo && t.hasLocalMutations));\n            }, t) : r.getViaSnapshotListener(e, t, n);\n          });\n        }, n.prototype.getViaSnapshotListener = function (e, n, r) {\n          var i = this.onSnapshotInternal({\n            includeMetadataChanges: !0,\n            waitForSyncWhenOnline: !0\n          }, {\n            next: function (t) {\n              i(), !t.exists && t.metadata.fromCache ? n(new xr(Lr.UNAVAILABLE, \"Failed to get document because the client is offline.\")) : t.exists && t.metadata.fromCache && r && \"server\" === r.source ? n(new xr(Lr.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to \"server\" to retrieve the cached document.)')) : e(t);\n            },\n            error: n\n          });\n        }, n;\n      }(),\n          Xc = function () {\n        function t(t, e) {\n          this.hasPendingWrites = t, this.fromCache = e;\n        }\n\n        return t.prototype.isEqual = function (t) {\n          return this.hasPendingWrites === t.hasPendingWrites && this.fromCache === t.fromCache;\n        }, t;\n      }(),\n          Jc = function () {\n        function e(t, e, n, r, i) {\n          this._firestore = t, this._key = e, this._document = n, this._fromCache = r, this._hasPendingWrites = i;\n        }\n\n        return e.prototype.data = function (t) {\n          return Wr(\"DocumentSnapshot.data\", arguments, 0, 1), t = rh(\"DocumentSnapshot.data\", t), this._document ? this.convertObject(this._document.data, qa.fromSnapshotOptions(t, this._firestore._areTimestampsInSnapshotsEnabled())) : void 0;\n        }, e.prototype.get = function (t, e) {\n          if (Wr(\"DocumentSnapshot.get\", arguments, 1, 2), e = rh(\"DocumentSnapshot.get\", e), this._document) {\n            var n = this._document.data.field(Uc(\"DocumentSnapshot.get\", t));\n\n            if (void 0 !== n) return this.convertValue(n, qa.fromSnapshotOptions(e, this._firestore._areTimestampsInSnapshotsEnabled()));\n          }\n        }, Object.defineProperty(e.prototype, \"id\", {\n          get: function () {\n            return this._key.path.lastSegment();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"ref\", {\n          get: function () {\n            return new Yc(this._key, this._firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"exists\", {\n          get: function () {\n            return null !== this._document;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"metadata\", {\n          get: function () {\n            return new Xc(this._hasPendingWrites, this._fromCache);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.isEqual = function (t) {\n          if (!(t instanceof e)) throw ii(\"isEqual\", \"DocumentSnapshot\", 1, t);\n          return this._firestore === t._firestore && this._fromCache === t._fromCache && this._key.isEqual(t._key) && (null === this._document ? null === t._document : this._document.isEqual(t._document));\n        }, e.prototype.convertObject = function (t, n) {\n          var r = this,\n              i = {};\n          return t.forEach(function (t, e) {\n            i[t] = r.convertValue(e, n);\n          }), i;\n        }, e.prototype.convertValue = function (t, e) {\n          if (t instanceof Za) return this.convertObject(t, e);\n          if (t instanceof ts) return this.convertArray(t, e);\n\n          if (t instanceof Ja) {\n            var n = t.value(e),\n                r = this._firestore.ensureClientConfigured().databaseId();\n\n            return t.databaseId.isEqual(r) || kr(\"Document \" + this._key.path + \" contains a document reference within a different database (\" + t.databaseId.projectId + \"/\" + t.databaseId.database + \") which is not supported. It will be treated as a reference in the current database (\" + r.projectId + \"/\" + r.database + \") instead.\"), new Yc(n, this._firestore);\n          }\n\n          return t.value(e);\n        }, e.prototype.convertArray = function (t, e) {\n          var n = this;\n          return t.internalValue.map(function (t) {\n            return n.convertValue(t, e);\n          });\n        }, e;\n      }(),\n          $c = function (o) {\n        function t(t, e, n, r, i) {\n          return o.call(this, t, e, n, r, i) || this;\n        }\n\n        return s(t, o), t.prototype.data = function (t) {\n          var e = o.prototype.data.call(this, t);\n          return Or(\"object\" == typeof e, \"Document in a QueryDocumentSnapshot should exist\"), e;\n        }, t;\n      }(Jc),\n          Zc = function () {\n        function c(t, e) {\n          this._query = t, this.firestore = e;\n        }\n\n        return c.prototype.where = function (t, e, n) {\n          if (jr(\"Query.where\", arguments, 3), ni(\"Query.where\", 3, n), \"in\" !== e && \"array-contains-any\" !== e) {\n            !function (t, e, n, r) {\n              if (!e.some(function (t) {\n                return t === r;\n              })) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid value \" + ei(r) + \" provided to function \" + t + \"() for its \" + oi(n) + \" argument. Acceptable values: \" + e.join(\", \"));\n            }(\"Query.where\", [\"<\", \"<=\", \"==\", \">=\", \">\", \"array-contains\"], 2, e);\n          }\n\n          var r,\n              i = Uc(\"Query.where\", t),\n              o = mu.fromString(e);\n\n          if (i.isKeyField()) {\n            if (o === mu.ARRAY_CONTAINS || o === mu.ARRAY_CONTAINS_ANY || o === mu.IN) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid Query. You can't perform '\" + o.toString() + \"' queries on FieldPath.documentId().\");\n\n            if (\"string\" == typeof n) {\n              if (\"\" === n) throw new xr(Lr.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a valid document ID if the first parameter is FieldPath.documentId(), but it was an empty string.\");\n              if (!this._query.isCollectionGroupQuery() && -1 !== n.indexOf(\"/\")) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid third parameter to Query.where(). When querying a collection by FieldPath.documentId(), the value provided must be a plain document ID, but '\" + n + \"' contains a slash.\");\n\n              var a = this._query.path.child(Ti.fromString(n));\n\n              if (!Di.isDocumentKey(a)) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid third parameter to Query.where(). When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '\" + a + \"' is not because it has an odd number of segments (\" + a.length + \").\");\n              r = new Ja(this.firestore._databaseId, new Di(a));\n            } else {\n              if (!(n instanceof Yc)) throw new xr(Lr.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a string or a DocumentReference if the first parameter is FieldPath.documentId(), but it was: \" + ei(n) + \".\");\n              var s = n;\n              r = new Ja(this.firestore._databaseId, s._key);\n            }\n          } else {\n            if (o === mu.IN || o === mu.ARRAY_CONTAINS_ANY) {\n              if (!Array.isArray(n) || 0 === n.length) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid Query. A non-empty array is required for '\" + o.toString() + \"' filters.\");\n              if (10 < n.length) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid Query. '\" + o.toString() + \"' filters support a maximum of 10 elements in the value array.\");\n            }\n\n            r = this.firestore._dataConverter.parseQueryValue(\"Query.where\", n);\n          }\n\n          var u = yu.create(i, o, r);\n          return this.validateNewFilter(u), new c(this._query.addFilter(u), this.firestore);\n        }, c.prototype.orderBy = function (t, e) {\n          var n;\n          if (Wr(\"Query.orderBy\", arguments, 1, 2), Hr(\"Query.orderBy\", \"non-empty string\", 2, e), void 0 === e || \"asc\" === e) n = Eu.ASCENDING;else {\n            if (\"desc\" !== e) throw new xr(Lr.INVALID_ARGUMENT, \"Function Query.orderBy() has unknown direction '\" + e + \"', expected 'asc' or 'desc'.\");\n            n = Eu.DESCENDING;\n          }\n          if (null !== this._query.startAt) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid query. You must not call Query.startAt() or Query.startAfter() before calling Query.orderBy().\");\n          if (null !== this._query.endAt) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid query. You must not call Query.endAt() or Query.endBefore() before calling Query.orderBy().\");\n          var r = Uc(\"Query.orderBy\", t),\n              i = new Tu(r, n);\n          return this.validateNewOrderBy(i), new c(this._query.addOrderBy(i), this.firestore);\n        }, c.prototype.limit = function (t) {\n          if (jr(\"Query.limit\", arguments, 1), zr(\"Query.limit\", \"number\", 1, t), t <= 0) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid Query. Query limit (\" + t + \") is invalid. Limit must be positive.\");\n          return new c(this._query.withLimit(t), this.firestore);\n        }, c.prototype.startAt = function (t) {\n          for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n          Gr(\"Query.startAt\", arguments, 1);\n          var r = this.boundFromDocOrFields(\"Query.startAt\", t, e, !0);\n          return new c(this._query.withStartAt(r), this.firestore);\n        }, c.prototype.startAfter = function (t) {\n          for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n          Gr(\"Query.startAfter\", arguments, 1);\n          var r = this.boundFromDocOrFields(\"Query.startAfter\", t, e, !1);\n          return new c(this._query.withStartAt(r), this.firestore);\n        }, c.prototype.endBefore = function (t) {\n          for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n          Gr(\"Query.endBefore\", arguments, 1);\n          var r = this.boundFromDocOrFields(\"Query.endBefore\", t, e, !0);\n          return new c(this._query.withEndAt(r), this.firestore);\n        }, c.prototype.endAt = function (t) {\n          for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n          Gr(\"Query.endAt\", arguments, 1);\n          var r = this.boundFromDocOrFields(\"Query.endAt\", t, e, !1);\n          return new c(this._query.withEndAt(r), this.firestore);\n        }, c.prototype.isEqual = function (t) {\n          if (!(t instanceof c)) throw ii(\"isEqual\", \"Query\", 1, t);\n          return this.firestore === t.firestore && this._query.isEqual(t._query);\n        }, c.prototype.boundFromDocOrFields = function (t, e, n, r) {\n          if (ni(t, 1, e), e instanceof Jc) {\n            if (0 < n.length) throw new xr(Lr.INVALID_ARGUMENT, \"Too many arguments provided to \" + t + \"().\");\n            var i = e;\n            if (!i.exists) throw new xr(Lr.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \" + t + \"().\");\n            return this.boundFromDocument(t, i._document, r);\n          }\n\n          var o = [e].concat(n);\n          return this.boundFromFields(t, o, r);\n        }, c.prototype.boundFromDocument = function (t, e, n) {\n          for (var r = [], i = 0, o = this._query.orderBy; i < o.length; i++) {\n            var a = o[i];\n            if (a.field.isKeyField()) r.push(new Ja(this.firestore._databaseId, e.key));else {\n              var s = e.field(a.field);\n              if (s instanceof Ya) throw new xr(Lr.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field \"' + a.field + '\" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');\n\n              if (void 0 === s) {\n                var u = a.field.canonicalString();\n                throw new xr(Lr.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a document for which the field '\" + u + \"' (used as the orderBy) does not exist.\");\n              }\n\n              r.push(s);\n            }\n          }\n\n          return new Su(r, n);\n        }, c.prototype.boundFromFields = function (t, e, n) {\n          var r = this._query.explicitOrderBy;\n          if (e.length > r.length) throw new xr(Lr.INVALID_ARGUMENT, \"Too many arguments provided to \" + t + \"(). The number of arguments must be less than or equal to the number of Query.orderBy() clauses\");\n\n          for (var i = [], o = 0; o < e.length; o++) {\n            var a = e[o];\n\n            if (r[o].field.isKeyField()) {\n              if (\"string\" != typeof a) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \" + t + \"(), but got a \" + typeof a);\n              if (!this._query.isCollectionGroupQuery() && -1 !== a.indexOf(\"/\")) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to \" + t + \"() must be a plain document ID, but '\" + a + \"' contains a slash.\");\n\n              var s = this._query.path.child(Ti.fromString(a));\n\n              if (!Di.isDocumentKey(s)) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to \" + t + \"() must result in a valid document path, but '\" + s + \"' is not because it contains an odd number of segments.\");\n              var u = new Di(s);\n              i.push(new Ja(this.firestore._databaseId, u));\n            } else {\n              var c = this.firestore._dataConverter.parseQueryValue(t, a);\n\n              i.push(c);\n            }\n          }\n\n          return new Su(i, n);\n        }, c.prototype.onSnapshot = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          Wr(\"Query.onSnapshot\", arguments, 1, 4);\n          var n,\n              r = {},\n              i = 0;\n          return \"object\" != typeof t[i] || Ec(t[i]) || (ri(\"Query.onSnapshot\", r = t[i], [\"includeMetadataChanges\"]), Xr(\"Query.onSnapshot\", \"boolean\", \"includeMetadataChanges\", r.includeMetadataChanges), i++), n = Ec(t[i]) ? t[i] : (zr(\"Query.onSnapshot\", \"function\", i, t[i]), Hr(\"Query.onSnapshot\", \"function\", i + 1, t[i + 1]), Hr(\"Query.onSnapshot\", \"function\", i + 2, t[i + 2]), {\n            next: t[i],\n            error: t[i + 1],\n            complete: t[i + 2]\n          }), this.onSnapshotInternal(r, n);\n        }, c.prototype.onSnapshotInternal = function (t, e) {\n          var n = this,\n              r = function (t) {\n            console.error(\"Uncaught Error in onSnapshot:\", t);\n          };\n\n          e.error && (r = e.error.bind(e));\n          var i = new pc({\n            next: function (t) {\n              e.next && e.next(new th(n.firestore, n._query, t));\n            },\n            error: r\n          }),\n              o = this.firestore.ensureClientConfigured(),\n              a = o.listen(this._query, i, t);\n          return function () {\n            i.mute(), o.unlisten(a);\n          };\n        }, c.prototype.get = function (n) {\n          var r = this;\n          return Wr(\"Query.get\", arguments, 0, 1), ih(\"Query.get\", n), new Promise(function (e, t) {\n            n && \"cache\" === n.source ? r.firestore.ensureClientConfigured().getDocumentsFromLocalCache(r._query).then(function (t) {\n              e(new th(r.firestore, r._query, t));\n            }, t) : r.getViaSnapshotListener(e, t, n);\n          });\n        }, c.prototype.getViaSnapshotListener = function (e, n, r) {\n          var i = this.onSnapshotInternal({\n            includeMetadataChanges: !0,\n            waitForSyncWhenOnline: !0\n          }, {\n            next: function (t) {\n              i(), t.metadata.fromCache && r && \"server\" === r.source ? n(new xr(Lr.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to \"server\" to retrieve the cached documents.)')) : e(t);\n            },\n            error: n\n          });\n        }, c.prototype.validateNewFilter = function (t) {\n          if (t instanceof yu) {\n            var e = [mu.ARRAY_CONTAINS, mu.ARRAY_CONTAINS_ANY],\n                n = [mu.IN, mu.ARRAY_CONTAINS_ANY],\n                r = 0 <= e.indexOf(t.op),\n                i = 0 <= n.indexOf(t.op);\n\n            if (t.isInequality()) {\n              var o = this._query.getInequalityFilterField();\n\n              if (null !== o && !o.isEqual(t.field)) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid query. All where filters with an inequality (<, <=, >, or >=) must be on the same field. But you have inequality filters on '\" + o.toString() + \"' and '\" + t.field.toString() + \"'\");\n\n              var a = this._query.getFirstOrderByField();\n\n              null !== a && this.validateOrderByAndInequalityMatch(t.field, a);\n            } else if (i || r) {\n              var s = null;\n              if (i && (s = this._query.findFilterOperator(n)), null === s && r && (s = this._query.findFilterOperator(e)), null != s) throw s === t.op ? new xr(Lr.INVALID_ARGUMENT, \"Invalid query. You cannot use more than one '\" + t.op.toString() + \"' filter.\") : new xr(Lr.INVALID_ARGUMENT, \"Invalid query. You cannot use '\" + t.op.toString() + \"' filters with '\" + s.toString() + \"' filters.\");\n            }\n          }\n        }, c.prototype.validateNewOrderBy = function (t) {\n          if (null === this._query.getFirstOrderByField()) {\n            var e = this._query.getInequalityFilterField();\n\n            null !== e && this.validateOrderByAndInequalityMatch(e, t.field);\n          }\n        }, c.prototype.validateOrderByAndInequalityMatch = function (t, e) {\n          if (!e.isEqual(t)) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid query. You have a where filter with an inequality (<, <=, >, or >=) on field '\" + t.toString() + \"' and so you must also use '\" + t.toString() + \"' as your first Query.orderBy(), but your first Query.orderBy() is on field '\" + e.toString() + \"' instead.\");\n        }, c;\n      }(),\n          th = function () {\n        function e(t, e, n) {\n          this._firestore = t, this._originalQuery = e, this._snapshot = n, this._cachedChanges = null, this._cachedChangesIncludeMetadataChanges = null, this.metadata = new Xc(n.hasPendingWrites, n.fromCache);\n        }\n\n        return Object.defineProperty(e.prototype, \"docs\", {\n          get: function () {\n            var e = [];\n            return this.forEach(function (t) {\n              return e.push(t);\n            }), e;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"empty\", {\n          get: function () {\n            return this._snapshot.docs.isEmpty();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(e.prototype, \"size\", {\n          get: function () {\n            return this._snapshot.docs.size;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.forEach = function (e, n) {\n          var r = this;\n          Wr(\"QuerySnapshot.forEach\", arguments, 1, 2), zr(\"QuerySnapshot.forEach\", \"function\", 1, e), this._snapshot.docs.forEach(function (t) {\n            e.call(n, r.convertToDocumentImpl(t));\n          });\n        }, Object.defineProperty(e.prototype, \"query\", {\n          get: function () {\n            return new Zc(this._originalQuery, this._firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.docChanges = function (t) {\n          t && (ri(\"QuerySnapshot.docChanges\", t, [\"includeMetadataChanges\"]), Xr(\"QuerySnapshot.docChanges\", \"boolean\", \"includeMetadataChanges\", t.includeMetadataChanges));\n          var e = !(!t || !t.includeMetadataChanges);\n          if (e && this._snapshot.excludesMetadataChanges) throw new xr(Lr.INVALID_ARGUMENT, \"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().\");\n          return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function (i, e, o) {\n            {\n              if (o.oldDocs.isEmpty()) {\n                var n,\n                    r = 0;\n                return o.docChanges.map(function (t) {\n                  var e = new $c(i, t.doc.key, t.doc, o.fromCache, o.mutatedKeys.has(t.doc.key));\n                  return Or(t.type === Ws.Added, \"Invalid event type for first snapshot\"), Or(!n || o.query.docComparator(n, t.doc) < 0, \"Got added events in wrong order\"), n = t.doc, {\n                    type: \"added\",\n                    doc: e,\n                    oldIndex: -1,\n                    newIndex: r++\n                  };\n                });\n              }\n\n              var a = o.oldDocs;\n              return o.docChanges.filter(function (t) {\n                return e || t.type !== Ws.Metadata;\n              }).map(function (t) {\n                var e = new $c(i, t.doc.key, t.doc, o.fromCache, o.mutatedKeys.has(t.doc.key)),\n                    n = -1,\n                    r = -1;\n                return t.type !== Ws.Added && (Or(0 <= (n = a.indexOf(t.doc.key)), \"Index for document not found\"), a = a.delete(t.doc.key)), t.type !== Ws.Removed && (a = a.add(t.doc), r = a.indexOf(t.doc.key)), {\n                  type: function (t) {\n                    switch (t) {\n                      case Ws.Added:\n                        return \"added\";\n\n                      case Ws.Modified:\n                      case Ws.Metadata:\n                        return \"modified\";\n\n                      case Ws.Removed:\n                        return \"removed\";\n\n                      default:\n                        return Mr(\"Unknown change type: \" + t);\n                    }\n                  }(t.type),\n                  doc: e,\n                  oldIndex: n,\n                  newIndex: r\n                };\n              });\n            }\n          }(this._firestore, e, this._snapshot), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;\n        }, e.prototype.isEqual = function (t) {\n          if (!(t instanceof e)) throw ii(\"isEqual\", \"QuerySnapshot\", 1, t);\n          return this._firestore === t._firestore && this._originalQuery.isEqual(t._originalQuery) && this._snapshot.isEqual(t._snapshot);\n        }, e.prototype.convertToDocumentImpl = function (t) {\n          return new $c(this._firestore, t.key, t, this.metadata.fromCache, this._snapshot.mutatedKeys.has(t.key));\n        }, e;\n      }();\n\n      [\"length\", \"forEach\", \"map\"].concat(\"undefined\" != typeof Symbol ? [Symbol.iterator] : []).forEach(function (t) {\n        try {\n          Object.defineProperty(th.prototype.docChanges, t, {\n            get: function () {\n              return function () {\n                throw new xr(Lr.INVALID_ARGUMENT, 'QuerySnapshot.docChanges has been changed from a property into a method, so usages like \"querySnapshot.docChanges\" should become \"querySnapshot.docChanges()\"');\n              }();\n            }\n          });\n        } catch (t) {}\n      });\n\n      var eh = function (r) {\n        function t(t, e) {\n          var n = r.call(this, pu.atPath(t), e) || this;\n          if (t.length % 2 != 1) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid collection reference. Collection references must have an odd number of segments, but \" + t.canonicalString() + \" has \" + t.length);\n          return n;\n        }\n\n        return s(t, r), Object.defineProperty(t.prototype, \"id\", {\n          get: function () {\n            return this._query.path.lastSegment();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"parent\", {\n          get: function () {\n            var t = this._query.path.popLast();\n\n            return t.isEmpty() ? null : new Yc(new Di(t), this.firestore);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"path\", {\n          get: function () {\n            return this._query.path.canonicalString();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.doc = function (t) {\n          if (Wr(\"CollectionReference.doc\", arguments, 0, 1), 0 === arguments.length && (t = si.newId()), zr(\"CollectionReference.doc\", \"non-empty string\", 1, t), \"\" === t) throw new xr(Lr.INVALID_ARGUMENT, \"Document path must be a non-empty string\");\n          var e = Ti.fromString(t);\n          return Yc.forPath(this._query.path.child(e), this.firestore);\n        }, t.prototype.add = function (t) {\n          jr(\"CollectionReference.add\", arguments, 1), zr(\"CollectionReference.add\", \"object\", 1, t);\n          var e = this.doc();\n          return e.set(t).then(function () {\n            return e;\n          });\n        }, t;\n      }(Zc);\n\n      function nh(t, e) {\n        if (void 0 === e) return {\n          merge: !1\n        };\n        if (ri(t, e, [\"merge\", \"mergeFields\"]), Xr(t, \"boolean\", \"merge\", e.merge), Jr(t, \"mergeFields\", \"a string or a FieldPath\", e.mergeFields, function (t) {\n          return \"string\" == typeof t || t instanceof dc;\n        }), void 0 !== e.mergeFields && void 0 !== e.merge) throw new xr(Lr.INVALID_ARGUMENT, \"Invalid options passed to function \" + t + '(): You cannot specify both \"merge\" and \"mergeFields\".');\n        return e;\n      }\n\n      function rh(t, e) {\n        return void 0 === e ? {} : (ri(t, e, [\"serverTimestamps\"]), $r(t, 0, \"serverTimestamps\", e.serverTimestamps, [\"estimate\", \"previous\", \"none\"]), e);\n      }\n\n      function ih(t, e) {\n        Hr(t, \"object\", 1, e), e && (ri(t, e, [\"source\"]), $r(t, 0, \"source\", e.source, [\"default\", \"server\", \"cache\"]));\n      }\n\n      function oh(t, e, n) {\n        if (e instanceof Yc) {\n          if (e.firestore !== n) throw new xr(Lr.INVALID_ARGUMENT, \"Provided document reference is from a different Firestore instance.\");\n          return e;\n        }\n\n        throw ii(t, \"DocumentReference\", 1, e);\n      }\n\n      var ah = qr(Wc, \"Use firebase.firestore() instead.\"),\n          sh = qr(zc, \"Use firebase.firestore().runTransaction() instead.\"),\n          uh = qr(Hc, \"Use firebase.firestore().batch() instead.\"),\n          ch = qr(Yc, \"Use firebase.firestore().doc() instead.\"),\n          hh = qr(Jc),\n          lh = qr($c),\n          fh = qr(Zc),\n          ph = qr(th),\n          dh = qr(eh, \"Use firebase.firestore().collection() instead.\"),\n          mh = {\n        Firestore: ah,\n        GeoPoint: fu,\n        Timestamp: Fi,\n        Blob: yi,\n        Transaction: sh,\n        WriteBatch: uh,\n        DocumentReference: ch,\n        DocumentSnapshot: hh,\n        Query: fh,\n        QueryDocumentSnapshot: lh,\n        QuerySnapshot: ph,\n        CollectionReference: dh,\n        FieldPath: dc,\n        FieldValue: Rc,\n        setLogLevel: Wc.setLogLevel,\n        CACHE_SIZE_UNLIMITED: Kc\n      };\n\n      function yh(t) {\n        t.INTERNAL.registerService(\"firestore\", function (t) {\n          return new Wc(t);\n        }, function (t) {\n          Or(t && \"object\" == typeof t, \"shallowCopy() expects object parameter.\");\n          var e = {};\n\n          for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n\n          return e;\n        }(mh));\n      }\n\n      var gh = function () {\n        function t() {}\n\n        return t.prototype.addCallback = function (t) {}, t.prototype.shutdown = function () {}, t;\n      }(),\n          vh = \"ConnectivityMonitor\",\n          bh = function () {\n        function t() {\n          var t = this;\n          this.networkAvailableListener = function () {\n            return t.onNetworkAvailable();\n          }, this.networkUnavailableListener = function () {\n            return t.onNetworkUnavailable();\n          }, this.callbacks = [], this.configureNetworkMonitoring();\n        }\n\n        return t.prototype.addCallback = function (t) {\n          this.callbacks.push(t);\n        }, t.prototype.shutdown = function () {\n          window.removeEventListener(\"online\", this.networkAvailableListener), window.removeEventListener(\"offline\", this.networkUnavailableListener);\n        }, t.prototype.configureNetworkMonitoring = function () {\n          window.addEventListener(\"online\", this.networkAvailableListener), window.addEventListener(\"offline\", this.networkUnavailableListener);\n        }, t.prototype.onNetworkAvailable = function () {\n          Ar(vh, \"Network connectivity changed: AVAILABLE\");\n\n          for (var t = 0, e = this.callbacks; t < e.length; t++) {\n            (0, e[t])(0);\n          }\n        }, t.prototype.onNetworkUnavailable = function () {\n          Ar(vh, \"Network connectivity changed: UNAVAILABLE\");\n\n          for (var t = 0, e = this.callbacks; t < e.length; t++) {\n            (0, e[t])(1);\n          }\n        }, t.isAvailable = function () {\n          return \"undefined\" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;\n        }, t;\n      }(),\n          wh = function () {\n        function t(t) {\n          this.sendFn = t.sendFn, this.closeFn = t.closeFn;\n        }\n\n        return t.prototype.onOpen = function (t) {\n          Or(!this.wrappedOnOpen, \"Called onOpen on stream twice!\"), this.wrappedOnOpen = t;\n        }, t.prototype.onClose = function (t) {\n          Or(!this.wrappedOnClose, \"Called onClose on stream twice!\"), this.wrappedOnClose = t;\n        }, t.prototype.onMessage = function (t) {\n          Or(!this.wrappedOnMessage, \"Called onMessage on stream twice!\"), this.wrappedOnMessage = t;\n        }, t.prototype.close = function () {\n          this.closeFn();\n        }, t.prototype.send = function (t) {\n          this.sendFn(t);\n        }, t.prototype.callOnOpen = function () {\n          Or(void 0 !== this.wrappedOnOpen, \"Cannot call onOpen because no callback was set\"), this.wrappedOnOpen();\n        }, t.prototype.callOnClose = function (t) {\n          Or(void 0 !== this.wrappedOnClose, \"Cannot call onClose because no callback was set\"), this.wrappedOnClose(t);\n        }, t.prototype.callOnMessage = function (t) {\n          Or(void 0 !== this.wrappedOnMessage, \"Cannot call onMessage because no callback was set\"), this.wrappedOnMessage(t);\n        }, t;\n      }(),\n          Eh = \"Connection\",\n          Sh = {\n        BatchGetDocuments: \"batchGet\",\n        Commit: \"commit\"\n      },\n          Th = \"gl-js/ fire/\" + Ir,\n          Ih = function () {\n        function t(t) {\n          this.databaseId = t.databaseId;\n          var e = t.ssl ? \"https\" : \"http\";\n          this.baseUrl = e + \"://\" + t.host, this.forceLongPolling = t.forceLongPolling;\n        }\n\n        return t.prototype.modifyHeadersForRequest = function (t, e) {\n          if (e) for (var n in e.authHeaders) e.authHeaders.hasOwnProperty(n) && (t[n] = e.authHeaders[n]);\n          t[\"X-Goog-Api-Client\"] = Th;\n        }, t.prototype.invokeRPC = function (o, a, s) {\n          var u = this,\n              c = this.makeUrl(o);\n          return new Promise(function (n, r) {\n            var i = new Tr();\n            i.listenOnce(Er.COMPLETE, function () {\n              try {\n                switch (i.getLastErrorCode()) {\n                  case wr.NO_ERROR:\n                    var t = i.getResponseJson();\n                    Ar(Eh, \"XHR received:\", JSON.stringify(t)), n(t);\n                    break;\n\n                  case wr.TIMEOUT:\n                    Ar(Eh, 'RPC \"' + o + '\" timed out'), r(new xr(Lr.DEADLINE_EXCEEDED, \"Request time out\"));\n                    break;\n\n                  case wr.HTTP_ERROR:\n                    var e = i.getStatus();\n                    Ar(Eh, 'RPC \"' + o + '\" failed with status:', e, \"response text:\", i.getResponseText()), 0 < e ? r(new xr(function (t) {\n                      switch (t) {\n                        case 200:\n                          return Lr.OK;\n\n                        case 400:\n                          return Lr.INVALID_ARGUMENT;\n\n                        case 401:\n                          return Lr.UNAUTHENTICATED;\n\n                        case 403:\n                          return Lr.PERMISSION_DENIED;\n\n                        case 404:\n                          return Lr.NOT_FOUND;\n\n                        case 409:\n                          return Lr.ABORTED;\n\n                        case 416:\n                          return Lr.OUT_OF_RANGE;\n\n                        case 429:\n                          return Lr.RESOURCE_EXHAUSTED;\n\n                        case 499:\n                          return Lr.CANCELLED;\n\n                        case 500:\n                          return Lr.UNKNOWN;\n\n                        case 501:\n                          return Lr.UNIMPLEMENTED;\n\n                        case 503:\n                          return Lr.UNAVAILABLE;\n\n                        case 504:\n                          return Lr.DEADLINE_EXCEEDED;\n\n                        default:\n                          return 200 <= t && t < 300 ? Lr.OK : 400 <= t && t < 500 ? Lr.FAILED_PRECONDITION : 500 <= t && t < 600 ? Lr.INTERNAL : Lr.UNKNOWN;\n                      }\n                    }(e), \"Server responded with status \" + i.getStatusText())) : (Ar(Eh, 'RPC \"' + o + '\" failed'), r(new xr(Lr.UNAVAILABLE, \"Connection failed.\")));\n                    break;\n\n                  default:\n                    Mr('RPC \"' + o + '\" failed with unanticipated webchannel error ' + i.getLastErrorCode() + \": \" + i.getLastError() + \", giving up.\");\n                }\n              } finally {\n                Ar(Eh, 'RPC \"' + o + '\" completed.');\n              }\n            });\n            var t = JSON.stringify(a);\n            Ar(Eh, \"XHR sending: \", c + \" \" + t);\n            var e = {\n              \"Content-Type\": \"text/plain\"\n            };\n            u.modifyHeadersForRequest(e, s), i.send(c, \"POST\", t, e, 15);\n          });\n        }, t.prototype.invokeStreamingRPC = function (t, e, n) {\n          return this.invokeRPC(t, e, n);\n        }, t.prototype.openStream = function (t, e) {\n          var n = [this.baseUrl, \"/\", \"google.firestore.v1.Firestore\", \"/\", t, \"/channel\"],\n              r = br(),\n              i = {\n            backgroundChannelTest: !0,\n            httpSessionIdParam: \"gsessionid\",\n            initMessageHeaders: {},\n            messageUrlParams: {\n              database: \"projects/\" + this.databaseId.projectId + \"/databases/\" + this.databaseId.database\n            },\n            sendRawJson: !0,\n            supportsCrossDomainXhr: !0,\n            internalChannelParams: {\n              forwardChannelRequestTimeoutMs: 6e5\n            },\n            forceLongPolling: this.forceLongPolling\n          };\n          this.modifyHeadersForRequest(i.initMessageHeaders, e), \"object\" == typeof navigator && \"ReactNative\" === navigator.product || (i.httpHeadersOverwriteParam = \"$httpHeaders\");\n          var o = n.join(\"\");\n          Ar(Eh, \"Creating WebChannel: \" + o + \" \" + i);\n\n          var s = r.createWebChannel(o, i),\n              a = !1,\n              u = !1,\n              c = new wh({\n            sendFn: function (t) {\n              u ? Ar(Eh, \"Not sending because WebChannel is closed:\", t) : (a || (Ar(Eh, \"Opening WebChannel transport.\"), s.open(), a = !0), Ar(Eh, \"WebChannel sending:\", t), s.send(t));\n            },\n            closeFn: function () {\n              return s.close();\n            }\n          }),\n              h = function (t, e) {\n            s.listen(t, function (t) {\n              try {\n                e(t);\n              } catch (t) {\n                setTimeout(function () {\n                  throw t;\n                }, 0);\n              }\n            });\n          };\n\n          return h(Sr.EventType.OPEN, function () {\n            u || Ar(Eh, \"WebChannel transport opened.\");\n          }), h(Sr.EventType.CLOSE, function () {\n            u || (u = !0, Ar(Eh, \"WebChannel transport closed\"), c.callOnClose());\n          }), h(Sr.EventType.ERROR, function (t) {\n            u || (u = !0, Ar(Eh, \"WebChannel transport errored:\", t), c.callOnClose(new xr(Lr.UNAVAILABLE, \"The operation could not be completed\")));\n          }), h(Sr.EventType.MESSAGE, function (t) {\n            if (!u) {\n              var e = t.data[0];\n              Or(!!e, \"Got a webchannel message without data.\");\n              var n = e,\n                  r = n.error || n[0] && n[0].error;\n\n              if (r) {\n                Ar(Eh, \"WebChannel received error:\", r);\n\n                var i = r.status,\n                    o = function (t) {\n                  var e = Bs[t];\n                  if (void 0 !== e) return Gs(e);\n                }(i),\n                    a = r.message;\n\n                void 0 === o && (o = Lr.INTERNAL, a = \"Unknown error status: \" + i + \" with message \" + r.message), u = !0, c.callOnClose(new xr(o, a)), s.close();\n              } else Ar(Eh, \"WebChannel received:\", e), c.callOnMessage(e);\n            }\n          }), setTimeout(function () {\n            c.callOnOpen();\n          }, 0), c;\n        }, t.prototype.makeUrl = function (t) {\n          var e = Sh[t];\n          Or(void 0 !== e, \"Unknown REST mapping for: \" + t);\n          var n = [this.baseUrl, \"/\", \"v1\"];\n          return n.push(\"/projects/\"), n.push(this.databaseId.projectId), n.push(\"/databases/\"), n.push(this.databaseId.database), n.push(\"/documents\"), n.push(\":\"), n.push(e), n.join(\"\");\n        }, t;\n      }(),\n          Ch = function () {\n        function t() {\n          this.emptyByteString = \"\", this.base64Available = \"undefined\" != typeof atob;\n        }\n\n        return Object.defineProperty(t.prototype, \"document\", {\n          get: function () {\n            return \"undefined\" != typeof document ? document : null;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"window\", {\n          get: function () {\n            return \"undefined\" != typeof window ? window : null;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.loadConnection = function (t) {\n          return Promise.resolve(new Ih(t));\n        }, t.prototype.newConnectivityMonitor = function () {\n          return bh.isAvailable() ? new bh() : new gh();\n        }, t.prototype.newSerializer = function (t) {\n          return new Vu(t, {\n            useProto3Json: !0\n          });\n        }, t.prototype.formatJSON = function (t) {\n          return JSON.stringify(t);\n        }, t.prototype.atob = function (t) {\n          return atob(t);\n        }, t.prototype.btoa = function (t) {\n          return btoa(t);\n        }, t;\n      }();\n\n      _r.setPlatform(new Ch()), yh(Dh);\n    }).apply(this, arguments);\n  } catch (t) {\n    throw console.error(t), new Error(\"Cannot instantiate firebase-firestore - be sure to load firebase-app.js first.\");\n  }\n});","map":null,"metadata":{},"sourceType":"script"}