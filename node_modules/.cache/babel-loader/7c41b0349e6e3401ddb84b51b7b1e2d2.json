{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 Google LLC\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst grpcProtoLoader = require(\"@grpc/proto-loader\");\n\nconst fs = require(\"fs\");\n\nconst google_auth_library_1 = require(\"google-auth-library\");\n\nconst grpc = require(\"@grpc/grpc-js\");\n\nconst path = require(\"path\");\n\nconst protobuf = require(\"protobufjs\");\n\nconst semver = require(\"semver\");\n\nconst walk = require(\"walkdir\");\n\nconst gax = require(\"./gax\");\n\nconst googleProtoFilesDir = path.join(__dirname, '..', '..', 'protos'); // INCLUDE_DIRS is passed to @grpc/proto-loader\n\nconst INCLUDE_DIRS = [];\nINCLUDE_DIRS.push(googleProtoFilesDir); // COMMON_PROTO_FILES logic is here for protobufjs loads (see\n// GoogleProtoFilesRoot below)\n\nconst COMMON_PROTO_FILES = walk.sync(googleProtoFilesDir).filter(f => path.extname(f) === '.proto').map(f => path.normalize(f).substring(googleProtoFilesDir.length + 1));\n\nclass ClientStub extends grpc.Client {}\n\nexports.ClientStub = ClientStub;\n\nclass GrpcClient {\n  /**\n   * A class which keeps the context of gRPC and auth for the gRPC.\n   *\n   * @param {Object=} options - The optional parameters. It will be directly\n   *   passed to google-auth-library library, so parameters like keyFile or\n   *   credentials will be valid.\n   * @param {Object=} options.auth - An instance of google-auth-library.\n   *   When specified, this auth instance will be used instead of creating\n   *   a new one.\n   * @param {Object=} options.grpc - When specified, this will be used\n   *   for the 'grpc' module in this context. By default, it will load the grpc\n   *   module in the standard way.\n   * @param {Function=} options.promise - A constructor for a promise that\n   * implements the ES6 specification of promise. If not provided, native\n   * promises will be used.\n   * @constructor\n   */\n  constructor(options = {}) {\n    this.auth = options.auth || new google_auth_library_1.GoogleAuth(options);\n    this.promise = options.promise || Promise;\n\n    if ('grpc' in options) {\n      this.grpc = options.grpc;\n      this.grpcVersion = '';\n    } else {\n      if (semver.gte(process.version, '8.13.0')) {\n        this.grpc = grpc;\n        this.grpcVersion = require('@grpc/grpc-js/package.json').version;\n      } else {\n        const errorMessage = 'To use @grpc/grpc-js you must run your code on Node.js v8.13.0 or newer. Please see README if you need to use an older version. ' + 'https://github.com/googleapis/gax-nodejs/blob/master/README.md';\n        throw new Error(errorMessage);\n      }\n    }\n  }\n  /**\n   * Creates a gRPC credentials. It asks the auth data if necessary.\n   * @private\n   * @param {Object} opts - options values for configuring credentials.\n   * @param {Object=} opts.sslCreds - when specified, this is used instead\n   *   of default channel credentials.\n   * @return {Promise} The promise which will be resolved to the gRPC credential.\n   */\n\n\n  async _getCredentials(opts) {\n    if (opts.sslCreds) {\n      return opts.sslCreds;\n    }\n\n    const grpc = this.grpc;\n    const sslCreds = grpc.credentials.createSsl();\n    const client = await this.auth.getClient();\n    const credentials = grpc.credentials.combineChannelCredentials(sslCreds, grpc.credentials.createFromGoogleCredential(client));\n    return credentials;\n  }\n  /**\n   * Loads the gRPC service from the proto file(s) at the given path and with the\n   * given options.\n   * @param filename The path to the proto file(s).\n   * @param options Options for loading the proto file.\n   */\n\n\n  loadFromProto(filename, options) {\n    const packageDef = grpcProtoLoader.loadSync(filename, options);\n    return this.grpc.loadPackageDefinition(packageDef);\n  }\n  /**\n   * Load grpc proto service from a filename hooking in googleapis common protos\n   * when necessary.\n   * @param {String} protoPath - The directory to search for the protofile.\n   * @param {String|String[]} filename - The filename(s) of the proto(s) to be loaded.\n   * @return {Object<string, *>} The gRPC loaded result (the toplevel namespace\n   *   object).\n   */\n\n\n  loadProto(protoPath, filename) {\n    if (Array.isArray(filename) && filename.length === 0) {\n      return {};\n    } // This set of @grpc/proto-loader options\n    // 'closely approximates the existing behavior of grpc.load'\n\n\n    const includeDirs = INCLUDE_DIRS.slice();\n    includeDirs.unshift(protoPath);\n    const options = {\n      keepCase: false,\n      longs: String,\n      enums: String,\n      defaults: true,\n      oneofs: true,\n      includeDirs\n    };\n    return this.loadFromProto(filename, options);\n  }\n\n  static _resolveFile(protoPath, filename) {\n    if (fs.existsSync(path.join(protoPath, filename))) {\n      return path.join(protoPath, filename);\n    } else if (COMMON_PROTO_FILES.indexOf(filename) > -1) {\n      return path.join(googleProtoFilesDir, filename);\n    }\n\n    throw new Error(filename + ' could not be found in ' + protoPath);\n  }\n\n  metadataBuilder(headers) {\n    const Metadata = this.grpc.Metadata;\n    const baseMetadata = new Metadata(); // tslint:disable-next-line forin\n\n    for (const key in headers) {\n      const value = headers[key];\n\n      if (Array.isArray(value)) {\n        value.forEach(v => baseMetadata.add(key, v));\n      } else {\n        baseMetadata.set(key, \"\".concat(value));\n      }\n    }\n\n    return function buildMetadata(abTests, moreHeaders) {\n      // TODO: bring the A/B testing info into the metadata.\n      let copied = false;\n      let metadata = baseMetadata;\n\n      if (moreHeaders) {\n        for (const key in moreHeaders) {\n          if (key.toLowerCase() !== 'x-goog-api-client' && moreHeaders.hasOwnProperty(key)) {\n            if (!copied) {\n              copied = true;\n              metadata = metadata.clone();\n            }\n\n            const value = moreHeaders[key];\n\n            if (Array.isArray(value)) {\n              value.forEach(v => metadata.add(key, v));\n            } else {\n              metadata.set(key, \"\".concat(value));\n            }\n          }\n        }\n      }\n\n      return metadata;\n    };\n  }\n  /**\n   * A wrapper of {@link constructSettings} function under the gRPC context.\n   *\n   * Most of parameters are common among constructSettings, please take a look.\n   * @param {string} serviceName - The fullly-qualified name of the service.\n   * @param {Object} clientConfig - A dictionary of the client config.\n   * @param {Object} configOverrides - A dictionary of overriding configs.\n   * @param {Object} headers - A dictionary of additional HTTP header name to\n   *   its value.\n   * @return {Object} A mapping of method names to CallSettings.\n   */\n\n\n  constructSettings(serviceName, clientConfig, configOverrides, headers) {\n    return gax.constructSettings(serviceName, clientConfig, configOverrides, this.grpc.status, {\n      metadataBuilder: this.metadataBuilder(headers)\n    }, this.promise);\n  }\n  /**\n   * Creates a gRPC stub with current gRPC and auth.\n   * @param {function} CreateStub - The constructor function of the stub.\n   * @param {Object} options - The optional arguments to customize\n   *   gRPC connection. This options will be passed to the constructor of\n   *   gRPC client too.\n   * @param {string} options.servicePath - The name of the server of the service.\n   * @param {number} options.port - The port of the service.\n   * @param {grpcTypes.ClientCredentials=} options.sslCreds - The credentials to be used\n   *   to set up gRPC connection.\n   * @return {Promise} A promse which resolves to a gRPC stub instance.\n   */\n  // tslint:disable-next-line variable-name\n\n\n  async createStub(CreateStub, options) {\n    const serviceAddress = options.servicePath + ':' + options.port;\n    const creds = await this._getCredentials(options);\n    const grpcOptions = {};\n    Object.keys(options).forEach(key => {\n      if (key.startsWith('grpc.')) {\n        grpcOptions[key.replace(/^grpc\\./, '')] = options[key];\n      }\n    });\n    const stub = new CreateStub(serviceAddress, creds, grpcOptions);\n    return stub;\n  }\n  /**\n   * Creates a 'bytelength' function for a given proto message class.\n   *\n   * See {@link BundleDescriptor} about the meaning of the return value.\n   *\n   * @param {function} message - a constructor function that is generated by\n   *   protobuf.js. Assumes 'encoder' field in the message.\n   * @return {function(Object):number} - a function to compute the byte length\n   *   for an object.\n   */\n\n\n  static createByteLengthFunction(message) {\n    return function getByteLength(obj) {\n      return message.encode(obj).finish().length;\n    };\n  }\n\n}\n\nexports.GrpcClient = GrpcClient;\n\nclass GoogleProtoFilesRoot extends protobuf.Root {\n  constructor(...args) {\n    super(...args);\n  } // Causes the loading of an included proto to check if it is a common\n  // proto. If it is a common proto, use the bundled proto.\n\n\n  resolvePath(originPath, includePath) {\n    originPath = path.normalize(originPath);\n    includePath = path.normalize(includePath); // Fully qualified paths don't need to be resolved.\n\n    if (path.isAbsolute(includePath)) {\n      if (!fs.existsSync(includePath)) {\n        throw new Error('The include `' + includePath + '` was not found.');\n      }\n\n      return includePath;\n    }\n\n    if (COMMON_PROTO_FILES.indexOf(includePath) > -1) {\n      return path.join(googleProtoFilesDir, includePath);\n    }\n\n    return GoogleProtoFilesRoot._findIncludePath(originPath, includePath);\n  }\n\n  static _findIncludePath(originPath, includePath) {\n    originPath = path.normalize(originPath);\n    includePath = path.normalize(includePath);\n    let current = originPath;\n    let found = fs.existsSync(path.join(current, includePath));\n\n    while (!found && current.length > 0) {\n      current = current.substring(0, current.lastIndexOf(path.sep));\n      found = fs.existsSync(path.join(current, includePath));\n    }\n\n    if (!found) {\n      throw new Error('The include `' + includePath + '` was not found.');\n    }\n\n    return path.join(current, includePath);\n  }\n\n}\n\nexports.GoogleProtoFilesRoot = GoogleProtoFilesRoot;","map":null,"metadata":{},"sourceType":"script"}