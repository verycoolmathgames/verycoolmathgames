{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst convert_1 = require(\"./convert\");\n\nconst field_value_1 = require(\"./field-value\");\n\nconst field_value_2 = require(\"./field-value\");\n\nconst geo_point_1 = require(\"./geo-point\");\n\nconst index_1 = require(\"./index\");\n\nconst path_1 = require(\"./path\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n/**\n * The maximum depth of a Firestore object.\n *\n * @private\n */\n\n\nconst MAX_DEPTH = 20;\n/**\n * Serializer that is used to convert between JavaScript types and their\n * Firestore Protobuf representation.\n *\n * @private\n */\n\nclass Serializer {\n  constructor(firestore) {\n    // Instead of storing the `firestore` object, we store just a reference to\n    // its `.doc()` method. This avoid a circular reference, which breaks\n    // JSON.stringify().\n    this.createReference = path => firestore.doc(path); // tslint:disable-next-line deprecation\n\n\n    if (firestore._settings.timestampsInSnapshots === undefined) {\n      this.timestampsInSnapshots = true;\n    } else {\n      // tslint:disable-next-line deprecation\n      this.timestampsInSnapshots = firestore._settings.timestampsInSnapshots;\n    }\n  }\n  /**\n   * Encodes a JavaScript object into the Firestore 'Fields' representation.\n   *\n   * @private\n   * @param obj The object to encode.\n   * @returns The Firestore 'Fields' representation\n   */\n\n\n  encodeFields(obj) {\n    const fields = {};\n\n    for (const prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        const val = this.encodeValue(obj[prop]);\n\n        if (val) {\n          fields[prop] = val;\n        }\n      }\n    }\n\n    return fields;\n  }\n  /**\n   * Encodes a JavaScript value into the Firestore 'Value' representation.\n   *\n   * @private\n   * @param val The object to encode\n   * @returns The Firestore Proto or null if we are deleting a field.\n   */\n\n\n  encodeValue(val) {\n    if (val instanceof field_value_1.FieldTransform) {\n      return null;\n    }\n\n    if (typeof val === 'string') {\n      return {\n        stringValue: val\n      };\n    }\n\n    if (typeof val === 'boolean') {\n      return {\n        booleanValue: val\n      };\n    }\n\n    if (typeof val === 'number') {\n      if (Number.isSafeInteger(val)) {\n        return {\n          integerValue: val\n        };\n      } else {\n        return {\n          doubleValue: val\n        };\n      }\n    }\n\n    if (val instanceof Date) {\n      const timestamp = timestamp_1.Timestamp.fromDate(val);\n      return {\n        timestampValue: {\n          seconds: timestamp.seconds,\n          nanos: timestamp.nanoseconds\n        }\n      };\n    }\n\n    if (val === null) {\n      return {\n        nullValue: 'NULL_VALUE'\n      };\n    }\n\n    if (val instanceof Buffer || val instanceof Uint8Array) {\n      return {\n        bytesValue: val\n      };\n    }\n\n    if (util_1.isObject(val)) {\n      const toProto = val['toProto'];\n\n      if (typeof toProto === 'function') {\n        return toProto.bind(val)();\n      }\n    }\n\n    if (val instanceof Array) {\n      const array = {\n        arrayValue: {}\n      };\n\n      if (val.length > 0) {\n        array.arrayValue.values = [];\n\n        for (let i = 0; i < val.length; ++i) {\n          const enc = this.encodeValue(val[i]);\n\n          if (enc) {\n            array.arrayValue.values.push(enc);\n          }\n        }\n      }\n\n      return array;\n    }\n\n    if (typeof val === 'object' && isPlainObject(val)) {\n      const map = {\n        mapValue: {}\n      }; // If we encounter an empty object, we always need to send it to make sure\n      // the server creates a map entry.\n\n      if (!util_1.isEmpty(val)) {\n        map.mapValue.fields = this.encodeFields(val);\n\n        if (util_1.isEmpty(map.mapValue.fields)) {\n          return null;\n        }\n      }\n\n      return map;\n    }\n\n    throw new Error(\"Cannot encode value: \".concat(val));\n  }\n  /**\n   * Decodes a single Firestore 'Value' Protobuf.\n   *\n   * @private\n   * @param proto A Firestore 'Value' Protobuf.\n   * @returns The converted JS type.\n   */\n\n\n  decodeValue(proto) {\n    const valueType = convert_1.detectValueType(proto);\n\n    switch (valueType) {\n      case 'stringValue':\n        {\n          return proto.stringValue;\n        }\n\n      case 'booleanValue':\n        {\n          return proto.booleanValue;\n        }\n\n      case 'integerValue':\n        {\n          return Number(proto.integerValue);\n        }\n\n      case 'doubleValue':\n        {\n          return Number(proto.doubleValue);\n        }\n\n      case 'timestampValue':\n        {\n          const timestamp = timestamp_1.Timestamp.fromProto(proto.timestampValue);\n          return this.timestampsInSnapshots ? timestamp : timestamp.toDate();\n        }\n\n      case 'referenceValue':\n        {\n          const resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);\n          return this.createReference(resourcePath.relativeName);\n        }\n\n      case 'arrayValue':\n        {\n          const array = [];\n\n          if (Array.isArray(proto.arrayValue.values)) {\n            for (const value of proto.arrayValue.values) {\n              array.push(this.decodeValue(value));\n            }\n          }\n\n          return array;\n        }\n\n      case 'nullValue':\n        {\n          return null;\n        }\n\n      case 'mapValue':\n        {\n          const obj = {};\n          const fields = proto.mapValue.fields;\n\n          for (const prop in fields) {\n            if (fields.hasOwnProperty(prop)) {\n              obj[prop] = this.decodeValue(fields[prop]);\n            }\n          }\n\n          return obj;\n        }\n\n      case 'geoPointValue':\n        {\n          return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);\n        }\n\n      case 'bytesValue':\n        {\n          return proto.bytesValue;\n        }\n\n      default:\n        {\n          throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));\n        }\n    }\n  }\n\n}\n\nexports.Serializer = Serializer;\n/**\n * Verifies that 'obj' is a plain JavaScript object that can be encoded as a\n * 'Map' in Firestore.\n *\n * @private\n * @param input The argument to verify.\n * @returns 'true' if the input can be a treated as a plain object.\n */\n\nfunction isPlainObject(input) {\n  return util_1.isObject(input) && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null);\n}\n\nexports.isPlainObject = isPlainObject;\n/**\n * Validates a JavaScript value for usage as a Firestore value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value JavaScript value to validate.\n * @param desc A description of the expected type.\n * @param path The field path to validate.\n * @param options Validation options\n * @param level The current depth of the traversal. This is used to decide\n * whether deletes are allowed in conjunction with `allowDeletes: root`.\n * @param inArray Whether we are inside an array.\n * @throws when the object is invalid.\n */\n\nfunction validateUserInput(arg, value, desc, options, path, level, inArray) {\n  if (path && path.size > MAX_DEPTH) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" Input object is deeper than \").concat(MAX_DEPTH, \" levels or contains a cycle.\"));\n  }\n\n  options = options || {};\n  level = level || 0;\n  inArray = inArray || false;\n  const fieldPathMessage = path ? \" (found in field \".concat(path, \")\") : '';\n\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; ++i) {\n      validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1,\n      /* inArray= */\n      true);\n    }\n  } else if (isPlainObject(value)) {\n    for (const prop in value) {\n      if (value.hasOwnProperty(prop)) {\n        validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);\n      }\n    }\n  } else if (value === undefined) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" Cannot use \\\"undefined\\\" as a Firestore value\").concat(fieldPathMessage, \".\"));\n  } else if (value instanceof field_value_2.DeleteTransform) {\n    if (inArray) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() cannot be used inside of an array\").concat(fieldPathMessage, \".\"));\n    } else if (options.allowDeletes === 'root' && level !== 0 || options.allowDeletes === 'none') {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() must appear at the top-level and can only be used in update() or set() with {merge:true}\").concat(fieldPathMessage, \".\"));\n    }\n  } else if (value instanceof field_value_1.FieldTransform) {\n    if (inArray) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() cannot be used inside of an array\").concat(fieldPathMessage, \".\"));\n    } else if (!options.allowTransforms) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() can only be used in set(), create() or update()\").concat(fieldPathMessage, \".\"));\n    }\n  } else if (value instanceof path_1.FieldPath) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" Cannot use object of type \\\"FieldPath\\\" as a Firestore value\").concat(fieldPathMessage, \".\"));\n  } else if (value instanceof index_1.DocumentReference) {// Ok.\n  } else if (value instanceof geo_point_1.GeoPoint) {// Ok.\n  } else if (value instanceof timestamp_1.Timestamp || value instanceof Date) {// Ok.\n  } else if (value instanceof Buffer || value instanceof Uint8Array) {// Ok.\n  } else if (value === null) {// Ok.\n  } else if (typeof value === 'object') {\n    throw new Error(validate_1.customObjectMessage(arg, value, path));\n  }\n}\n\nexports.validateUserInput = validateUserInput;","map":null,"metadata":{},"sourceType":"script"}