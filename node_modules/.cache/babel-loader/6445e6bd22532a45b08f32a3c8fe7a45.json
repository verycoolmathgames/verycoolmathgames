{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 Google LLC\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Path template utility.\n */\n\nconst has = require(\"lodash.has\");\n\nconst util = require(\"util\");\n\nconst extras = require(\"./parserExtras\");\n\nconst parser = require('./pathTemplateParser');\n\nclass PathTemplate {\n  get size() {\n    return this.parseResult.size;\n  }\n\n  get segments() {\n    return this.parseResult.segments;\n  }\n  /**\n   * @param {String} data the of the template\n   *\n   * @constructor\n   */\n\n\n  constructor(data) {\n    this.parseResult = extras.finishParse(parser.parse(data));\n  }\n  /**\n   * Matches a fully-qualified path template string.\n   *\n   * @param {String} path a fully-qualified path template string\n   * @return {Object} contains const names matched to binding values\n   * @throws {TypeError} if path can't be matched to this template\n   */\n\n\n  match(path) {\n    const pathSegments = path.split('/');\n    const bindings = {};\n    let segmentCount = this.size;\n    let current;\n    let index = 0;\n    this.segments.forEach(segment => {\n      if (index > pathSegments.length) {\n        return;\n      }\n\n      if (segment.kind === extras.BINDING) {\n        current = segment.literal;\n      } else if (segment.kind === extras.TERMINAL) {\n        if (segment.literal === '*') {\n          bindings[current] = pathSegments[index];\n          index += 1;\n        } else if (segment.literal === '**') {\n          const size = pathSegments.length - segmentCount + 1;\n          segmentCount += size - 1;\n          bindings[current] = pathSegments.slice(index, index + size).join('/');\n          index += size;\n        } else if (segment.literal === pathSegments[index]) {\n          index += 1;\n        } else {\n          const msg = util.format(\"mismatched literal (index=%d): '%s' != '%s'\", index, segment.literal, pathSegments[index]);\n          throw new TypeError(msg);\n        }\n      }\n    });\n\n    if (index !== pathSegments.length || index !== segmentCount) {\n      const msg = util.format('match error: could not instantiate a path template from %s', path);\n      throw new TypeError(msg);\n    }\n\n    return bindings;\n  }\n  /**\n   * Renders a path template using the provided bindings.\n   *\n   * @param {Object} bindings a mapping of const names to binding strings\n   * @return {String} a rendered representation of the path template\n   * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n   *   parsed\n   */\n\n\n  render(bindings) {\n    const out = [];\n    let inABinding = false;\n    this.segments.forEach(segment => {\n      if (segment.kind === extras.BINDING) {\n        if (!has(bindings, segment.literal)) {\n          const msg = util.format('Value for key %s is not provided in %s', segment.literal, bindings);\n          throw new TypeError(msg);\n        }\n\n        const tmp = new PathTemplate(bindings[segment.literal]);\n        Array.prototype.push.apply(out, tmp.segments);\n        inABinding = true;\n      } else if (segment.kind === extras.END_BINDING) {\n        inABinding = false;\n      } else if (inABinding) {\n        return;\n      } else {\n        out.push(segment);\n      }\n    });\n    const result = formatSegments(out);\n    this.match(result);\n    return result;\n  }\n  /**\n   * Renders the path template.\n   *\n   * @return {string} contains const names matched to binding values\n   */\n\n\n  inspect() {\n    return formatSegments(this.segments);\n  }\n\n}\n\nexports.PathTemplate = PathTemplate;\n/**\n * Creates the string representattion for the segments.\n * @param {Object[]} segments - The array of segments.\n * @return {string} - A string representing segments in the path template\n *   format.\n */\n\nfunction formatSegments(segments) {\n  let out = '';\n  let slash = true;\n  segments.forEach(segment => {\n    if (segment.kind === extras.TERMINAL) {\n      if (slash) {\n        out += '/';\n      }\n\n      out += segment.literal;\n      return;\n    }\n\n    slash = true;\n\n    if (segment.kind === extras.BINDING) {\n      out += '/{' + segment.literal + '=';\n      slash = false;\n    } else {\n      out += segment.literal + '}';\n    }\n  });\n  return out.substring(1);\n}","map":null,"metadata":{},"sourceType":"script"}