{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst document_1 = require(\"./document\");\n\nconst logger_1 = require(\"./logger\");\n\nconst path_1 = require(\"./path\");\n\nconst reference_1 = require(\"./reference\");\n\nconst serializer_1 = require(\"./serializer\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n/*!\n * Google Cloud Functions terminates idle connections after two minutes. After\n * longer periods of idleness, we issue transactional commits to allow for\n * retries.\n */\n\n\nconst GCF_IDLE_TIMEOUT_MS = 110 * 1000;\n/**\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\n * updates(), and creates().\n *\n * @class\n */\n\nclass WriteResult {\n  /**\n   * @hideconstructor\n   *\n   * @param _writeTime The time of the corresponding document write.\n   */\n  constructor(_writeTime) {\n    this._writeTime = _writeTime;\n  }\n  /**\n   * The write time as set by the Firestore servers.\n   *\n   * @type {Timestamp}\n   * @name WriteResult#writeTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(writeResult => {\n   *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\n   * });\n   */\n\n\n  get writeTime() {\n    return this._writeTime;\n  }\n  /**\n   * Returns true if this `WriteResult` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return true if this `WriteResult` is equal to the provided value.\n   */\n\n\n  isEqual(other) {\n    return this === other || other instanceof WriteResult && this._writeTime.isEqual(other._writeTime);\n  }\n\n}\n\nexports.WriteResult = WriteResult;\n/**\n * A Firestore WriteBatch that can be used to atomically commit multiple write\n * operations at once.\n *\n * @class\n */\n\nclass WriteBatch {\n  /**\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   */\n  constructor(firestore) {\n    /**\n     * An array of write operations that are executed as part of the commit. The\n     * resulting `api.IWrite` will be sent to the backend.\n     * @private\n     */\n    this._ops = [];\n    this._committed = false;\n    this._firestore = firestore;\n    this._serializer = new serializer_1.Serializer(firestore);\n  }\n  /**\n   * Checks if this write batch has any pending operations.\n   *\n   * @private\n   */\n\n\n  get isEmpty() {\n    return this._ops.length === 0;\n  }\n  /**\n   * Throws an error if this batch has already been committed.\n   *\n   * @private\n   */\n\n\n  verifyNotCommitted() {\n    if (this._committed) {\n      throw new Error('Cannot modify a WriteBatch that has been committed.');\n    }\n  }\n  /**\n   * Create a document with the provided object values. This will fail the batch\n   * if a document exists at its location.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * created.\n   * @param {DocumentData} data The object to serialize as the document.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * writeBatch.create(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   */\n\n\n  create(documentRef, data) {\n    reference_1.validateDocumentReference('documentRef', documentRef);\n    validateDocumentData('data', data,\n    /* allowDeletes= */\n    false);\n    this.verifyNotCommitted();\n    const transform = document_1.DocumentTransform.fromObject(documentRef, data);\n    transform.validate();\n    const precondition = new document_1.Precondition({\n      exists: false\n    });\n\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromObject(documentRef, data);\n      const write = !document.isEmpty || transform.isEmpty ? document.toProto() : null;\n      return {\n        write,\n        transform: transform.toProto(this._serializer),\n        precondition: precondition.toProto()\n      };\n    };\n\n    this._ops.push(op);\n\n    return this;\n  }\n  /**\n   * Deletes a document from the database.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * deleted.\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the batch if the\n   * document doesn't exist or was last updated at a different time.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.delete(documentRef);\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   */\n\n\n  delete(documentRef, precondition) {\n    reference_1.validateDocumentReference('documentRef', documentRef);\n    validateDeletePrecondition('precondition', precondition, {\n      optional: true\n    });\n    this.verifyNotCommitted();\n    const conditions = new document_1.Precondition(precondition);\n\n    const op = () => {\n      return {\n        write: {\n          delete: documentRef.formattedName\n        },\n        precondition: conditions.toProto()\n      };\n    };\n\n    this._ops.push(op);\n\n    return this;\n  }\n  /**\n   * Write to the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}.\n   * If the document does not exist yet, it will be created. If you pass\n   * [SetOptions]{@link SetOptions}., the provided data can be merged\n   * into the existing document.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * set.\n   * @param {DocumentData} data The object to serialize as the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge - If true, set() merges the values\n   * specified in its data argument. Fields omitted from this set() call\n   * remain untouched.\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n   * set() only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.set(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   */\n\n\n  set(documentRef, data, options) {\n    validateSetOptions('options', options, {\n      optional: true\n    });\n    const mergeLeaves = options && options.merge === true;\n    const mergePaths = options && options.mergeFields;\n    reference_1.validateDocumentReference('documentRef', documentRef);\n    validateDocumentData('data', data,\n    /* allowDeletes= */\n    !!(mergePaths || mergeLeaves));\n    this.verifyNotCommitted();\n    let documentMask;\n\n    if (mergePaths) {\n      documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n      data = documentMask.applyTo(data);\n    }\n\n    const transform = document_1.DocumentTransform.fromObject(documentRef, data);\n    transform.validate();\n\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromObject(documentRef, data);\n\n      if (mergePaths) {\n        documentMask.removeFields(transform.fields);\n      } else {\n        documentMask = document_1.DocumentMask.fromObject(data);\n      }\n\n      const hasDocumentData = !document.isEmpty || !documentMask.isEmpty;\n      let write;\n\n      if (!mergePaths && !mergeLeaves) {\n        write = document.toProto();\n      } else if (hasDocumentData || transform.isEmpty) {\n        write = document.toProto();\n        write.updateMask = documentMask.toProto();\n      }\n\n      return {\n        write,\n        transform: transform.toProto(this._serializer)\n      };\n    };\n\n    this._ops.push(op);\n\n    return this;\n  }\n  /**\n   * Update fields of the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. If the document\n   * doesn't yet exist, the update fails and the entire batch will be rejected.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values. Nested fields can be\n   * updated by providing dot-separated field path strings or by providing\n   * FieldPath objects.\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * updated.\n   * @param {UpdateData|string|FieldPath} dataOrField An object\n   * containing the fields and values with which to update the document\n   * or the path of the first field to update.\n   * @param {\n   * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n   * An alternating list of field paths and values to update or a Precondition\n   * to restrict this update.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.update(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   */\n\n\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    validate_1.validateMinNumberOfArguments('WriteBatch.update', arguments, 2);\n    reference_1.validateDocumentReference('documentRef', documentRef);\n    this.verifyNotCommitted();\n    const updateMap = new Map();\n    let precondition = new document_1.Precondition({\n      exists: true\n    });\n    const argumentError = 'Update() requires either a single JavaScript ' + 'object or an alternating list of field/value pairs that can be ' + 'followed by an optional precondition.';\n    const usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n\n    if (usesVarargs) {\n      try {\n        for (let i = 1; i < arguments.length; i += 2) {\n          if (i === arguments.length - 1) {\n            validateUpdatePrecondition(i, arguments[i]);\n            precondition = new document_1.Precondition(arguments[i]);\n          } else {\n            path_1.validateFieldPath(i, arguments[i]); // Unlike the `validateMinNumberOfArguments` invocation above, this\n            // validation can be triggered both from `WriteBatch.update()` and\n            // `DocumentReference.update()`. Hence, we don't use the fully\n            // qualified API name in the error message.\n\n            validate_1.validateMinNumberOfArguments('update', arguments, i + 1);\n            const fieldPath = path_1.FieldPath.fromArgument(arguments[i]);\n            validateFieldValue(i, arguments[i + 1], fieldPath);\n            updateMap.set(fieldPath, arguments[i + 1]);\n          }\n        }\n      } catch (err) {\n        logger_1.logger('WriteBatch.update', null, 'Varargs validation failed:', err); // We catch the validation error here and re-throw to provide a better\n        // error message.\n\n        throw new Error(\"\".concat(argumentError, \" \").concat(err.message));\n      }\n    } else {\n      try {\n        validateUpdateMap('dataOrField', dataOrField);\n        validate_1.validateMaxNumberOfArguments('update', arguments, 3);\n        const data = dataOrField;\n        Object.keys(data).forEach(key => {\n          path_1.validateFieldPath(key, key);\n          updateMap.set(path_1.FieldPath.fromArgument(key), data[key]);\n        });\n\n        if (preconditionOrValues.length > 0) {\n          validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n          precondition = new document_1.Precondition(preconditionOrValues[0]);\n        }\n      } catch (err) {\n        logger_1.logger('WriteBatch.update', null, 'Non-varargs validation failed:', err); // We catch the validation error here and prefix the error with a custom\n        // message to describe the usage of update() better.\n\n        throw new Error(\"\".concat(argumentError, \" \").concat(err.message));\n      }\n    }\n\n    validateNoConflictingFields('dataOrField', updateMap);\n    const transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n    transform.validate();\n    const documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n      let write = null;\n\n      if (!document.isEmpty || !documentMask.isEmpty) {\n        write = document.toProto();\n        write.updateMask = documentMask.toProto();\n      }\n\n      return {\n        write,\n        transform: transform.toProto(this._serializer),\n        precondition: precondition.toProto()\n      };\n    };\n\n    this._ops.push(op);\n\n    return this;\n  }\n  /**\n   * Atomically commits all pending operations to the database and verifies all\n   * preconditions. Fails the entire write if any precondition is not met.\n   *\n   * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\n   * when this batch completes.\n   *\n   * @example\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.set(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   */\n\n\n  commit() {\n    return this.commit_();\n  }\n  /**\n   * Commit method that takes an optional transaction ID.\n   *\n   * @private\n   * @param commitOptions Options to use for this commit.\n   * @param commitOptions.transactionId The transaction ID of this commit.\n   * @param commitOptions.requestTag A unique client-assigned identifier for\n   * this request.\n   * @returns  A Promise that resolves when this batch completes.\n   */\n\n\n  async commit_(commitOptions) {\n    // Note: We don't call `verifyNotCommitted()` to allow for retries.\n    this._committed = true;\n    await this._firestore.initializeIfNeeded();\n    const explicitTransaction = commitOptions && commitOptions.transactionId;\n    const tag = commitOptions && commitOptions.requestTag || util_1.requestTag();\n    const database = this._firestore.formattedName;\n    const request = {\n      database\n    }; // On GCF, we periodically force transactional commits to allow for\n    // request retries in case GCF closes our backend connection.\n\n    if (!explicitTransaction && this._shouldCreateTransaction()) {\n      logger_1.logger('WriteBatch.commit', tag, 'Using transaction for commit');\n      return this._firestore.request('beginTransaction', request, tag, true).then(resp => {\n        return this.commit_({\n          transactionId: resp.transaction\n        });\n      });\n    }\n\n    const writes = this._ops.map(op => op());\n\n    request.writes = [];\n\n    for (const req of writes) {\n      assert(req.write || req.transform, 'Either a write or transform must be set');\n\n      if (req.precondition) {\n        (req.write || req.transform).currentDocument = req.precondition;\n      }\n\n      if (req.write) {\n        request.writes.push(req.write);\n      }\n\n      if (req.transform) {\n        request.writes.push(req.transform);\n      }\n    }\n\n    logger_1.logger('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n\n    if (explicitTransaction) {\n      request.transaction = explicitTransaction;\n    }\n\n    return this._firestore.request('commit', request, tag,\n    /* allowRetries= */\n    false).then(resp => {\n      const writeResults = [];\n\n      if (request.writes.length > 0) {\n        assert(Array.isArray(resp.writeResults) && request.writes.length === resp.writeResults.length, \"Expected one write result per operation, but got \".concat(resp.writeResults.length, \" results for \").concat(request.writes.length, \" operations.\"));\n        const commitTime = timestamp_1.Timestamp.fromProto(resp.commitTime);\n        let offset = 0;\n\n        for (let i = 0; i < writes.length; ++i) {\n          const writeRequest = writes[i]; // Don't return two write results for a write that contains a\n          // transform, as the fact that we have to split one write\n          // operation into two distinct write requests is an implementation\n          // detail.\n\n          if (writeRequest.write && writeRequest.transform) {\n            // The document transform is always sent last and produces the\n            // latest update time.\n            ++offset;\n          }\n\n          const writeResult = resp.writeResults[i + offset];\n          writeResults.push(new WriteResult(writeResult.updateTime ? timestamp_1.Timestamp.fromProto(writeResult.updateTime) : commitTime));\n        }\n      }\n\n      return writeResults;\n    });\n  }\n  /**\n   * Determines whether we should issue a transactional commit. On GCF, this\n   * happens after two minutes of idleness.\n   *\n   * @private\n   * @returns Whether to use a transaction.\n   */\n\n\n  _shouldCreateTransaction() {\n    if (!this._firestore._preferTransactions) {\n      return false;\n    }\n\n    if (this._firestore._lastSuccessfulRequest) {\n      const now = new Date().getTime();\n      return now - this._firestore._lastSuccessfulRequest > GCF_IDLE_TIMEOUT_MS;\n    }\n\n    return true;\n  }\n\n}\n\nexports.WriteBatch = WriteBatch;\n/**\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\n * and 'lastUpdateTime' use valid types.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate\n * @param allowExists Whether to allow the 'exists' preconditions.\n */\n\nfunction validatePrecondition(arg, value, allowExists) {\n  if (typeof value !== 'object' || value === null) {\n    throw new Error('Input is not an object.');\n  }\n\n  const precondition = value;\n  let conditions = 0;\n\n  if (precondition.exists !== undefined) {\n    ++conditions;\n\n    if (!allowExists) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" \\\"exists\\\" is not an allowed precondition.\"));\n    }\n\n    if (typeof precondition.exists !== 'boolean') {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" \\\"exists\\\" is not a boolean.'\"));\n    }\n  }\n\n  if (precondition.lastUpdateTime !== undefined) {\n    ++conditions;\n\n    if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" \\\"lastUpdateTime\\\" is not a Firestore Timestamp.\"));\n    }\n  }\n\n  if (conditions > 1) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" Input specifies more than one precondition.\"));\n  }\n}\n/**\n * Validates the use of 'value' as an update Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\n\n\nfunction validateUpdatePrecondition(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    validatePrecondition(arg, value,\n    /* allowExists= */\n    false);\n  }\n}\n/**\n * Validates the use of 'value' as a delete Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\n\n\nfunction validateDeletePrecondition(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    validatePrecondition(arg, value,\n    /* allowExists= */\n    true);\n  }\n}\n/**\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\n * boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n * @throws if the input is not a valid SetOptions object.\n */\n\n\nfunction validateSetOptions(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" Input is not an object.\"));\n    }\n\n    const setOptions = value;\n\n    if ('merge' in setOptions && typeof setOptions.merge !== 'boolean') {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" \\\"merge\\\" is not a boolean.\"));\n    }\n\n    if ('mergeFields' in setOptions) {\n      if (!Array.isArray(setOptions.mergeFields)) {\n        throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" \\\"mergeFields\\\" is not an array.\"));\n      }\n\n      for (let i = 0; i < setOptions.mergeFields.length; ++i) {\n        try {\n          path_1.validateFieldPath(i, setOptions.mergeFields[i]);\n        } catch (err) {\n          throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" \\\"mergeFields\\\" is not valid: \").concat(err.message));\n        }\n      }\n    }\n\n    if ('merge' in setOptions && 'mergeFields' in setOptions) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" You cannot specify both \\\"merge\\\" and \\\"mergeFields\\\".\"));\n    }\n  }\n}\n\nexports.validateSetOptions = validateSetOptions;\n/**\n * Validates a JavaScript object for usage as a Firestore document.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\n * @throws when the object is invalid.\n */\n\nfunction validateDocumentData(arg, obj, allowDeletes) {\n  if (!serializer_1.isPlainObject(obj)) {\n    throw new Error(validate_1.customObjectMessage(arg, obj));\n  }\n\n  for (const prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      serializer_1.validateUserInput(arg, obj[prop], 'Firestore document', {\n        allowDeletes: allowDeletes ? 'all' : 'none',\n        allowTransforms: true\n      }, new path_1.FieldPath(prop));\n    }\n  }\n}\n\nexports.validateDocumentData = validateDocumentData;\n/**\n * Validates that a value can be used as field value during an update.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param val The value to verify.\n * @param path The path to show in the error message.\n */\n\nfunction validateFieldValue(arg, val, path) {\n  serializer_1.validateUserInput(arg, val, 'Firestore value', {\n    allowDeletes: 'root',\n    allowTransforms: true\n  }, path);\n}\n\nexports.validateFieldValue = validateFieldValue;\n/**\n * Validates that the update data does not contain any ambiguous field\n * definitions (such as 'a.b' and 'a').\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param data An update map with field/value pairs.\n */\n\nfunction validateNoConflictingFields(arg, data) {\n  const fields = [];\n  data.forEach((value, key) => {\n    fields.push(key);\n  });\n  fields.sort((left, right) => left.compareTo(right));\n\n  for (let i = 1; i < fields.length; ++i) {\n    if (fields[i - 1].isPrefixOf(fields[i])) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'update map'), \" Field \\\"\").concat(fields[i - 1], \"\\\" was specified multiple times.\"));\n    }\n  }\n}\n/**\n * Validates that a JavaScript object is a map of field paths to field values.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @throws when the object is invalid.\n */\n\n\nfunction validateUpdateMap(arg, obj) {\n  if (!serializer_1.isPlainObject(obj)) {\n    throw new Error(validate_1.customObjectMessage(arg, obj));\n  }\n\n  let isEmpty = true;\n\n  for (const prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      isEmpty = false;\n      validateFieldValue(arg, obj[prop], new path_1.FieldPath(prop));\n    }\n  }\n\n  if (isEmpty) {\n    throw new Error('At least one field must be updated.');\n  }\n}","map":null,"metadata":{},"sourceType":"script"}