{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst stream_1 = require(\"stream\");\n\nconst constants_1 = require(\"./constants\");\n\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n  constructor(call) {\n    super();\n    this.call = call;\n    call.on('metadata', metadata => {\n      this.emit('metadata', metadata);\n    });\n    call.on('status', status => {\n      this.emit('status', status);\n    });\n  }\n\n  cancel() {\n    this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n}\n\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\n\nfunction setUpReadableStream(stream, call, deserialize) {\n  let statusEmitted = false;\n  call.on('data', data => {\n    let deserialized;\n\n    try {\n      deserialized = deserialize(data);\n    } catch (e) {\n      call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');\n      return;\n    }\n\n    if (!stream.push(deserialized)) {\n      call.pause();\n    }\n  });\n  call.on('end', () => {\n    if (statusEmitted) {\n      stream.push(null);\n    } else {\n      call.once('status', () => {\n        stream.push(null);\n      });\n    }\n  });\n  call.on('status', status => {\n    if (status.code !== constants_1.Status.OK) {\n      const error = Object.assign(new Error(status.details), status);\n      stream.emit('error', error);\n    }\n\n    stream.emit('status', status);\n    statusEmitted = true;\n  });\n  call.pause();\n}\n\nclass ClientReadableStreamImpl extends stream_1.Readable {\n  constructor(call, deserialize) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.deserialize = deserialize;\n    call.on('metadata', metadata => {\n      this.emit('metadata', metadata);\n    });\n    setUpReadableStream(this, call, deserialize);\n  }\n\n  cancel() {\n    this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  _read(_size) {\n    this.call.resume();\n  }\n\n}\n\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\n\nfunction tryWrite(call, serialize, chunk, encoding, cb) {\n  let message;\n  const flags = Number(encoding);\n\n  try {\n    message = serialize(chunk);\n  } catch (e) {\n    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Serialization failure');\n    cb(e);\n    return;\n  }\n\n  const writeObj = {\n    message\n  };\n\n  if (!Number.isNaN(flags)) {\n    writeObj.flags = flags;\n  }\n\n  call.write(writeObj, cb);\n}\n\nclass ClientWritableStreamImpl extends stream_1.Writable {\n  constructor(call, serialize) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.serialize = serialize;\n    call.on('metadata', metadata => {\n      this.emit('metadata', metadata);\n    });\n    call.on('status', status => {\n      this.emit('status', status);\n    });\n  }\n\n  cancel() {\n    this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  _write(chunk, encoding, cb) {\n    tryWrite(this.call, this.serialize, chunk, encoding, cb);\n  }\n\n  _final(cb) {\n    this.call.end();\n    cb();\n  }\n\n}\n\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\n\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n  constructor(call, serialize, deserialize) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n    call.on('metadata', metadata => {\n      this.emit('metadata', metadata);\n    });\n    setUpReadableStream(this, call, deserialize);\n  }\n\n  cancel() {\n    this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  _read(_size) {\n    this.call.resume();\n  }\n\n  _write(chunk, encoding, cb) {\n    tryWrite(this.call, this.serialize, chunk, encoding, cb);\n  }\n\n  _final(cb) {\n    this.call.end();\n    cb();\n  }\n\n}\n\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;","map":null,"metadata":{},"sourceType":"script"}