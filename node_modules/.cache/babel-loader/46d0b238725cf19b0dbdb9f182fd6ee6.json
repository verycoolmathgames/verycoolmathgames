{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst deepEqual = require('deep-equal');\n\nconst bun = require(\"bun\");\n\nconst through2 = require(\"through2\");\n\nconst document_1 = require(\"./document\");\n\nconst document_change_1 = require(\"./document-change\");\n\nconst logger_1 = require(\"./logger\");\n\nconst order_1 = require(\"./order\");\n\nconst path_1 = require(\"./path\");\n\nconst serializer_1 = require(\"./serializer\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n\nconst watch_1 = require(\"./watch\");\n\nconst write_batch_1 = require(\"./write-batch\");\n/**\n * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'\n * (descending or ascending).\n *\n * @private\n */\n\n\nconst directionOperators = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\n/**\n * Filter conditions in a `Query.where()` clause are specified using the\n * strings '<', '<=', '==', '>=', and '>'.\n *\n * @private\n */\n\nconst comparisonOperators = {\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS'\n};\n/**\n * onSnapshot() callback that receives a QuerySnapshot.\n *\n * @callback querySnapshotCallback\n * @param {QuerySnapshot} snapshot A query snapshot.\n */\n\n/**\n * onSnapshot() callback that receives a DocumentSnapshot.\n *\n * @callback documentSnapshotCallback\n * @param {DocumentSnapshot} snapshot A document snapshot.\n */\n\n/**\n * onSnapshot() callback that receives an error.\n *\n * @callback errorCallback\n * @param {Error} err An error from a listen.\n */\n\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class\n */\n\nclass DocumentReference {\n  /**\n   * @hideconstructor\n   *\n   * @param _firestore The Firestore Database client.\n   * @param _path The Path of this reference.\n   */\n  constructor(_firestore, _path) {\n    this._firestore = _firestore;\n    this._path = _path;\n  }\n  /**\n   * The string representation of the DocumentReference's location.\n   * @private\n   * @type {string}\n   * @name DocumentReference#formattedName\n   */\n\n\n  get formattedName() {\n    const projectId = this.firestore.projectId;\n    return this._path.toQualifiedResourcePath(projectId).formattedName;\n  }\n  /**\n   * The [Firestore]{@link Firestore} instance for the Firestore\n   * database (useful for performing transactions, etc.).\n   *\n   * @type {Firestore}\n   * @name DocumentReference#firestore\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   let firestore = documentReference.firestore;\n   *   console.log(`Root location for document is ${firestore.formattedName}`);\n   * });\n   */\n\n\n  get firestore() {\n    return this._firestore;\n  }\n  /**\n   * A string representing the path of the referenced document (relative\n   * to the root of the database).\n   *\n   * @type {string}\n   * @name DocumentReference#path\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document at '${documentReference.path}'`);\n   * });\n   */\n\n\n  get path() {\n    return this._path.relativeName;\n  }\n  /**\n   * The last path element of the referenced document.\n   *\n   * @type {string}\n   * @name DocumentReference#id\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document with name '${documentReference.id}'`);\n   * });\n   */\n\n\n  get id() {\n    return this._path.id;\n  }\n  /**\n   * A reference to the collection to which this DocumentReference belongs.\n   *\n   * @name DocumentReference#parent\n   * @type {CollectionReference}\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   * let collectionRef = documentRef.parent;\n   *\n   * collectionRef.where('foo', '==', 'bar').get().then(results => {\n   *   console.log(`Found ${results.size} matches in parent collection`);\n   * }):\n   */\n\n\n  get parent() {\n    return new CollectionReference(this._firestore, this._path.parent());\n  }\n  /**\n   * Reads the document referred to by this DocumentReference.\n   *\n   * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n   * DocumentSnapshot for the retrieved document on success. For missing\n   * documents, DocumentSnapshot.exists will be false. If the get() fails for\n   * other reasons, the Promise will be rejected.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     console.log('Document retrieved successfully.');\n   *   }\n   * });\n   */\n\n\n  get() {\n    return this._firestore.getAll(this).then(([result]) => result);\n  }\n  /**\n   * Gets a [CollectionReference]{@link CollectionReference} instance\n   * that refers to the collection at the specified path.\n   *\n   * @param {string} collectionPath A slash-separated path to a collection.\n   * @returns {CollectionReference} A reference to the new\n   * subcollection.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   * let subcollection = documentRef.collection('subcollection');\n   * console.log(`Path to subcollection: ${subcollection.path}`);\n   */\n\n\n  collection(collectionPath) {\n    path_1.validateResourcePath('collectionPath', collectionPath);\n\n    const path = this._path.append(collectionPath);\n\n    if (!path.isCollection) {\n      throw new Error(\"Value for argument \\\"collectionPath\\\" must point to a collection, but was \\\"\".concat(collectionPath, \"\\\". Your path does not contain an odd number of components.\"));\n    }\n\n    return new CollectionReference(this._firestore, path);\n  }\n  /**\n   * Fetches the subcollections that are direct children of this document.\n   *\n   * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n   * with an array of CollectionReferences.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.listCollections().then(collections => {\n   *   for (let collection of collections) {\n   *     console.log(`Found subcollection with id: ${collection.id}`);\n   *   }\n   * });\n   */\n\n\n  listCollections() {\n    return this.firestore.initializeIfNeeded().then(() => {\n      const request = {\n        parent: this.formattedName\n      };\n      return this._firestore.request('listCollectionIds', request, util_1.requestTag(),\n      /* allowRetries= */\n      true).then(collectionIds => {\n        const collections = []; // We can just sort this list using the default comparator since it\n        // will only contain collection ids.\n\n        collectionIds.sort();\n\n        for (const collectionId of collectionIds) {\n          collections.push(this.collection(collectionId));\n        }\n\n        return collections;\n      });\n    });\n  }\n  /**\n   * Create a document with the provided object values. This will fail the write\n   * if a document exists at its location.\n   *\n   * @param {DocumentData} data An object that contains the fields and data to\n   * serialize as the document.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * write time of this create.\n   *\n   * @example\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * documentRef.create({foo: 'bar'}).then((res) => {\n   *   console.log(`Document created at ${res.updateTime}`);\n   * }).catch((err) => {\n   *   console.log(`Failed to create document: ${err}`);\n   * });\n   */\n\n\n  create(data) {\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.create(this, data).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Deletes the document referred to by this `DocumentReference`.\n   *\n   * A delete for a non-existing document is treated as a success (unless\n   * lastUptimeTime is provided).\n   *\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the delete if the\n   * document was last updated at a different time.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * delete time.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.delete().then(() => {\n   *   console.log('Document successfully deleted.');\n   * });\n   */\n\n\n  delete(precondition) {\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.delete(this, precondition).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Writes to the document referred to by this DocumentReference. If the\n   * document does not yet exist, it will be created. If you pass\n   * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n   * existing document.\n   *\n   * @param {DocumentData} data A map of the fields and values for the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge If true, set() merges the values specified\n   * in its data argument. Fields omitted from this set() call remain untouched.\n   * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n   * set() only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * write time of this set.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(res => {\n   *   console.log(`Document written at ${res.updateTime}`);\n   * });\n   */\n\n\n  set(data, options) {\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.set(this, data, options).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Updates fields in the document referred to by this DocumentReference.\n   * If the document doesn't yet exist, the update fails and the returned\n   * Promise will be rejected.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values.\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n   * fields and values with which to update the document or the path of the\n   * first field to update.\n   * @param {\n   * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n   * list of field paths and values to update or a Precondition to restrict\n   * this update.\n   * @returns {Promise.<WriteResult>} A Promise that resolves once the\n   * data has been successfully written to the backend.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.update({foo: 'bar'}).then(res => {\n   *   console.log(`Document updated at ${res.updateTime}`);\n   * });\n   */\n\n\n  update(dataOrField, ...preconditionOrValues) {\n    validate_1.validateMinNumberOfArguments('DocumentReference.update', arguments, 1);\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.update.apply(writeBatch, [this, dataOrField, ...preconditionOrValues]).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Attaches a listener for DocumentSnapshot events.\n   *\n   * @param {documentSnapshotCallback} onNext A callback to be called every\n   * time a new `DocumentSnapshot` is available.\n   * @param {errorCallback=} onError A callback to be called if the listen fails\n   * or is cancelled. No further callbacks will occur. If unset, errors will be\n   * logged to the console.\n   *\n   * @returns {function()} An unsubscribe function that can be called to cancel\n   * the snapshot listener.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(documentSnapshot.data());\n   *   }\n   * }, err => {\n   *   console.log(`Encountered error: ${err}`);\n   * });\n   *\n   * // Remove this listener.\n   * unsubscribe();\n   */\n\n\n  onSnapshot(onNext, onError) {\n    validate_1.validateFunction('onNext', onNext);\n    validate_1.validateFunction('onError', onError, {\n      optional: true\n    });\n    const watch = new watch_1.DocumentWatch(this.firestore, this);\n    return watch.onSnapshot((readTime, size, docs) => {\n      for (const document of docs()) {\n        if (document.ref.path === this.path) {\n          onNext(document);\n          return;\n        }\n      } // The document is missing.\n\n\n      const document = new document_1.DocumentSnapshotBuilder();\n      document.ref = new DocumentReference(this._firestore, this._path);\n      document.readTime = readTime;\n      onNext(document.build());\n    }, onError || console.error);\n  }\n  /**\n   * Returns true if this `DocumentReference` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `DocumentReference` is equal to the provided\n   * value.\n   */\n\n\n  isEqual(other) {\n    return this === other || other instanceof DocumentReference && this._firestore === other._firestore && this._path.isEqual(other._path);\n  }\n  /**\n   * Converts this DocumentReference to the Firestore Proto representation.\n   *\n   * @private\n   */\n\n\n  toProto() {\n    return {\n      referenceValue: this.formattedName\n    };\n  }\n\n}\n\nexports.DocumentReference = DocumentReference;\n/**\n * A Query order-by field.\n *\n * @private\n * @class\n */\n\nclass FieldOrder {\n  /**\n   * @param field The name of a document field (member) on which to order query\n   * results.\n   * @param direction One of 'ASCENDING' (default) or 'DESCENDING' to\n   * set the ordering direction to ascending or descending, respectively.\n   */\n  constructor(field, direction = 'ASCENDING') {\n    this.field = field;\n    this.direction = direction;\n  }\n  /**\n   * Generates the proto representation for this field order.\n   * @private\n   */\n\n\n  toProto() {\n    return {\n      field: {\n        fieldPath: this.field.formattedName\n      },\n      direction: this.direction\n    };\n  }\n\n}\n/**\n * A field constraint for a Query where clause.\n *\n * @private\n * @class\n */\n\n\nclass FieldFilter {\n  /**\n   * @param serializer The Firestore serializer\n   * @param field The path of the property value to compare.\n   * @param op A comparison operation.\n   * @param value The value to which to compare the field for inclusion in a\n   * query.\n   */\n  constructor(serializer, field, op, value) {\n    this.serializer = serializer;\n    this.field = field;\n    this.op = op;\n    this.value = value;\n  }\n  /**\n   * Returns whether this FieldFilter uses an equals comparison.\n   *\n   * @private\n   */\n\n\n  isInequalityFilter() {\n    switch (this.op) {\n      case 'GREATER_THAN':\n      case 'GREATER_THAN_OR_EQUAL':\n      case 'LESS_THAN':\n      case 'LESS_THAN_OR_EQUAL':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n  /**\n   * Generates the proto representation for this field filter.\n   *\n   * @private\n   */\n\n\n  toProto() {\n    if (typeof this.value === 'number' && isNaN(this.value)) {\n      return {\n        unaryFilter: {\n          field: {\n            fieldPath: this.field.formattedName\n          },\n          op: 'IS_NAN'\n        }\n      };\n    }\n\n    if (this.value === null) {\n      return {\n        unaryFilter: {\n          field: {\n            fieldPath: this.field.formattedName\n          },\n          op: 'IS_NULL'\n        }\n      };\n    }\n\n    return {\n      fieldFilter: {\n        field: {\n          fieldPath: this.field.formattedName\n        },\n        op: this.op,\n        value: this.serializer.encodeValue(this.value)\n      }\n    };\n  }\n\n}\n/**\n * A QuerySnapshot contains zero or more\n * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects\n * representing the results of a query. The documents can be accessed as an\n * array via the [documents]{@link QuerySnapshot#documents} property\n * or enumerated using the [forEach]{@link QuerySnapshot#forEach}\n * method. The number of documents can be determined via the\n * [empty]{@link QuerySnapshot#empty} and\n * [size]{@link QuerySnapshot#size} properties.\n *\n * @class QuerySnapshot\n */\n\n\nclass QuerySnapshot {\n  /**\n   * @hideconstructor\n   *\n   * @param _query The originating query.\n   * @param _readTime The time when this query snapshot was obtained.\n   * @param _size The number of documents in the result set.\n   * @param docs A callback returning a sorted array of documents matching\n   * this query\n   * @param changes A callback returning a sorted array of document change\n   * events for this snapshot.\n   */\n  constructor(_query, _readTime, _size, docs, changes) {\n    this._query = _query;\n    this._readTime = _readTime;\n    this._size = _size;\n    this._materializedDocs = null;\n    this._materializedChanges = null;\n    this._docs = null;\n    this._changes = null;\n    this._docs = docs;\n    this._changes = changes;\n  }\n  /**\n   * The query on which you called get() or onSnapshot() in order to get this\n   * QuerySnapshot.\n   *\n   * @type {Query}\n   * @name QuerySnapshot#query\n   * @readonly\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.limit(10).get().then(querySnapshot => {\n   *   console.log(`Returned first batch of results`);\n   *   let query = querySnapshot.query;\n   *   return query.offset(10).get();\n   * }).then(() => {\n   *   console.log(`Returned second batch of results`);\n   * });\n   */\n\n\n  get query() {\n    return this._query;\n  }\n  /**\n   * An array of all the documents in this QuerySnapshot.\n   *\n   * @type {Array.<QueryDocumentSnapshot>}\n   * @name QuerySnapshot#docs\n   * @readonly\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   let docs = querySnapshot.docs;\n   *   for (let doc of docs) {\n   *     console.log(`Document found at path: ${doc.ref.path}`);\n   *   }\n   * });\n   */\n\n\n  get docs() {\n    if (this._materializedDocs) {\n      return this._materializedDocs;\n    }\n\n    this._materializedDocs = this._docs();\n    this._docs = null;\n    return this._materializedDocs;\n  }\n  /**\n   * True if there are no documents in the QuerySnapshot.\n   *\n   * @type {boolean}\n   * @name QuerySnapshot#empty\n   * @readonly\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   if (querySnapshot.empty) {\n   *     console.log('No documents found.');\n   *   }\n   * });\n   */\n\n\n  get empty() {\n    return this._size === 0;\n  }\n  /**\n   * The number of documents in the QuerySnapshot.\n   *\n   * @type {number}\n   * @name QuerySnapshot#size\n   * @readonly\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   console.log(`Found ${querySnapshot.size} documents.`);\n   * });\n   */\n\n\n  get size() {\n    return this._size;\n  }\n  /**\n   * The time this query snapshot was obtained.\n   *\n   * @type {Timestamp}\n   * @name QuerySnapshot#readTime\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then((querySnapshot) => {\n   *   let readTime = querySnapshot.readTime;\n   *   console.log(`Query results returned at '${readTime.toDate()}'`);\n   * });\n   */\n\n\n  get readTime() {\n    return this._readTime;\n  }\n  /**\n   * Returns an array of the documents changes since the last snapshot. If\n   * this is the first snapshot, all documents will be in the list as added\n   * changes.\n   *\n   * @return {Array.<DocumentChange>}\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.onSnapshot(querySnapshot => {\n   *   let changes = querySnapshot.docChanges();\n   *   for (let change of changes) {\n   *     console.log(`A document was ${change.type}.`);\n   *   }\n   * });\n   */\n\n\n  docChanges() {\n    if (this._materializedChanges) {\n      return this._materializedChanges;\n    }\n\n    this._materializedChanges = this._changes();\n    this._changes = null;\n    return this._materializedChanges;\n  }\n  /**\n   * Enumerates all of the documents in the QuerySnapshot. This is a convenience\n   * method for running the same callback on each {@link QueryDocumentSnapshot}\n   * that is returned.\n   *\n   * @param {function} callback A callback to be called with a\n   * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in\n   * the snapshot.\n   * @param {*=} thisArg The `this` binding for the callback..\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  forEach(callback, thisArg) {\n    validate_1.validateFunction('callback', callback);\n\n    for (const doc of this.docs) {\n      callback.call(thisArg, doc);\n    }\n  }\n  /**\n   * Returns true if the document data in this `QuerySnapshot` is equal to the\n   * provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `QuerySnapshot` is equal to the provided\n   * value.\n   */\n\n\n  isEqual(other) {\n    // Since the read time is different on every query read, we explicitly\n    // ignore all metadata in this comparison.\n    if (this === other) {\n      return true;\n    }\n\n    if (!(other instanceof QuerySnapshot)) {\n      return false;\n    }\n\n    if (this._size !== other._size) {\n      return false;\n    }\n\n    if (!this._query.isEqual(other._query)) {\n      return false;\n    }\n\n    if (this._materializedDocs && !this._materializedChanges) {\n      // If we have only materialized the documents, we compare them first.\n      return isArrayEqual(this.docs, other.docs) && isArrayEqual(this.docChanges(), other.docChanges());\n    } // Otherwise, we compare the changes first as we expect there to be fewer.\n\n\n    return isArrayEqual(this.docChanges(), other.docChanges()) && isArrayEqual(this.docs, other.docs);\n  }\n\n}\n\nexports.QuerySnapshot = QuerySnapshot; // TODO: As of v0.17.0, we're changing docChanges from an array into a method.\n// Because this is a runtime breaking change and somewhat subtle (both Array and\n// Function have a .length, etc.), we'll replace commonly-used properties\n// (including Symbol.iterator) to throw a custom error message. By our v1.0\n// release, we should remove this code.\n\nfunction throwDocChangesMethodError() {\n  throw new Error('QuerySnapshot.docChanges has been changed from a property into a ' + 'method, so usages like \"querySnapshot.docChanges\" should become ' + '\"querySnapshot.docChanges()\"');\n}\n\nconst docChangesPropertiesToOverride = ['length', 'forEach', 'map', ...(typeof Symbol !== 'undefined' ? [Symbol.iterator] : [])];\ndocChangesPropertiesToOverride.forEach(property => {\n  Object.defineProperty(QuerySnapshot.prototype.docChanges, property, {\n    get: () => throwDocChangesMethodError()\n  });\n});\n/**\n * Internal class representing custom Query options.\n *\n * These options are immutable. Modified options can be created using `with()`.\n * @private\n */\n\nclass QueryOptions {\n  constructor(parentPath, collectionId, allDescendants, fieldFilters, fieldOrders, startAt, endAt, limit, offset, projection) {\n    this.parentPath = parentPath;\n    this.collectionId = collectionId;\n    this.allDescendants = allDescendants;\n    this.fieldFilters = fieldFilters;\n    this.fieldOrders = fieldOrders;\n    this.startAt = startAt;\n    this.endAt = endAt;\n    this.limit = limit;\n    this.offset = offset;\n    this.projection = projection;\n  }\n  /**\n   * Returns query options for a collection group query.\n   * @private\n   */\n\n\n  static forCollectionGroupQuery(collectionId) {\n    return new QueryOptions(\n    /*parentPath=*/\n    path_1.ResourcePath.EMPTY, collectionId,\n    /*allDescendants=*/\n    true,\n    /*fieldFilters=*/\n    [],\n    /*fieldOrders=*/\n    []);\n  }\n  /**\n   * Returns query options for a single-collection query.\n   * @private\n   */\n\n\n  static forCollectionQuery(collectionRef) {\n    return new QueryOptions(collectionRef.parent(), collectionRef.id,\n    /*allDescendants=*/\n    false,\n    /*fieldFilters=*/\n    [],\n    /*fieldOrders=*/\n    []);\n  }\n  /**\n   * Returns the union of the current and the provided options.\n   * @private\n   */\n\n\n  with(settings) {\n    return new QueryOptions(coalesce(settings.parentPath, this.parentPath), coalesce(settings.collectionId, this.collectionId), coalesce(settings.allDescendants, this.allDescendants), coalesce(settings.fieldFilters, this.fieldFilters), coalesce(settings.fieldOrders, this.fieldOrders), coalesce(settings.startAt, this.startAt), coalesce(settings.endAt, this.endAt), coalesce(settings.limit, this.limit), coalesce(settings.offset, this.offset), coalesce(settings.projection, this.projection));\n  }\n\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n\n    return other instanceof QueryOptions && this.parentPath.isEqual(other.parentPath) && this.collectionId === other.collectionId && this.allDescendants === other.allDescendants && this.limit === other.limit && this.offset === other.offset && deepEqual(this.fieldFilters, other.fieldFilters, {\n      strict: true\n    }) && deepEqual(this.fieldOrders, other.fieldOrders, {\n      strict: true\n    }) && deepEqual(this.startAt, other.startAt, {\n      strict: true\n    }) && deepEqual(this.endAt, other.endAt, {\n      strict: true\n    }) && deepEqual(this.projection, other.projection, {\n      strict: true\n    });\n  }\n\n}\n\nexports.QueryOptions = QueryOptions;\n/**\n * A Query refers to a query which you can read or stream from. You can also\n * construct refined Query objects by adding filters and ordering.\n *\n * @class Query\n */\n\nclass Query {\n  /**\n   * @hideconstructor\n   *\n   * @param _firestore The Firestore Database client.\n   * @param _queryOptions Options that define the query.\n   */\n  constructor(_firestore, _queryOptions) {\n    this._firestore = _firestore;\n    this._queryOptions = _queryOptions;\n    this._serializer = new serializer_1.Serializer(_firestore);\n  }\n  /**\n   * Detects the argument type for Firestore cursors.\n   *\n   * @private\n   * @param fieldValuesOrDocumentSnapshot A snapshot of the document or a set\n   * of field values.\n   * @returns 'true' if the input is a single DocumentSnapshot..\n   */\n\n\n  static _isDocumentSnapshot(fieldValuesOrDocumentSnapshot) {\n    return fieldValuesOrDocumentSnapshot.length === 1 && fieldValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot;\n  }\n  /**\n   * Extracts field values from the DocumentSnapshot based on the provided\n   * field order.\n   *\n   * @private\n   * @param documentSnapshot The document to extract the fields from.\n   * @param fieldOrders The field order that defines what fields we should\n   * extract.\n   * @return {Array.<*>} The field values to use.\n   * @private\n   */\n\n\n  static _extractFieldValues(documentSnapshot, fieldOrders) {\n    const fieldValues = [];\n\n    for (const fieldOrder of fieldOrders) {\n      if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n        fieldValues.push(documentSnapshot.ref);\n      } else {\n        const fieldValue = documentSnapshot.get(fieldOrder.field);\n\n        if (fieldValue === undefined) {\n          throw new Error(\"Field \\\"\".concat(fieldOrder.field, \"\\\" is missing in the provided DocumentSnapshot. \") + 'Please provide a document that contains values for all specified ' + 'orderBy() and where() constraints.');\n        } else {\n          fieldValues.push(fieldValue);\n        }\n      }\n    }\n\n    return fieldValues;\n  }\n  /**\n   * The [Firestore]{@link Firestore} instance for the Firestore\n   * database (useful for performing transactions, etc.).\n   *\n   * @type {Firestore}\n   * @name Query#firestore\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   let firestore = documentReference.firestore;\n   *   console.log(`Root location for document is ${firestore.formattedName}`);\n   * });\n   */\n\n\n  get firestore() {\n    return this._firestore;\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} with the additional filter\n   * that documents must contain the specified field and that its value should\n   * satisfy the relation constraint provided.\n   *\n   * Returns a new Query that constrains the value of a Document property.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the filter.\n   *\n   * @param {string|FieldPath} fieldPath The name of a property value to compare.\n   * @param {string} opStr A comparison operation in the form of a string\n   * (e.g., \"<\").\n   * @param {*} value The value to which to compare the field for inclusion in\n   * a query.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.where('foo', '==', 'bar').get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  where(fieldPath, opStr, value) {\n    path_1.validateFieldPath('fieldPath', fieldPath);\n    opStr = validateQueryOperator('opStr', opStr, value);\n    validateQueryValue('value', value);\n\n    if (this._queryOptions.startAt || this._queryOptions.endAt) {\n      throw new Error('Cannot specify a where() filter after calling startAt(), ' + 'startAfter(), endBefore() or endAt().');\n    }\n\n    const path = path_1.FieldPath.fromArgument(fieldPath);\n\n    if (path_1.FieldPath.documentId().isEqual(path)) {\n      value = this.validateReference(value);\n    }\n\n    const fieldFilter = new FieldFilter(this._serializer, path, comparisonOperators[opStr], value);\n\n    const options = this._queryOptions.with({\n      fieldFilters: this._queryOptions.fieldFilters.concat(fieldFilter)\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} instance that applies a\n   * field mask to the result and returns only the specified subset of fields.\n   * You can specify a list of field paths to return, or use an empty list to\n   * only return the references of matching documents.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the field mask.\n   *\n   * @param {...(string|FieldPath)} fieldPaths The field paths to return.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   * let documentRef = collectionRef.doc('doc');\n   *\n   * return documentRef.set({x:10, y:5}).then(() => {\n   *   return collectionRef.where('x', '>', 5).select('y').get();\n   * }).then((res) => {\n   *   console.log(`y is ${res.docs[0].get('y')}.`);\n   * });\n   */\n\n\n  select(...fieldPaths) {\n    const fields = [];\n\n    if (fieldPaths.length === 0) {\n      fields.push({\n        fieldPath: path_1.FieldPath.documentId().formattedName\n      });\n    } else {\n      for (let i = 0; i < fieldPaths.length; ++i) {\n        path_1.validateFieldPath(i, fieldPaths[i]);\n        fields.push({\n          fieldPath: path_1.FieldPath.fromArgument(fieldPaths[i]).formattedName\n        });\n      }\n    }\n\n    const options = this._queryOptions.with({\n      projection: {\n        fields\n      }\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that's additionally sorted\n   * by the specified field, optionally in descending order instead of\n   * ascending.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the field mask.\n   *\n   * @param {string|FieldPath} fieldPath The field to sort by.\n   * @param {string=} directionStr Optional direction to sort by ('asc' or\n   * 'desc'). If not specified, order will be ascending.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.orderBy('foo', 'desc').get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  orderBy(fieldPath, directionStr) {\n    path_1.validateFieldPath('fieldPath', fieldPath);\n    directionStr = validateQueryOrder('directionStr', directionStr);\n\n    if (this._queryOptions.startAt || this._queryOptions.endAt) {\n      throw new Error('Cannot specify an orderBy() constraint after calling ' + 'startAt(), startAfter(), endBefore() or endAt().');\n    }\n\n    const newOrder = new FieldOrder(path_1.FieldPath.fromArgument(fieldPath), directionOperators[directionStr || 'asc']);\n\n    const options = this._queryOptions.with({\n      fieldOrders: this._queryOptions.fieldOrders.concat(newOrder)\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that's additionally limited\n   * to only return up to the specified number of documents.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the limit.\n   *\n   * @param {number} limit The maximum number of items to return.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limit(1).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  limit(limit) {\n    validate_1.validateInteger('limit', limit);\n\n    const options = this._queryOptions.with({\n      limit\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Specifies the offset of the returned results.\n   *\n   * This function returns a new (immutable) instance of the\n   * [Query]{@link Query} (rather than modify the existing instance)\n   * to impose the offset.\n   *\n   * @param {number} offset The offset to apply to the Query results\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limit(10).offset(20).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  offset(offset) {\n    validate_1.validateInteger('offset', offset);\n\n    const options = this._queryOptions.with({\n      offset\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Returns true if this `Query` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `Query` is equal to the provided value.\n   */\n\n\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n\n    return other instanceof Query && this._queryOptions.isEqual(other._queryOptions);\n  }\n  /**\n   * Computes the backend ordering semantics for DocumentSnapshot cursors.\n   *\n   * @private\n   * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the\n   * set of field values to use as the boundary.\n   * @returns The implicit ordering semantics.\n   */\n\n\n  createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {\n    if (!Query._isDocumentSnapshot(cursorValuesOrDocumentSnapshot)) {\n      return this._queryOptions.fieldOrders;\n    }\n\n    const fieldOrders = this._queryOptions.fieldOrders.slice();\n\n    let hasDocumentId = false;\n\n    if (fieldOrders.length === 0) {\n      // If no explicit ordering is specified, use the first inequality to\n      // define an implicit order.\n      for (const fieldFilter of this._queryOptions.fieldFilters) {\n        if (fieldFilter.isInequalityFilter()) {\n          fieldOrders.push(new FieldOrder(fieldFilter.field));\n          break;\n        }\n      }\n    } else {\n      for (const fieldOrder of fieldOrders) {\n        if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n          hasDocumentId = true;\n        }\n      }\n    }\n\n    if (!hasDocumentId) {\n      // Add implicit sorting by name, using the last specified direction.\n      const lastDirection = fieldOrders.length === 0 ? directionOperators.ASC : fieldOrders[fieldOrders.length - 1].direction;\n      fieldOrders.push(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n    }\n\n    return fieldOrders;\n  }\n  /**\n   * Builds a Firestore 'Position' proto message.\n   *\n   * @private\n   * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this\n   * cursor.\n   * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The\n   * snapshot of the document or the set of field values to use as the boundary.\n   * @param before Whether the query boundary lies just before or after the\n   * provided data.\n   * @returns {Object} The proto message.\n   */\n\n\n  createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {\n    let fieldValues;\n\n    if (Query._isDocumentSnapshot(cursorValuesOrDocumentSnapshot)) {\n      fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);\n    } else {\n      fieldValues = cursorValuesOrDocumentSnapshot;\n    }\n\n    if (fieldValues.length > fieldOrders.length) {\n      throw new Error('Too many cursor values specified. The specified ' + 'values must match the orderBy() constraints of the query.');\n    }\n\n    const options = {\n      values: []\n    };\n\n    if (before) {\n      options.before = true;\n    }\n\n    for (let i = 0; i < fieldValues.length; ++i) {\n      let fieldValue = fieldValues[i];\n\n      if (path_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {\n        fieldValue = this.validateReference(fieldValue);\n      }\n\n      validateQueryValue(i, fieldValue);\n      options.values.push(fieldValue);\n    }\n\n    return options;\n  }\n  /**\n   * Validates that a value used with FieldValue.documentId() is either a\n   * string or a DocumentReference that is part of the query`s result set.\n   * Throws a validation error or returns a DocumentReference that can\n   * directly be used in the Query.\n   *\n   * @param val The value to validate.\n   * @throws If the value cannot be used for this query.\n   * @return If valid, returns a DocumentReference that can be used with the\n   * query.\n   * @private\n   */\n\n\n  validateReference(val) {\n    const basePath = this._queryOptions.allDescendants ? this._queryOptions.parentPath : this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n    let reference;\n\n    if (typeof val === 'string') {\n      reference = new DocumentReference(this._firestore, basePath.append(val));\n    } else if (val instanceof DocumentReference) {\n      reference = val;\n\n      if (!basePath.isPrefixOf(reference._path)) {\n        throw new Error(\"\\\"\".concat(reference.path, \"\\\" is not part of the query result set and \") + 'cannot be used as a query boundary.');\n      }\n    } else {\n      throw new Error('The corresponding value for FieldPath.documentId() must be a ' + 'string or a DocumentReference.');\n    }\n\n    if (!this._queryOptions.allDescendants && reference._path.parent().compareTo(basePath) !== 0) {\n      throw new Error('Only a direct child can be used as a query boundary. ' + \"Found: \\\"\".concat(reference.path, \"\\\".\"));\n    }\n\n    return reference;\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that starts at the provided\n   * set of field values relative to the order of the query. The order of the\n   * provided values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should start at or the field values to\n   * start this query at, in order of the query's order by.\n   * @returns {Query} A query with the new starting point.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').startAt(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  startAt(...fieldValuesOrDocumentSnapshot) {\n    validate_1.validateMinNumberOfArguments('Query.startAt', arguments, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n\n    const options = this._queryOptions.with({\n      fieldOrders,\n      startAt\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that starts after the\n   * provided set of field values relative to the order of the query. The order\n   * of the provided values must match the order of the order by clauses of the\n   * query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should start after or the field values to\n   * start this query after, in order of the query's order by.\n   * @returns {Query} A query with the new starting point.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  startAfter(...fieldValuesOrDocumentSnapshot) {\n    validate_1.validateMinNumberOfArguments('Query.startAfter', arguments, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n\n    const options = this._queryOptions.with({\n      fieldOrders,\n      startAt\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that ends before the set of\n   * field values relative to the order of the query. The order of the provided\n   * values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should end before or the field values to\n   * end this query before, in order of the query's order by.\n   * @returns {Query} A query with the new ending point.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  endBefore(...fieldValuesOrDocumentSnapshot) {\n    validate_1.validateMinNumberOfArguments('Query.endBefore', arguments, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n\n    const options = this._queryOptions.with({\n      fieldOrders,\n      endAt\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that ends at the provided\n   * set of field values relative to the order of the query. The order of the\n   * provided values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should end at or the field values to end\n   * this query at, in order of the query's order by.\n   * @returns {Query} A query with the new ending point.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').endAt(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  endAt(...fieldValuesOrDocumentSnapshot) {\n    validate_1.validateMinNumberOfArguments('Query.endAt', arguments, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n\n    const options = this._queryOptions.with({\n      fieldOrders,\n      endAt\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Executes the query and returns the results as a\n   * [QuerySnapshot]{@link QuerySnapshot}.\n   *\n   * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results\n   * of the Query.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  get() {\n    return this._get();\n  }\n  /**\n   * Internal get() method that accepts an optional transaction id.\n   *\n   * @private\n   * @param {bytes=} transactionId A transaction ID.\n   */\n\n\n  _get(transactionId) {\n    const self = this;\n    const docs = [];\n    return new Promise((resolve, reject) => {\n      let readTime;\n\n      self._stream(transactionId).on('error', err => {\n        reject(err);\n      }).on('data', result => {\n        readTime = result.readTime;\n\n        if (result.document) {\n          const document = result.document;\n          docs.push(document);\n        }\n      }).on('end', () => {\n        resolve(new QuerySnapshot(this, readTime, docs.length, () => docs, () => {\n          const changes = [];\n\n          for (let i = 0; i < docs.length; ++i) {\n            changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n          }\n\n          return changes;\n        }));\n      });\n    });\n  }\n  /**\n   * Executes the query and streams the results as\n   * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.\n   *\n   * @returns {Stream.<QueryDocumentSnapshot>} A stream of\n   * QueryDocumentSnapshots.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * let count = 0;\n   *\n   * query.stream().on('data', (documentSnapshot) => {\n   *   console.log(`Found document with name '${documentSnapshot.id}'`);\n   *   ++count;\n   * }).on('end', () => {\n   *   console.log(`Total count is ${count}`);\n   * });\n   */\n\n\n  stream() {\n    const responseStream = this._stream();\n\n    const transform = through2.obj(function (chunk, encoding, callback) {\n      // Only send chunks with documents.\n      if (chunk.document) {\n        this.push(chunk.document);\n      }\n\n      callback();\n    });\n    return bun([responseStream, transform]);\n  }\n  /**\n   * Converts a QueryCursor to its proto representation.\n   * @private\n   */\n\n\n  _toCursor(cursor) {\n    if (cursor) {\n      const values = cursor.values.map(val => this._serializer.encodeValue(val));\n      return {\n        before: cursor.before,\n        values\n      };\n    }\n\n    return undefined;\n  }\n  /**\n   * Internal method for serializing a query to its RunQuery proto\n   * representation with an optional transaction id.\n   *\n   * @param transactionId A transaction ID.\n   * @private\n   * @returns Serialized JSON for the query.\n   */\n\n\n  toProto(transactionId) {\n    const projectId = this.firestore.projectId;\n\n    const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId);\n\n    const reqOpts = {\n      parent: parentPath.formattedName,\n      structuredQuery: {\n        from: [{\n          collectionId: this._queryOptions.collectionId\n        }]\n      }\n    };\n\n    if (this._queryOptions.allDescendants) {\n      reqOpts.structuredQuery.from[0].allDescendants = true;\n    }\n\n    const structuredQuery = reqOpts.structuredQuery;\n\n    if (this._queryOptions.fieldFilters.length === 1) {\n      structuredQuery.where = this._queryOptions.fieldFilters[0].toProto();\n    } else if (this._queryOptions.fieldFilters.length > 1) {\n      const filters = [];\n\n      for (const fieldFilter of this._queryOptions.fieldFilters) {\n        filters.push(fieldFilter.toProto());\n      }\n\n      structuredQuery.where = {\n        compositeFilter: {\n          op: 'AND',\n          filters\n        }\n      };\n    }\n\n    if (this._queryOptions.fieldOrders.length) {\n      const orderBy = [];\n\n      for (const fieldOrder of this._queryOptions.fieldOrders) {\n        orderBy.push(fieldOrder.toProto());\n      }\n\n      structuredQuery.orderBy = orderBy;\n    }\n\n    if (this._queryOptions.limit) {\n      structuredQuery.limit = {\n        value: this._queryOptions.limit\n      };\n    }\n\n    structuredQuery.offset = this._queryOptions.offset;\n    structuredQuery.startAt = this._toCursor(this._queryOptions.startAt);\n    structuredQuery.endAt = this._toCursor(this._queryOptions.endAt);\n    structuredQuery.select = this._queryOptions.projection;\n    reqOpts.transaction = transactionId;\n    return reqOpts;\n  }\n  /**\n   * Internal streaming method that accepts an optional transaction id.\n   *\n   * @param transactionId A transaction ID.\n   * @private\n   * @returns A stream of document results.\n   */\n\n\n  _stream(transactionId) {\n    const tag = util_1.requestTag();\n    const self = this;\n    const stream = through2.obj(function (proto, enc, callback) {\n      const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n\n      if (proto.document) {\n        const document = self.firestore.snapshot_(proto.document, proto.readTime);\n        this.push({\n          document,\n          readTime\n        });\n      } else {\n        this.push({\n          readTime\n        });\n      }\n\n      callback();\n    });\n    this.firestore.initializeIfNeeded().then(() => {\n      const request = this.toProto(transactionId);\n\n      this._firestore.readStream('runQuery', request, tag, true).then(backendStream => {\n        backendStream.on('error', err => {\n          logger_1.logger('Query._stream', tag, 'Query failed with stream error:', err);\n          stream.destroy(err);\n        });\n        backendStream.resume();\n        backendStream.pipe(stream);\n      }).catch(err => {\n        stream.destroy(err);\n      });\n    });\n    return stream;\n  }\n  /**\n   * Attaches a listener for QuerySnapshot events.\n   *\n   * @param {querySnapshotCallback} onNext A callback to be called every time\n   * a new [QuerySnapshot]{@link QuerySnapshot} is available.\n   * @param {errorCallback=} onError A callback to be called if the listen\n   * fails or is cancelled. No further callbacks will occur.\n   *\n   * @returns {function()} An unsubscribe function that can be called to cancel\n   * the snapshot listener.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * let unsubscribe = query.onSnapshot(querySnapshot => {\n   *   console.log(`Received query snapshot of size ${querySnapshot.size}`);\n   * }, err => {\n   *   console.log(`Encountered error: ${err}`);\n   * });\n   *\n   * // Remove this listener.\n   * unsubscribe();\n   */\n\n\n  onSnapshot(onNext, onError) {\n    validate_1.validateFunction('onNext', onNext);\n    validate_1.validateFunction('onError', onError, {\n      optional: true\n    });\n    const watch = new watch_1.QueryWatch(this.firestore, this);\n    return watch.onSnapshot((readTime, size, docs, changes) => {\n      onNext(new QuerySnapshot(this, readTime, size, docs, changes));\n    }, onError || console.error);\n  }\n  /**\n   * Returns a function that can be used to sort QueryDocumentSnapshots\n   * according to the sort criteria of this query.\n   *\n   * @private\n   */\n\n\n  comparator() {\n    return (doc1, doc2) => {\n      // Add implicit sorting by name, using the last specified direction.\n      const lastDirection = this._queryOptions.fieldOrders.length === 0 ? 'ASCENDING' : this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction;\n\n      const orderBys = this._queryOptions.fieldOrders.concat(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n\n      for (const orderBy of orderBys) {\n        let comp;\n\n        if (path_1.FieldPath.documentId().isEqual(orderBy.field)) {\n          comp = doc1.ref._path.compareTo(doc2.ref._path);\n        } else {\n          const v1 = doc1.protoField(orderBy.field);\n          const v2 = doc2.protoField(orderBy.field);\n\n          if (v1 === undefined || v2 === undefined) {\n            throw new Error('Trying to compare documents on fields that ' + \"don't exist. Please include the fields you are ordering on \" + 'in your select() call.');\n          }\n\n          comp = order_1.compare(v1, v2);\n        }\n\n        if (comp !== 0) {\n          const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;\n          return direction * comp;\n        }\n      }\n\n      return 0;\n    };\n  }\n\n}\n\nexports.Query = Query;\n/**\n * A CollectionReference object can be used for adding documents, getting\n * document references, and querying for documents (using the methods\n * inherited from [Query]{@link Query}).\n *\n * @class\n * @extends Query\n */\n\nclass CollectionReference extends Query {\n  /**\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   * @param path The Path of this collection.\n   */\n  constructor(firestore, path) {\n    super(firestore, QueryOptions.forCollectionQuery(path));\n  }\n  /**\n   * Returns a resource path for this collection.\n   * @private\n   */\n\n\n  get resourcePath() {\n    return this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n  }\n  /**\n   * The last path element of the referenced collection.\n   *\n   * @type {string}\n   * @name CollectionReference#id\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col/doc/subcollection');\n   * console.log(`ID of the subcollection: ${collectionRef.id}`);\n   */\n\n\n  get id() {\n    return this._queryOptions.collectionId;\n  }\n  /**\n   * A reference to the containing Document if this is a subcollection, else\n   * null.\n   *\n   * @type {DocumentReference}\n   * @name CollectionReference#parent\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col/doc/subcollection');\n   * let documentRef = collectionRef.parent;\n   * console.log(`Parent name: ${documentRef.path}`);\n   */\n\n\n  get parent() {\n    return new DocumentReference(this.firestore, this._queryOptions.parentPath);\n  }\n  /**\n   * A string representing the path of the referenced collection (relative\n   * to the root of the database).\n   *\n   * @type {string}\n   * @name CollectionReference#path\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col/doc/subcollection');\n   * console.log(`Path of the subcollection: ${collectionRef.path}`);\n   */\n\n\n  get path() {\n    return this.resourcePath.relativeName;\n  }\n  /**\n   * Retrieves the list of documents in this collection.\n   *\n   * The document references returned may include references to \"missing\n   * documents\", i.e. document locations that have no document present but\n   * which contain subcollections with documents. Attempting to read such a\n   * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a\n   * `DocumentSnapshot` whose `.exists` property is false.\n   *\n   * @return {Promise<DocumentReference[]>} The list of documents in this\n   * collection.\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * return collectionRef.listDocuments().then(documentRefs => {\n   *    return firestore.getAll(documentRefs);\n   * }).then(documentSnapshots => {\n   *    for (let documentSnapshot of documentSnapshots) {\n   *       if (documentSnapshot.exists) {\n   *         console.log(`Found document with data: ${documentSnapshot.id}`);\n   *       } else {\n   *         console.log(`Found missing document: ${documentSnapshot.id}`);\n   *       }\n   *    }\n   * });\n   */\n\n\n  listDocuments() {\n    return this.firestore.initializeIfNeeded().then(() => {\n      const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId);\n\n      const request = {\n        parent: parentPath.formattedName,\n        collectionId: this.id,\n        showMissing: true,\n        mask: {\n          fieldPaths: []\n        }\n      };\n      return this.firestore.request('listDocuments', request, util_1.requestTag(),\n      /*allowRetries=*/\n      true).then(documents => {\n        // Note that the backend already orders these documents by name,\n        // so we do not need to manually sort them.\n        return documents.map(doc => {\n          const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);\n          return this.doc(path.id);\n        });\n      });\n    });\n  }\n  /**\n   * Gets a [DocumentReference]{@link DocumentReference} instance that\n   * refers to the document at the specified path. If no path is specified, an\n   * automatically-generated unique ID will be used for the returned\n   * DocumentReference.\n   *\n   * @param {string=} documentPath A slash-separated path to a document.\n   * @returns {DocumentReference} The `DocumentReference`\n   * instance.\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   * let documentRefWithName = collectionRef.doc('doc');\n   * let documentRefWithAutoId = collectionRef.doc();\n   * console.log(`Reference with name: ${documentRefWithName.path}`);\n   * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);\n   */\n\n\n  doc(documentPath) {\n    if (arguments.length === 0) {\n      documentPath = util_1.autoId();\n    } else {\n      path_1.validateResourcePath('documentPath', documentPath);\n    }\n\n    const path = this.resourcePath.append(documentPath);\n\n    if (!path.isDocument) {\n      throw new Error(\"Value for argument \\\"documentPath\\\" must point to a document, but was \\\"\".concat(documentPath, \"\\\". Your path does not contain an even number of components.\"));\n    }\n\n    return new DocumentReference(this.firestore, path);\n  }\n  /**\n   * Add a new document to this collection with the specified data, assigning\n   * it a document ID automatically.\n   *\n   * @param {DocumentData} data An Object containing the data for the new\n   * document.\n   * @returns {Promise.<DocumentReference>} A Promise resolved with a\n   * [DocumentReference]{@link DocumentReference} pointing to the\n   * newly created document.\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document with name: ${documentReference.id}`);\n   * });\n   */\n\n\n  add(data) {\n    write_batch_1.validateDocumentData('data', data,\n    /*allowDeletes=*/\n    false);\n    const documentRef = this.doc();\n    return documentRef.create(data).then(() => documentRef);\n  }\n  /**\n   * Returns true if this `CollectionReference` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `CollectionReference` is equal to the\n   * provided value.\n   */\n\n\n  isEqual(other) {\n    return this === other || other instanceof CollectionReference && super.isEqual(other);\n  }\n\n}\n\nexports.CollectionReference = CollectionReference;\n/**\n * Validates the input string as a field order direction.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Order direction to validate.\n * @throws when the direction is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\n\nfunction validateQueryOrder(arg, op) {\n  // For backwards compatibility, we support both lower and uppercase values.\n  op = typeof op === 'string' ? op.toLowerCase() : op;\n  validate_1.validateEnumValue(arg, op, Object.keys(directionOperators), {\n    optional: true\n  });\n  return op;\n}\n\nexports.validateQueryOrder = validateQueryOrder;\n/**\n * Validates the input string as a field comparison operator.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Field comparison operator to validate.\n * @param fieldValue Value that is used in the filter.\n * @throws when the comparison operation is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\n\nfunction validateQueryOperator(arg, op, fieldValue) {\n  // For backwards compatibility, we support both `=` and `==` for \"equals\".\n  op = op === '=' ? '==' : op;\n  validate_1.validateEnumValue(arg, op, Object.keys(comparisonOperators));\n\n  if (typeof fieldValue === 'number' && isNaN(fieldValue) && op !== '==') {\n    throw new Error('Invalid query. You can only perform equals comparisons on NaN.');\n  }\n\n  if (fieldValue === null && op !== '==') {\n    throw new Error('Invalid query. You can only perform equals comparisons on Null.');\n  }\n\n  return op;\n}\n\nexports.validateQueryOperator = validateQueryOperator;\n/**\n * Validates that 'value' is a DocumentReference.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n */\n\nfunction validateDocumentReference(arg, value) {\n  if (!(value instanceof DocumentReference)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentReference'));\n  }\n}\n\nexports.validateDocumentReference = validateDocumentReference;\n/**\n * Validates that 'value' can be used as a query value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n */\n\nfunction validateQueryValue(arg, value) {\n  serializer_1.validateUserInput(arg, value, 'query constraint', {\n    allowDeletes: 'none',\n    allowTransforms: false\n  });\n}\n/**\n * Verifies equality for an array of objects using the `isEqual` interface.\n *\n * @private\n * @param left Array of objects supporting `isEqual`.\n * @param right Array of objects supporting `isEqual`.\n * @return True if arrays are equal.\n */\n\n\nfunction isArrayEqual(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.length; ++i) {\n    if (!left[i].isEqual(right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Returns the first non-undefined value or `undefined` if no such value exists.\n * @private\n */\n\n\nfunction coalesce(...values) {\n  return values.find(value => value !== undefined);\n}","map":null,"metadata":{},"sourceType":"script"}