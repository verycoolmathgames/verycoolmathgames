{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014-2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst common_1 = require(\"@google-cloud/common\");\n\nconst paginator_1 = require(\"@google-cloud/paginator\");\n\nconst promisify_1 = require(\"@google-cloud/promisify\");\n\nconst arrify = require(\"arrify\");\n\nconst bucket_1 = require(\"./bucket\");\n\nconst channel_1 = require(\"./channel\");\n\nconst file_1 = require(\"./file\");\n\nconst util_1 = require(\"./util\");\n/*! Developer Documentation\n *\n * Invoke this method to create a new Storage object bound with pre-determined\n * configuration options. For each object that can be created (e.g., a bucket),\n * there is an equivalent static and instance method. While they are classes,\n * they can be instantiated without use of the `new` keyword.\n */\n\n/**\n * <h4>ACLs</h4>\n * Cloud Storage uses access control lists (ACLs) to manage object and\n * bucket access. ACLs are the mechanism you use to share files with other users\n * and allow other users to access your buckets and files.\n *\n * To learn more about ACLs, read this overview on\n * [Access Control](https://cloud.google.com/storage/docs/access-control).\n *\n * @see [Cloud Storage overview]{@link https://cloud.google.com/storage/docs/overview}\n * @see [Access Control]{@link https://cloud.google.com/storage/docs/access-control}\n *\n * @class\n */\n\n\nclass Storage extends common_1.Service {\n  /**\n   * @typedef {object} StorageOptions\n   * @property {string} [projectId] The project ID from the Google Developer's\n   *     Console, e.g. 'grape-spaceship-123'. We will also check the environment\n   *     variable `GCLOUD_PROJECT` for your project ID. If your app is running\n   * in an environment which supports {@link\n   * https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\n   * Application Default Credentials}, your project ID will be detected\n   * automatically.\n   * @property {string} [keyFilename] Full path to the a .json, .pem, or .p12 key\n   *     downloaded from the Google Developers Console. If you provide a path to\n   * a JSON file, the `projectId` option above is not necessary. NOTE: .pem and\n   *     .p12 require you to specify the `email` option as well.\n   * @property {string} [email] Account email address. Required when using a .pem\n   *     or .p12 keyFilename.\n   * @property {object} [credentials] Credentials object.\n   * @property {string} [credentials.client_email]\n   * @property {string} [credentials.private_key]\n   * @property {boolean} [autoRetry=true] Automatically retry requests if the\n   *     response is related to rate limits or certain intermittent server\n   * errors. We will exponentially backoff subsequent requests by default.\n   * @property {number} [maxRetries=3] Maximum number of automatic retries\n   *     attempted before returning the error.\n   * @property {Constructor} [promise] Custom promise module to use instead of\n   *     native Promises.\n   */\n\n  /**\n   * Constructs the Storage client.\n   *\n   * @example <caption>Create a client that uses Application Default Credentials\n   * (ADC)</caption> const {Storage} = require('@google-cloud/storage'); const\n   * storage = new Storage();\n   *\n   * @example <caption>Create a client with explicit credentials</caption>\n   * storage');/storage');\n   * const storage = new Storage({\n   *   projectId: 'your-project-id',\n   *   keyFilename: '/path/to/keyfile.json'\n   * });\n   *\n   * @param {StorageOptions} [options] Configuration options.\n   */\n  constructor(options = {}) {\n    const config = {\n      baseUrl: 'https://www.googleapis.com/storage/v1',\n      projectIdRequired: false,\n      scopes: ['https://www.googleapis.com/auth/iam', 'https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/devstorage.full_control'],\n      packageJson: require('../../package.json')\n    };\n    super(config, options);\n    /**\n     * Reference to {@link Storage.acl}.\n     *\n     * @name Storage#acl\n     * @see Storage.acl\n     */\n\n    this.acl = Storage.acl;\n    this.getBucketsStream = paginator_1.paginator.streamify('getBuckets');\n  }\n  /**\n   * Get a reference to a Cloud Storage bucket.\n   *\n   * @param {string} name Name of the bucket.\n   * @param {object} [options] Configuration object.\n   * @param {string} [options.kmsKeyName] A Cloud KMS key that will be used to\n   *     encrypt objects inserted into this bucket, if no encryption method is\n   *     specified.\n   * @param {string} [options.userProject] User project to be billed for all\n   *     requests made from this Bucket object.\n   * @returns {Bucket}\n   * @see Bucket\n   *\n   * @example\n   * const {Storage} = require('@google-cloud/storage');\n   * const storage = new Storage();\n   * const albums = storage.bucket('albums');\n   * const photos = storage.bucket('photos');\n   */\n\n\n  bucket(name, options) {\n    if (!name) {\n      throw new Error('A bucket name is needed to use Cloud Storage.');\n    }\n\n    return new bucket_1.Bucket(this, name, options);\n  }\n  /**\n   * Reference a channel to receive notifications about changes to your bucket.\n   *\n   * @param {string} id The ID of the channel.\n   * @param {string} resourceId The resource ID of the channel.\n   * @returns {Channel}\n   * @see Channel\n   *\n   * @example\n   * const {Storage} = require('@google-cloud/storage');\n   * const storage = new Storage();\n   * const channel = storage.channel('id', 'resource-id');\n   */\n\n\n  channel(id, resourceId) {\n    return new channel_1.Channel(this, id, resourceId);\n  }\n  /**\n   * @typedef {array} CreateBucketResponse\n   * @property {Bucket} 0 The new {@link Bucket}.\n   * @property {object} 1 The full API response.\n   */\n\n  /**\n   * @callback CreateBucketCallback\n   * @param {?Error} err Request error, if any.\n   * @param {Bucket} bucket The new {@link Bucket}.\n   * @param {object} apiResponse The full API response.\n   */\n\n  /**\n   * Metadata to set for the bucket.\n   *\n   * @typedef {object} CreateBucketRequest\n   * @property {boolean} [coldline=false] Specify the storage class as Coldline.\n   * @property {boolean} [dra=false] Specify the storage class as Durable Reduced\n   *     Availability.\n   * @property {boolean} [multiRegional=false] Specify the storage class as\n   *     Multi-Regional.\n   * @property {boolean} [nearline=false] Specify the storage class as Nearline.\n   * @property {boolean} [regional=false] Specify the storage class as Regional.\n   * @property {boolean} [requesterPays=false] **Early Access Testers Only**\n   *     Force the use of the User Project metadata field to assign operational\n   *     costs when an operation is made on a Bucket and its objects.\n   * @property {string} [userProject] The ID of the project which will be billed\n   *     for the request.\n   */\n\n  /**\n   * Create a bucket.\n   *\n   * Cloud Storage uses a flat namespace, so you can't create a bucket with\n   * a name that is already in use. For more information, see\n   * [Bucket Naming\n   * Guidelines](https://cloud.google.com/storage/docs/bucketnaming.html#requirements).\n   *\n   * @see [Buckets: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/insert}\n   * @see [Storage Classes]{@link https://cloud.google.com/storage/docs/storage-classes}\n   *\n   * @param {string} name Name of the bucket to create.\n   * @param {CreateBucketRequest} [metadata] Metadata to set for the bucket.\n   * @param {CreateBucketCallback} [callback] Callback function.\n   * @returns {Promise<CreateBucketResponse>}\n   * @throws {Error} If a name is not provided.\n   * @see Bucket#create\n   *\n   * @example\n   * const {Storage} = require('@google-cloud/storage');\n   * const storage = new Storage();\n   * const callback = function(err, bucket, apiResponse) {\n   *   // `bucket` is a Bucket object.\n   * };\n   *\n   * storage.createBucket('new-bucket', callback);\n   *\n   * //-\n   * // Create a bucket in a specific location and region. <em>See the <a\n   * // href=\"https://cloud.google.com/storage/docs/json_api/v1/buckets/insert\">\n   * // Official JSON API docs</a> for complete details on the `location`\n   * option.\n   * // </em>\n   * //-\n   * const metadata = {\n   *   location: 'US-CENTRAL1',\n   *   regional: true\n   * };\n   *\n   * storage.createBucket('new-bucket', metadata, callback);\n   *\n   * //-\n   * // Create a bucket with a retention policy of 6 months.\n   * //-\n   * const metadata = {\n   *   retentionPolicy: {\n   *     retentionPeriod: 15780000 // 6 months in seconds.\n   *   }\n   * };\n   *\n   * storage.createBucket('new-bucket', metadata, callback);\n   *\n   * //-\n   * // Enable versioning on a new bucket.\n   * //-\n   * const metadata = {\n   *   versioning: {\n   *     enabled: true\n   *   }\n   * };\n   *\n   * storage.createBucket('new-bucket', metadata, callback);\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * storage.createBucket('new-bucket').then(function(data) {\n   *   const bucket = data[0];\n   *   const apiResponse = data[1];\n   * });\n   *\n   * @example <caption>include:samples/buckets.js</caption>\n   * region_tag:storage_create_bucket\n   * Another example:\n   */\n\n\n  createBucket(name, metadataOrCallback, callback) {\n    if (!name) {\n      throw new Error('A name is required to create a bucket.');\n    }\n\n    let metadata;\n\n    if (!callback) {\n      callback = metadataOrCallback;\n      metadata = {};\n    } else {\n      metadata = metadataOrCallback;\n    }\n\n    const body = Object.assign({}, metadata, {\n      name\n    });\n    const storageClasses = {\n      coldline: 'COLDLINE',\n      dra: 'DURABLE_REDUCED_AVAILABILITY',\n      multiRegional: 'MULTI_REGIONAL',\n      nearline: 'NEARLINE',\n      regional: 'REGIONAL'\n    };\n    Object.keys(storageClasses).forEach(storageClass => {\n      if (body[storageClass]) {\n        body.storageClass = storageClasses[storageClass];\n        delete body[storageClass];\n      }\n    });\n\n    if (body.requesterPays) {\n      body.billing = {\n        requesterPays: body.requesterPays\n      };\n      delete body.requesterPays;\n    }\n\n    const query = {\n      project: this.projectId\n    };\n\n    if (body.userProject) {\n      query.userProject = body.userProject;\n      delete body.userProject;\n    }\n\n    this.request({\n      method: 'POST',\n      uri: '/b',\n      qs: query,\n      json: body\n    }, (err, resp) => {\n      if (err) {\n        callback(err, null, resp);\n        return;\n      }\n\n      const bucket = this.bucket(name);\n      bucket.metadata = resp;\n      callback(null, bucket, resp);\n    });\n  }\n  /**\n   * Query object for listing buckets.\n   *\n   * @typedef {object} GetBucketsRequest\n   * @property {boolean} [autoPaginate=true] Have pagination handled\n   *     automatically.\n   * @property {number} [maxApiCalls] Maximum number of API calls to make.\n   * @property {number} [maxResults] Maximum number of items plus prefixes to\n   *     return.\n   * @property {string} [pageToken] A previously-returned page token\n   *     representing part of the larger set of results to view.\n   * @property {string} [userProject] The ID of the project which will be billed\n   *     for the request.\n   */\n\n  /**\n   * @typedef {array} GetBucketsResponse\n   * @property {Bucket[]} 0 Array of {@link Bucket} instances.\n   */\n\n  /**\n   * @callback GetBucketsCallback\n   * @param {?Error} err Request error, if any.\n   * @param {Bucket[]} buckets Array of {@link Bucket} instances.\n   */\n\n  /**\n   * Get Bucket objects for all of the buckets in your project.\n   *\n   * @see [Buckets: list API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/list}\n   *\n   * @param {GetBucketsRequest} [query] Query object for listing buckets.\n   * @param {GetBucketsCallback} [callback] Callback function.\n   * @returns {Promise<GetBucketsResponse>}\n   *\n   * @example\n   * const {Storage} = require('@google-cloud/storage');\n   * const storage = new Storage();\n   * storage.getBuckets(function(err, buckets) {\n   *   if (!err) {\n   *     // buckets is an array of Bucket objects.\n   *   }\n   * });\n   *\n   * //-\n   * // To control how many API requests are made and page through the results\n   * // manually, set `autoPaginate` to `false`.\n   * //-\n   * const callback = function(err, buckets, nextQuery, apiResponse) {\n   *   if (nextQuery) {\n   *     // More results exist.\n   *     storage.getBuckets(nextQuery, callback);\n   *   }\n   *\n   *   // The `metadata` property is populated for you with the metadata at the\n   *   // time of fetching.\n   *   buckets[0].metadata;\n   *\n   *   // However, in cases where you are concerned the metadata could have\n   *   // changed, use the `getMetadata` method.\n   *   buckets[0].getMetadata(function(err, metadata, apiResponse) {});\n   * };\n   *\n   * storage.getBuckets({\n   *   autoPaginate: false\n   * }, callback);\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * storage.getBuckets().then(function(data) {\n   *   const buckets = data[0];\n   * });\n   *\n   * @example <caption>include:samples/buckets.js</caption>\n   * region_tag:storage_list_buckets\n   * Another example:\n   */\n\n\n  getBuckets(optionsOrCallback, cb) {\n    const _util_1$normalize = util_1.normalize(optionsOrCallback, cb),\n          options = _util_1$normalize.options,\n          callback = _util_1$normalize.callback;\n\n    options.project = options.project || this.projectId;\n    this.request({\n      uri: '/b',\n      qs: options\n    }, (err, resp) => {\n      if (err) {\n        callback(err, null, null, resp);\n        return;\n      }\n\n      const buckets = arrify(resp.items).map(bucket => {\n        const bucketInstance = this.bucket(bucket.id);\n        bucketInstance.metadata = bucket;\n        return bucketInstance;\n      });\n      const nextQuery = resp.nextPageToken ? Object.assign({}, options, {\n        pageToken: resp.nextPageToken\n      }) : null;\n      callback(null, buckets, nextQuery, resp);\n    });\n  }\n  /**\n   * @typedef {array} GetServiceAccountResponse\n   * @property {object} 0 The service account resource.\n   * @property {object} 1 The full\n   * [API\n   * response](https://cloud.google.com/storage/docs/json_api/v1/projects/serviceAccount#resource).\n   */\n\n  /**\n   * @callback GetServiceAccountCallback\n   * @param {?Error} err Request error, if any.\n   * @param {object} serviceAccount The serviceAccount resource.\n   * @param {string} serviceAccount.emailAddress The service account email\n   *     address.\n   * @param {object} apiResponse The full\n   * [API\n   * response](https://cloud.google.com/storage/docs/json_api/v1/projects/serviceAccount#resource).\n   */\n\n  /**\n   * Get the email address of this project's Google Cloud Storage service\n   * account.\n   *\n   * @see [Projects.serviceAccount: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/projects/serviceAccount/get}\n   * @see [Projects.serviceAccount Resource]{@link https://cloud.google.com/storage/docs/json_api/v1/projects/serviceAccount#resource}\n   *\n   * @param {object} [options] Configuration object.\n   * @param {string} [options.userProject] User project to be billed for this\n   *     request.\n   * @param {GetServiceAccountCallback} [callback] Callback function.\n   * @returns {Promise<GetServiceAccountResponse>}\n   *\n   * @example\n   * const {Storage} = require('@google-cloud/storage');\n   * const storage = new Storage();\n   *\n   * storage.getServiceAccount(function(err, serviceAccount, apiResponse) {\n   *   if (!err) {\n   *     const serviceAccountEmail = serviceAccount.emailAddress;\n   *   }\n   * });\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * storage.getServiceAccount().then(function(data) {\n   *   const serviceAccountEmail = data[0].emailAddress;\n   *   const apiResponse = data[1];\n   * });\n   */\n\n\n  getServiceAccount(optionsOrCallback, cb) {\n    const _util_1$normalize2 = util_1.normalize(optionsOrCallback, cb),\n          options = _util_1$normalize2.options,\n          callback = _util_1$normalize2.callback;\n\n    this.request({\n      uri: \"/projects/\".concat(this.projectId, \"/serviceAccount\"),\n      qs: options\n    }, (err, resp) => {\n      if (err) {\n        callback(err, null, resp);\n        return;\n      }\n\n      const camelCaseResponse = {};\n\n      for (const prop in resp) {\n        if (resp.hasOwnProperty(prop)) {\n          const camelCaseProp = prop.replace(/_(\\w)/g, (_, match) => match.toUpperCase());\n          camelCaseResponse[camelCaseProp] = resp[prop];\n        }\n      }\n\n      callback(null, camelCaseResponse, resp);\n    });\n  }\n\n}\n/**\n * {@link Bucket} class.\n *\n * @name Storage.Bucket\n * @see Bucket\n * @type {Constructor}\n */\n\n\nStorage.Bucket = bucket_1.Bucket;\n/**\n * {@link Channel} class.\n *\n * @name Storage.Channel\n * @see Channel\n * @type {Constructor}\n */\n\nStorage.Channel = channel_1.Channel;\n/**\n * {@link File} class.\n *\n * @name Storage.File\n * @see File\n * @type {Constructor}\n */\n\nStorage.File = file_1.File;\n/**\n * Cloud Storage uses access control lists (ACLs) to manage object and\n * bucket access. ACLs are the mechanism you use to share objects with other\n * users and allow other users to access your buckets and objects.\n *\n * This object provides constants to refer to the three permission levels that\n * can be granted to an entity:\n *\n *   - `gcs.acl.OWNER_ROLE` - (\"OWNER\")\n *   - `gcs.acl.READER_ROLE` - (\"READER\")\n *   - `gcs.acl.WRITER_ROLE` - (\"WRITER\")\n *\n * @see [About Access Control Lists]{@link https://cloud.google.com/storage/docs/access-control/lists}\n *\n * @name Storage.acl\n * @type {object}\n * @property {string} OWNER_ROLE\n * @property {string} READER_ROLE\n * @property {string} WRITER_ROLE\n *\n * @example\n * const {Storage} = require('@google-cloud/storage');\n * const storage = new Storage();\n * const albums = storage.bucket('albums');\n *\n * //-\n * // Make all of the files currently in a bucket publicly readable.\n * //-\n * const options = {\n *   entity: 'allUsers',\n *   role: storage.acl.READER_ROLE\n * };\n *\n * albums.acl.add(options, function(err, aclObject) {});\n *\n * //-\n * // Make any new objects added to a bucket publicly readable.\n * //-\n * albums.acl.default.add(options, function(err, aclObject) {});\n *\n * //-\n * // Grant a user ownership permissions to a bucket.\n * //-\n * albums.acl.add({\n *   entity: 'user-useremail@example.com',\n *   role: storage.acl.OWNER_ROLE\n * }, function(err, aclObject) {});\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * albums.acl.add(options).then(function(data) {\n *   const aclObject = data[0];\n *   const apiResponse = data[1];\n * });\n */\n\nStorage.acl = {\n  OWNER_ROLE: 'OWNER',\n  READER_ROLE: 'READER',\n  WRITER_ROLE: 'WRITER'\n};\nexports.Storage = Storage;\n/*! Developer Documentation\n *\n * These methods can be auto-paginated.\n */\n\npaginator_1.paginator.extend(Storage, 'getBuckets');\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\n\npromisify_1.promisifyAll(Storage, {\n  exclude: ['bucket', 'channel']\n});","map":null,"metadata":{},"sourceType":"script"}