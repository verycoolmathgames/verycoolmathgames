{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst zlib = require(\"zlib\");\n\nconst filter_1 = require(\"./filter\");\n\nclass CompressionHandler {\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  async writeMessage(message, compress) {\n    let messageBuffer = message;\n\n    if (compress) {\n      messageBuffer = await this.compressMessage(messageBuffer);\n    }\n\n    const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n    output.writeUInt8(compress ? 1 : 0, 0);\n    output.writeUInt32BE(messageBuffer.length, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n\n\n  async readMessage(data) {\n    const compressed = data.readUInt8(0) === 1;\n    let messageBuffer = data.slice(5);\n\n    if (compressed) {\n      messageBuffer = await this.decompressMessage(messageBuffer);\n    }\n\n    return messageBuffer;\n  }\n\n}\n\nclass IdentityHandler extends CompressionHandler {\n  async compressMessage(message) {\n    return message;\n  }\n\n  async writeMessage(message, compress) {\n    const output = Buffer.allocUnsafe(message.length + 5);\n    /* With \"identity\" compression, messages should always be marked as\n     * uncompressed */\n\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(message.length, 1);\n    message.copy(output, 5);\n    return output;\n  }\n\n  decompressMessage(message) {\n    return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n  }\n\n}\n\nclass DeflateHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.inflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n}\n\nclass GzipHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.unzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n}\n\nclass UnknownHandler extends CompressionHandler {\n  constructor(compressionName) {\n    super();\n    this.compressionName = compressionName;\n  }\n\n  compressMessage(message) {\n    return Promise.reject(new Error(\"Received message compressed wth unsupported compression method \".concat(this.compressionName)));\n  }\n\n  decompressMessage(message) {\n    // This should be unreachable\n    return Promise.reject(new Error(\"Compression method not supported: \".concat(this.compressionName)));\n  }\n\n}\n\nfunction getCompressionHandler(compressionName) {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n\n    case 'deflate':\n      return new DeflateHandler();\n\n    case 'gzip':\n      return new GzipHandler();\n\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\n\nclass CompressionFilter extends filter_1.BaseFilter {\n  constructor() {\n    super(...arguments);\n    this.sendCompression = new IdentityHandler();\n    this.receiveCompression = new IdentityHandler();\n  }\n\n  async sendMetadata(metadata) {\n    const headers = await metadata;\n    headers.set('grpc-encoding', 'identity');\n    headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n    return headers;\n  }\n\n  async receiveMetadata(metadata) {\n    const headers = await metadata;\n    const receiveEncoding = headers.get('grpc-encoding');\n\n    if (receiveEncoding.length > 0) {\n      const encoding = receiveEncoding[0];\n\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding);\n      }\n    }\n\n    headers.remove('grpc-encoding');\n    headers.remove('grpc-accept-encoding');\n    return headers;\n  }\n\n  async sendMessage(message) {\n    /* This filter is special. The input message is the bare message bytes,\n     * and the output is a framed and possibly compressed message. For this\n     * reason, this filter should be at the bottom of the filter stack */\n    const resolvedMessage = await message;\n    const compress = resolvedMessage.flags === undefined ? false : (resolvedMessage.flags & 2\n    /* NoCompress */\n    ) === 0;\n    return {\n      message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n      flags: resolvedMessage.flags\n    };\n  }\n\n  async receiveMessage(message) {\n    /* This filter is also special. The input message is framed and possibly\n     * compressed, and the output message is deframed and uncompressed. So\n     * this is another reason that this filter should be at the bottom of the\n     * filter stack. */\n    return this.receiveCompression.readMessage((await message));\n  }\n\n}\n\nexports.CompressionFilter = CompressionFilter;\n\nclass CompressionFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n\n  createFilter(callStream) {\n    return new CompressionFilter();\n  }\n\n}\n\nexports.CompressionFilterFactory = CompressionFilterFactory;","map":null,"metadata":{},"sourceType":"script"}