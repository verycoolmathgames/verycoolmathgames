{"ast":null,"code":"/*! firebase-admin v8.2.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils = require(\"../utils\");\n\nvar validator = require(\"../utils/validator\");\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar error_1 = require(\"../utils/error\");\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n */\n\n\nvar SAMLConfig =\n/** @class */\nfunction () {\n  /**\n   * The SAMLConfig constructor.\n   *\n   * @param {any} response The server side response used to initialize the SAMLConfig object.\n   * @constructor\n   */\n  function SAMLConfig(response) {\n    if (!response || !response.idpConfig || !response.spConfig || !response.name || !(validator.isString(response.name) && SAMLConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n\n    utils.addReadonlyGetter(this, 'providerId', SAMLConfig.getProviderIdFromResourceName(response.name)); // RP config.\n\n    utils.addReadonlyGetter(this, 'rpEntityId', response.spConfig.spEntityId);\n    utils.addReadonlyGetter(this, 'callbackURL', response.spConfig.callbackUri); // IdP config.\n\n    utils.addReadonlyGetter(this, 'idpEntityId', response.idpConfig.idpEntityId);\n    utils.addReadonlyGetter(this, 'ssoURL', response.idpConfig.ssoUrl);\n    utils.addReadonlyGetter(this, 'enableRequestSigning', !!response.idpConfig.signRequest);\n    var x509Certificates = [];\n\n    for (var _i = 0, _a = response.idpConfig.idpCertificates || []; _i < _a.length; _i++) {\n      var cert = _a[_i];\n\n      if (cert.x509Certificate) {\n        x509Certificates.push(cert.x509Certificate);\n      }\n    }\n\n    utils.addReadonlyGetter(this, 'x509Certificates', x509Certificates); // When enabled is undefined, it takes its default value of false.\n\n    utils.addReadonlyGetter(this, 'enabled', !!response.enabled);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName);\n  }\n  /**\n   * Converts a client side request to a SAMLConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a SAMLConfig request,\n   * returns null.\n   *\n   * @param {SAMLAuthProviderRequest} options The options object to convert to a server request.\n   * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n   * @return {?SAMLConfigServerRequest} The resulting server request or null if not valid.\n   */\n\n\n  SAMLConfig.buildServerRequest = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n\n    if (!makeRequest) {\n      return null;\n    }\n\n    var request = {}; // Validate options.\n\n    SAMLConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName; // IdP config.\n\n    if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n      request.idpConfig = {\n        idpEntityId: options.idpEntityId,\n        ssoUrl: options.ssoURL,\n        signRequest: options.enableRequestSigning,\n        idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : []\n      };\n\n      if (options.x509Certificates) {\n        for (var _i = 0, _a = options.x509Certificates || []; _i < _a.length; _i++) {\n          var cert = _a[_i];\n          request.idpConfig.idpCertificates.push({\n            x509Certificate: cert\n          });\n        }\n      }\n    } // RP config.\n\n\n    if (options.callbackURL || options.rpEntityId) {\n      request.spConfig = {\n        spEntityId: options.rpEntityId,\n        callbackUri: options.callbackURL\n      };\n    }\n\n    return request;\n  };\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param {string} resourceName The server side resource name.\n   * @return {?string} The provider ID corresponding to the resource, null otherwise.\n   */\n\n\n  SAMLConfig.getProviderIdFromResourceName = function (resourceName) {\n    // name is of form projects/project1/inboundSamlConfigs/providerId1\n    var matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n\n    return matchProviderRes[1];\n  };\n  /**\n   * @param {any} providerId The provider ID to check.\n   * @return {boolean} Whether the provider ID corresponds to a SAML provider.\n   */\n\n\n  SAMLConfig.isProviderId = function (providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n  };\n  /**\n   * Validates the SAMLConfig options object. Throws an error on failure.\n   *\n   * @param {SAMLAuthProviderRequest} options The options object to validate.\n   * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n   */\n\n\n  SAMLConfig.validate = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      idpEntityId: true,\n      ssoURL: true,\n      x509Certificates: true,\n      rpEntityId: true,\n      callbackURL: true,\n      enableRequestSigning: true\n    };\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n    } // Check for unsupported top level attributes.\n\n\n    for (var key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid SAML config parameter.\");\n      }\n    } // Required fields.\n\n\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('saml.') !== 0) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      // providerId is required and not provided correctly.\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n    }\n\n    if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') && !validator.isNonEmptyString(options.idpEntityId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') && !validator.isURL(options.ssoURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') && !validator.isNonEmptyString(options.rpEntityId)) {\n      throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') && !validator.isURL(options.callbackURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') && !validator.isArray(options.x509Certificates)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n    }\n\n    (options.x509Certificates || []).forEach(function (cert) {\n      if (!validator.isNonEmptyString(cert)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n      }\n    });\n\n    if (typeof options.enableRequestSigning !== 'undefined' && !validator.isBoolean(options.enableRequestSigning)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n    }\n\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n    }\n\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n    }\n  };\n  /** @return {SAMLAuthProviderConfig} The plain object representation of the SAMLConfig. */\n\n\n  SAMLConfig.prototype.toJSON = function () {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      idpEntityId: this.idpEntityId,\n      ssoURL: this.ssoURL,\n      x509Certificates: deep_copy_1.deepCopy(this.x509Certificates),\n      rpEntityId: this.rpEntityId,\n      callbackURL: this.callbackURL,\n      enableRequestSigning: this.enableRequestSigning\n    };\n  };\n\n  return SAMLConfig;\n}();\n\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n */\n\nvar OIDCConfig =\n/** @class */\nfunction () {\n  /**\n   * The OIDCConfig constructor.\n   *\n   * @param {any} response The server side response used to initialize the OIDCConfig object.\n   * @constructor\n   */\n  function OIDCConfig(response) {\n    if (!response || !response.issuer || !response.clientId || !response.name || !(validator.isString(response.name) && OIDCConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n    }\n\n    utils.addReadonlyGetter(this, 'providerId', OIDCConfig.getProviderIdFromResourceName(response.name));\n    utils.addReadonlyGetter(this, 'clientId', response.clientId);\n    utils.addReadonlyGetter(this, 'issuer', response.issuer); // When enabled is undefined, it takes its default value of false.\n\n    utils.addReadonlyGetter(this, 'enabled', !!response.enabled);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName);\n  }\n  /**\n   * Converts a client side request to a OIDCConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a OIDCConfig request,\n   * returns null.\n   *\n   * @param {OIDCAuthProviderRequest} options The options object to convert to a server request.\n   * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n   * @return {?OIDCConfigServerRequest} The resulting server request or null if not valid.\n   */\n\n\n  OIDCConfig.buildServerRequest = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n\n    if (!makeRequest) {\n      return null;\n    }\n\n    var request = {}; // Validate options.\n\n    OIDCConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName;\n    request.issuer = options.issuer;\n    request.clientId = options.clientId;\n    return request;\n  };\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param {string} resourceName The server side resource name\n   * @return {?string} The provider ID corresponding to the resource, null otherwise.\n   */\n\n\n  OIDCConfig.getProviderIdFromResourceName = function (resourceName) {\n    // name is of form projects/project1/oauthIdpConfigs/providerId1\n    var matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n\n    return matchProviderRes[1];\n  };\n  /**\n   * @param {any} providerId The provider ID to check.\n   * @return {boolean} Whether the provider ID corresponds to an OIDC provider.\n   */\n\n\n  OIDCConfig.isProviderId = function (providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n  };\n  /**\n   * Validates the OIDCConfig options object. Throws an error on failure.\n   *\n   * @param {OIDCAuthProviderRequest} options The options object to validate.\n   * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n   */\n\n\n  OIDCConfig.validate = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      clientId: true,\n      issuer: true\n    };\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n    } // Check for unsupported top level attributes.\n\n\n    for (var key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid OIDC config parameter.\");\n      }\n    } // Required fields.\n\n\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('oidc.') !== 0) {\n        throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n    }\n\n    if (!(ignoreMissingFields && typeof options.clientId === 'undefined') && !validator.isNonEmptyString(options.clientId)) {\n      throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.issuer === 'undefined') && !validator.isURL(options.issuer)) {\n      throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n    }\n\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n    }\n\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n    }\n  };\n  /** @return {OIDCAuthProviderConfig} The plain object representation of the OIDCConfig. */\n\n\n  OIDCConfig.prototype.toJSON = function () {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      issuer: this.issuer,\n      clientId: this.clientId\n    };\n  };\n\n  return OIDCConfig;\n}();\n\nexports.OIDCConfig = OIDCConfig;","map":null,"metadata":{},"sourceType":"script"}