{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst http2 = require(\"http2\");\n\nconst _http2$constants = http2.constants,\n      HTTP2_HEADER_AUTHORITY = _http2$constants.HTTP2_HEADER_AUTHORITY,\n      HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,\n      HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD,\n      HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH,\n      HTTP2_HEADER_TE = _http2$constants.HTTP2_HEADER_TE,\n      HTTP2_HEADER_USER_AGENT = _http2$constants.HTTP2_HEADER_USER_AGENT;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\n\nconst KEEPALIVE_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nclass Http2SubChannel extends events_1.EventEmitter {\n  constructor(target, connectionOptions, userAgent, channelArgs) {\n    super();\n    this.refCount = 0;\n    this.keepaliveTimeMs = KEEPALIVE_TIME_MS;\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    this.session = http2.connect(target, connectionOptions);\n    this.session.unref();\n    this.session.on('connect', () => {\n      this.emit('connect');\n    });\n    this.session.on('close', () => {\n      this.stopKeepalivePings();\n      this.emit('close');\n    });\n    this.session.on('error', () => {\n      this.stopKeepalivePings();\n      this.emit('close');\n    });\n    this.session.on('goaway', () => {\n      this.stopKeepalivePings();\n      this.emit('close');\n    });\n    this.userAgent = userAgent;\n\n    if (channelArgs['grpc.keepalive_time_ms']) {\n      this.keepaliveTimeMs = channelArgs['grpc.keepalive_time_ms'];\n    }\n\n    if (channelArgs['grpc.keepalive_timeout_ms']) {\n      this.keepaliveTimeoutMs = channelArgs['grpc.keepalive_timeout_ms'];\n    }\n\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n\n  ref() {\n    if (this.refCount === 0) {\n      this.session.ref();\n      this.startKeepalivePings();\n    }\n\n    this.refCount += 1;\n  }\n\n  unref() {\n    this.refCount -= 1;\n\n    if (this.refCount === 0) {\n      this.session.unref();\n      this.stopKeepalivePings();\n    }\n  }\n\n  sendPing() {\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.emit('close');\n    }, this.keepaliveTimeoutMs);\n    this.session.ping((err, duration, payload) => {\n      clearTimeout(this.keepaliveTimeoutId);\n    });\n  }\n  /* TODO(murgatroid99): refactor subchannels so that keepalives can be handled\n   * per subchannel */\n\n\n  startKeepalivePings() {\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    this.sendPing();\n  }\n\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  } // Prerequisite: this subchannel is connected\n\n\n  startCallStream(metadata, callStream) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    const http2Stream = this.session.request(headers);\n    this.ref();\n    http2Stream.on('close', () => {\n      this.unref();\n    });\n    callStream.attachHttp2Stream(http2Stream);\n  }\n\n  close() {\n    this.session.close();\n  }\n\n}\n\nexports.Http2SubChannel = Http2SubChannel;","map":null,"metadata":{},"sourceType":"script"}