{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst call_1 = require(\"./call\");\n\nconst channel_1 = require(\"./channel\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst CHANNEL_SYMBOL = Symbol();\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\n\nclass Client {\n  constructor(address, credentials, options = {}) {\n    if (options.channelOverride) {\n      this[CHANNEL_SYMBOL] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      this[CHANNEL_SYMBOL] = options.channelFactoryOverride(address, credentials, options);\n    } else {\n      this[CHANNEL_SYMBOL] = new channel_1.Http2Channel(address, credentials, options);\n    }\n  }\n\n  close() {\n    this[CHANNEL_SYMBOL].close();\n  }\n\n  getChannel() {\n    return this[CHANNEL_SYMBOL];\n  }\n\n  waitForReady(deadline, callback) {\n    const checkState = err => {\n      if (err) {\n        callback(new Error('Failed to connect before the deadline'));\n        return;\n      }\n\n      let newState;\n\n      try {\n        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n        return;\n      }\n\n      if (newState === channel_1.ConnectivityState.READY) {\n        callback();\n      } else {\n        try {\n          this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n        }\n      }\n    };\n\n    setImmediate(checkState);\n  }\n\n  handleUnaryResponse(call, deserialize, callback) {\n    let responseMessage = null;\n    call.on('data', data => {\n      if (responseMessage != null) {\n        call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n      }\n\n      try {\n        responseMessage = deserialize(data);\n      } catch (e) {\n        call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');\n      }\n    });\n    call.on('end', () => {\n      if (responseMessage == null) {\n        call.cancelWithStatus(constants_1.Status.INTERNAL, 'Not enough responses received');\n      }\n    });\n    call.on('status', status => {\n      /* We assume that call emits status after it emits end, and that it\n       * accounts for any cancelWithStatus calls up until it emits status.\n       * Therefore, considering the above event handlers, status.code should be\n       * OK if and only if we have a non-null responseMessage */\n      if (status.code === constants_1.Status.OK) {\n        callback(null, responseMessage);\n      } else {\n        const error = Object.assign(new Error(status.details), status);\n        callback(error);\n      }\n    });\n  }\n\n  checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n    if (arg1 instanceof Function) {\n      return {\n        metadata: new metadata_1.Metadata(),\n        options: {},\n        callback: arg1\n      };\n    } else if (arg2 instanceof Function) {\n      if (arg1 instanceof metadata_1.Metadata) {\n        return {\n          metadata: arg1,\n          options: {},\n          callback: arg2\n        };\n      } else {\n        return {\n          metadata: new metadata_1.Metadata(),\n          options: arg1,\n          callback: arg2\n        };\n      }\n    } else {\n      if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && arg3 instanceof Function)) {\n        throw new Error('Incorrect arguments passed');\n      }\n\n      return {\n        metadata: arg1,\n        options: arg2,\n        callback: arg3\n      };\n    }\n  }\n\n  makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n    var _this$checkOptionalUn = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n\n    metadata = _this$checkOptionalUn.metadata;\n    options = _this$checkOptionalUn.options;\n    callback = _this$checkOptionalUn.callback;\n    const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n\n    const message = serialize(argument);\n    const writeObj = {\n      message\n    };\n    call.sendMetadata(metadata);\n    call.write(writeObj);\n    call.end();\n    this.handleUnaryResponse(call, deserialize, callback);\n    return new call_1.ClientUnaryCallImpl(call);\n  }\n\n  makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n    var _this$checkOptionalUn2 = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n\n    metadata = _this$checkOptionalUn2.metadata;\n    options = _this$checkOptionalUn2.options;\n    callback = _this$checkOptionalUn2.callback;\n    const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n\n    call.sendMetadata(metadata);\n    this.handleUnaryResponse(call, deserialize, callback);\n    return new call_1.ClientWritableStreamImpl(call, serialize);\n  }\n\n  checkMetadataAndOptions(arg1, arg2) {\n    let metadata;\n    let options;\n\n    if (arg1 instanceof metadata_1.Metadata) {\n      metadata = arg1;\n\n      if (arg2) {\n        options = arg2;\n      } else {\n        options = {};\n      }\n    } else {\n      if (arg1) {\n        options = arg1;\n      } else {\n        options = {};\n      }\n\n      metadata = new metadata_1.Metadata();\n    }\n\n    return {\n      metadata,\n      options\n    };\n  }\n\n  makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n    var _this$checkMetadataAn = this.checkMetadataAndOptions(metadata, options);\n\n    metadata = _this$checkMetadataAn.metadata;\n    options = _this$checkMetadataAn.options;\n    const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n\n    const message = serialize(argument);\n    const writeObj = {\n      message\n    };\n    call.sendMetadata(metadata);\n    call.write(writeObj);\n    call.end();\n    return new call_1.ClientReadableStreamImpl(call, deserialize);\n  }\n\n  makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n    var _this$checkMetadataAn2 = this.checkMetadataAndOptions(metadata, options);\n\n    metadata = _this$checkMetadataAn2.metadata;\n    options = _this$checkMetadataAn2.options;\n    const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n\n    call.sendMetadata(metadata);\n    return new call_1.ClientDuplexStreamImpl(call, serialize, deserialize);\n  }\n\n}\n\nexports.Client = Client;","map":null,"metadata":{},"sourceType":"script"}